26 중급-재귀-백트래킹
=======================
# 1. N-Queen : https://www.acmicpc.net/problem/9663
    
* N x N 크기의 체스판 위에 Queen을 N개 놓는 방법의 수를 구하는 문제   
* calc(row) : row 행에 퀸을 어디에 놓을지 결정하는 함수   
     
```c++
void calc(int row){
    if(row == n){
        ans += 1;
    }
    for(int col=0; col < n; col++){
        a[row][col] = true;
        if(check(row, col)){
            calc(row+1);
        }
        a[row][calc] = false;
    }
}
```

```c++
#include <iostream>
#include <string.h>
#include <algorithm>
#include <vector>
using namespace std;

bool a[15][15];
int n;
int ans = 0;

bool check(int row, int col) { // 로우와 컬럼 입력.
    // |
    for (int i=0; i<n; i++) {
        if (i == row) continue; // 같은 로우이면 불가능
        if (a[i][col]) { // 하나라도 같은 col에 있다면
            return false; // false 리턴
        }
    }
    // 왼쪽 위 대각선
    int x = row-1; // 왼쪽 대각선이니까 row-1
    int y = col-1; // 컬럼 -1 -> 즉 \ 형태.
    while (x >=0 && y >=0) { // 0이 될때까지 반복
        if (a[x][y] == true) { // 하나라도 있으면
            return false; // false 리턴
        }
        x -= 1; // 왼쪽 대각선 이동
        y -= 1; // 왼쪽 대각선 이동
    }
    // /
    x = row-1; // 오른쪽 행 시작
    y = col+1; // 오른쪽 컬럼 시작
    
    while (x >=0 && y < n) { // 오른쪽 끝에 갈때까지.
        if (a[x][y] == true) { // 하나라도 있으면
            return false; // false 리턴.
        }
        x -=1; // 오른쪽으로 쭉 이동
        y += 1; // 마찬가지
    }
    return true; // 여기까지 무리 없이 왔다면 true 리턴
}
void calc(int row) {
    if (row == n) { // 로우가 n까지 도달했다면 무리 없이 돌았다는 뜻
        ans += 1; // 경우의 수 1 증가
    }
    for (int col=0; col<n; col++) { // 컬럼 0부터 시작.
        a[row][col] = true; // 현재 위치에 퀸을 놓고
        if (check(row, col)) { // 가능한지 확인
            calc(row+1); // 가능하다면 다음 로우로 이동.
        }
        a[row][col] = false; // 끝났다면 해당 컬럼에서 퀸 제거해서 다음 컬럼 가능하도록. 함.
    }
}
int main() {
    cin >> n;
    calc(0);
    cout << ans << '\n';
    return 0;
}

```

**개선된 방법**
```c++
#include <iostream>
#include <string.h>
#include <algorithm>
#include <vector>

using namespace std;
bool a[15][15];
int n;
bool check_col[15];
bool check_dig[40];
bool check_dig2[40];

bool check(int row, int col) {
    // |
    if (check_col[col]) { // 해당 컬럼에 있을 경우 false
        return false;
    }
    // 오른쪽 위 대각선
    if (check_dig[row+col]) { // 오른쪽 대각선에 있을 경우 false
        return false;
    }
    // 왼쪽 대각선
    if (check_dig2[row-col+n]) { // 왼쪽 대각선에 있을 경우 false
        return false;
    }
    return true;
}
int calc(int row) {
    if (row == n) {
        // ans += 1;
        return 1;
    }
    int cnt = 0;
    for (int col=0; col<n; col++) {
        if (check(row, col)) {
            check_dig[row+col] = true; // 오른쪽 대각선에 있다고 표시 -> 03,12,21,30 오른쪽 대각선임
            check_dig2[row-col+n] = true; // 왼쪽 대각선, 음수 나 올 수 있으니 양수처리로 +N
            check_col[col] = true; // 컬럼 true;
            a[row][col] = true;
            cnt += calc(row+1);
            check_dig[row+col] = false;
            check_dig2[row-col+n] = false;
            check_col[col] = false;
            a[row][col] = false;
        }
    }
    return cnt;
}
int main() {
    cin >> n;
    cout << calc(0) << '\n';
    return 0;
}

```

***
# 2.  : https://www.acmicpc.net/problem/1182
