다이나믹 프로그래밍1 
=======================
# 1. 다이나믹 프로그래밍(동적계획법)  
   
* 큰 문제를 작은 문제로 나눠서 푸는 알고리즘     
* Dynamic Programming의 다이나믹은 아무 의미가 없다.    
* 이 용어를 처음 사용한 1940년 Richard Bellman은 멋있어 보여서 사용했다고 한다 ㅋㅋㅋ      
      
**다이나믹 프로그래밍(동적계획법) 속성**       
    
다이나믹 프로그래밍이 수행되려면 2가지 속성이 만족해야 된다.      
      
* Overlapping Subproblem : 겹치는 부분(작은)문제       
* Optimal Substructure : 최적부분구조       
       
피보나치 수열을 기준으로 두 속성의 사용처를 알아보겠다.   
   
## 1.1. Overlapping Subproblem : 겹치는 부분(작은)문제      
**피보나치 수열**
* f0 = 0   
* f1 = 1   
* fn = fn-1 + fn-2 (n >= 2)  
```
0,1,1,2,3,5,8,13,21,34,55....
```
* 문제 : N번째 피보나치 수를 구하는 문제  
* 작은 문제 : N-1 번째 피보나치 수를 구하는 문제, N-2 번째 피보나치 수를 구하는 문제 
* 위 같은 동작이 마지막 까지 반복....

큰 문제와 작은 문제는 상대적이다.      
문제를 작은 문제로 쪼갬으로 같은 형식의 구조를 취하고 있으니     
**큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.**      

## 1.2. Optimal Substructure : 최적부분구조           
* 문제의 정답을 작은 문제의 정답을 통해 얻을 수 있다.    
    
**예시**        
* 서울에서 부산을 가는 가장 빠른 길이 ```대전```, ```대구```를 순서대로 거쳐야 한다면      
* 대전에서 부산을 가는 가장 바른 길은 ```대구```를 거쳐가야 한다.           
      
이를 다시 피보나치로 대입시켜 보면 피보나치의 작은 문제들로 큰 문제의 값을 도출해내는 것이다.     
     
**꿀팁**   
Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.     
  
* 10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* 9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* ...
* 5번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* 4번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
        
위에서 말하는 4번째 피보나치 수는 모두 같다!!!
하지만 여기서 알 수 있듯이 중복이 계속해서 발생하게 된다.   

## 1.3. 다이나믹 프로그래밍의 특징   
* 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.  
* Optimal Substructure를 만족하기 때문에, **같은 문제는 구할 때마다 정답이 같다.**   
* 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.   
* 이렇게 저장함으로써 중복된 계산을 진행하지 않고 빠르게 값만 활용할 수 있도록 한다.  
* 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.   
* 메모를 한다고 해서 영어로 Memorization이라고 한다.  

**일반적인 피보나치 수열**   
```c++
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```
이런식으로 코드를 작성할 경우 중복된 계산식이 많아져서 ```O(2^n)``` 의 복잡도를 가진다.
   
다이나믹 프로그래밍은 문제를 한번만 푸는 것이 좋다.   
이제 위의 코드를 Memorization을 이용하여 계산 복잡도를 낮춰보겠다.   

**1차 메모 피보나치 수열**   
```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```
메모 기능을 작성했지만 아직 있는지 없는지 검사하여 계산을 진행 안하는 부분이 빠졌다.       
    
**2차 메모 피보나치 수열**   
```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    if(memo[n] > 0){ // 여기서 0은 아직 값을 넣지 않았다는 뜻
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```
```함수의 시간복잡도 = 문제의 개수 x 문제 1개를 푸는 시간```에 의거하여       
* 문제의 개수 : N          
* 문제 1개를 푸는 시간 : 1 (더하기 연산만 있으므로)              
* 함수의 시간 복잡도 : O(N)            
의 결과를 나타내게 된다.       


***
# 2. 쇠막대기
* 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ```'()'```으로 표현된다.     
* 또한, 모든 ```'()'```는 반드시 레이저를 표현한다.      
* 쇠막대기의 왼쪽 끝은 여는 괄호 ```(```로, 오른쪽 끝은 닫힌 괄호 ```)```로 표현된다.   

* 올바른 괄호 문자열과 비슷하게 풀 수 있다.  
* ```()```가 나올 때 마다 스택에 들어있는 ```(``` 의 개수를 세어준다
* 그런데 , ```)```가 나왔을 때, 이것이 레이저인지 쇠막대인지 구문을 해줘야 한다.  
* 레이저는 항상 ```()```와 같이 붙어진 상태로 나온다 
* 스택에 ```(```의 인덱스를 넣어서 인덱스가 1차이 나는지 확인해야 한다.  

여기서 우리가 생각해볼 수 있는 점은 
```
레이저는 항상 ```()```와 같이 붙어진 상태로 나온다
```
이를 다르게 생각해보면 레이저는 괄호가 서로 붙어있다는 뜻이고 이는 인덱스가 1개밖에 차이가 안난다는 뜻이다.   

기준 : ```( ( ( ( ) ( ) ) ( ( ) ) ( ) ) ) ```
1,2,3,4 진행         
**5번 닫는 괄호가 나왔을 때**      
* 스택 : ```[1,2,3,4]```     
* 스택의 top 과 인덱스 차이가 1나기 때문에 레이져  
* 스택 : ```[1,2,3]```
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : 3     
   
6진행      
**7번 닫는 괄호가 나왔을 때**  
* 스택 : ```[1,2,3,6]```       
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저    
* 스택 : ```[1,2,3]```     
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.    
* 정답 : ```3 + 3 = 6```  
  
**8번 닫는 괄호가 나왔을 때**    
* 스택 : ```[1,2,3]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1,2]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 = 7```   
   
9,10 진행    
**11번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2,9,10]```     
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저  
* 스택 : ```[1,2,9]```   
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : ```3 + 3 + 1 + 3 = 10```   
   
**12번 닫는 괄호가 나왔을 때**    
* 스택 : ```[1,2,9]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1,2]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 1= 11```    
    
13번 진행
**14번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2,13]```     
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저  
* 스택 : ```[1,2]```   
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : ```3 + 3 + 1 + 3 + 2 = 12``` 

**15번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 2 + 1 = 13```   

**16번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[x]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 2 + 1 + 1 = 14```    

```c++
#include <string>
#include <stack> 
#include <iostream>

using namespace std; 
int main(void) { 
    
    stack<int> s;
    string str;
    cin >> str; 
    
    int len = str.size();
    int sum = 0;
    for(int i = 0; i < len; i++){
		if(str[i] == '('){
			s.push(i);
		} else {
			if(s.top()+1 == i){
				s.pop();
				sum += s.size();
			} else {
				s.pop();
				sum += 1;
			}
		}
	}
    
    cout << sum << '\n';
    return 0; 
}
```
   
***
# 3. 오큰수 (오른쪽에 있으면서 가장 가까운 큰수)   
* 크기가 N인 수열 A=A_1,A_2...A_N이 있고, 각 원소 A_i의 오큰수 NGE(i)를 구하려고 한다.  
* A_i의 오큰수는 오른쪽에 있으면서 A_i보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다.   
그러한 수가 없는 경우에 오큰수는 -1 이다.     
* ```A = [3,5,2,7]``` -> ```NGE = [5,7,7,-1]```   
* ```A = [9,5,4,8]``` -> ```NGE = [-1,8,8,-1]```   

여기에서 한가지 생각할 점이 있는데 아래 주석을 보자  
```
[5,.....2,7] 이 존재한다고 가정시 오큰수가 [7......,-1] 인 경우는 
다시 생각해보면 5와 7 사이에는 5보다 큰수가 없다는 뜻을 의미한다.  
그리고 마지막 숫자는 오른쪽에 더는 숫자가 존재하지 않으므로 -1 값을 가질 수 밖에 없다.  
```
    
다시 시나리오대로 분석해보자     
```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|       |       |       |       |    
_____|_______|_______|_______|_______|
```
1. A[1] = 3 인 경우 아직 오큰수를 찾을 수 없다. 스택에 위치 1을 넣는다.
```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|   5   |       |       |       |    
_____|_______|_______|_______|_______|
```
2. A[2] = 5, 스택 = [1]   
	* 스택의 가장 위의 있는 수 A[1] = 3이고, 현재 수는 A[2] = 5 이다.   
	* A[1] < A[2] 이기 대문에 , NGE(1) = 5 인 것을 알 수 있다.	
	* 스택 = []
	* 더 이상 스택에 수가 없기 때문에, 위치2를 스택에 넣는다. 
	* 스택 = [2]   

```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|   5   |       |       |       |    
_____|_______|_______|_______|_______|
```

3. A[3] = 2, 스택 = [2]   
	* 스택의 가장 위에 있는 수 A[2] = 5이고, 현재 수는 A[3] = 2 이다.  
	* A[2] > A[3]이기 때문에, 현재 스택에 있는 수의 오큰수는 A[3]이 아니다. 
	* 스택에 들어있는 수의 오큰수는 3보다 큰 위치에 있기 때문에, 그냥 넘어간다.  
	* 위치 3을 스택에 넣는다. 
	* 스택 = [2,3]   
```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|   5   |       |   7   |       |    
_____|_______|_______|_______|_______|
```	
4. A[4] = 7, 스택 = [2,3]   
	* 스택의 가장 위에 있는 수 A[3] = 2이고, 현재 수는 A[4] = 7 이다.  
	* A[3] < A[4]이기 때문에, NGE(3) = 7 인 것을 알 수 있다.   
	* 스택 = [2]
```
_____________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|   5   |   7   |   7   |  -1   |    
_____|_______|_______|_______|_______|
```
5. 스택에 [2] 만 남았는데 비교시 A[2] < A[4] 이기 때문에, NGE(2) = 7이다.  	
6. 마지막 NGE는 진척이 불가능 하므로 -1의 값을 넣어준다.  

```c++
int n;
cin >> n;
vector<int> a(n);
vector<int> ans(n);
for(int i=0; i< n; i++){
	cin >> a[i];
}
stack<int> s;
s.push(0);
for(int i=1;i<n;i++){
	if(s.empty()){
		s.push(i);
	}
	while(!s.empty() && a[s.top()] < a[i]){
		ans[s.top()] = a[i];
		s.pop();
	}
	s.push(i);
}
while (!s.empty()){
	ans[s.top()] = -1;
	s.pop();
}
for (int i=0; i < n; i++){
	cout >> ans[i] << ' ';
}
cout << '\n';
return 0;
```
   
***
# 4. 오등큰수 (등장횟수)
```c++
int n;
cin >> n;
vector<int> a(n);
vector<int> ans(n);
for(int i=0; i< n; i++){
	cin >> a[i];
}
stack<int> s;
s.push(0);
for(int i=1;i<n;i++){
	if(s.empty()){
		s.push(i);
	}
	while(!s.empty() && freq[a[s.top()]] < freq[a[i]]){
		ans[s.top()] = a[i];
		s.pop();
	}
	s.push(i);
}
while (!s.empty()){
	ans[s.top()] = -1;
	s.pop();
}
for (int i=0; i < n; i++){
	cout >> ans[i] << ' ';
}
cout << '\n';
return 0;
```
