다이나믹 프로그래밍1 
=======================
# 1. 다이나믹 프로그래밍(동적계획법)  
   
* 큰 문제를 작은 문제로 나눠서 푸는 알고리즘     
* Dynamic Programming의 다이나믹은 아무 의미가 없다.    
* 이 용어를 처음 사용한 1940년 Richard Bellman은 멋있어 보여서 사용했다고 한다 ㅋㅋㅋ      
      
**다이나믹 프로그래밍(동적계획법) 속성**       
    
다이나믹 프로그래밍이 수행되려면 2가지 속성이 만족해야 된다.      
      
* Overlapping Subproblem : 겹치는 부분(작은)문제       
* Optimal Substructure : 최적부분구조       
       
피보나치 수열을 기준으로 두 속성의 사용처를 알아보겠다.   
   
## 1.1. Overlapping Subproblem : 겹치는 부분(작은)문제      
**피보나치 수열**
* f0 = 0   
* f1 = 1   
* fn = fn-1 + fn-2 (n >= 2)  
```
0,1,1,2,3,5,8,13,21,34,55....
```
* 문제 : N번째 피보나치 수를 구하는 문제  
* 작은 문제 : N-1 번째 피보나치 수를 구하는 문제, N-2 번째 피보나치 수를 구하는 문제 
* 위 같은 동작이 마지막 까지 반복....

큰 문제와 작은 문제는 상대적이다.      
문제를 작은 문제로 쪼갬으로 같은 형식의 구조를 취하고 있으니     
**큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.**      

## 1.2. Optimal Substructure : 최적부분구조           
* 문제의 정답을 작은 문제의 정답을 통해 얻을 수 있다.    
    
**예시**        
* 서울에서 부산을 가는 가장 빠른 길이 ```대전```, ```대구```를 순서대로 거쳐야 한다면      
* 대전에서 부산을 가는 가장 바른 길은 ```대구```를 거쳐가야 한다.           
      
이를 다시 피보나치로 대입시켜 보면 피보나치의 작은 문제들로 큰 문제의 값을 도출해내는 것이다.     
     
**꿀팁**   
Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.     
  
* 10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* 9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* ...
* 5번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* 4번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
        
위에서 말하는 4번째 피보나치 수는 모두 같다!!!
하지만 여기서 알 수 있듯이 중복이 계속해서 발생하게 된다.   

## 1.3. 다이나믹 프로그래밍의 특징   
* 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.  
* Optimal Substructure를 만족하기 때문에, **같은 문제는 구할 때마다 정답이 같다.**   
* 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.   
* 이렇게 저장함으로써 중복된 계산을 진행하지 않고 빠르게 값만 활용할 수 있도록 한다.  
* 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.   
* 메모를 한다고 해서 영어로 Memorization이라고 한다.  

**일반적인 피보나치 수열**   
```c++
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```
이런식으로 코드를 작성할 경우 중복된 계산식이 많아져서 ```O(2^n)``` 의 복잡도를 가진다.
   
다이나믹 프로그래밍은 문제를 한번만 푸는 것이 좋다.   
이제 위의 코드를 Memorization을 이용하여 계산 복잡도를 낮춰보겠다.   

**1차 메모 피보나치 수열**   
```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```
메모 기능을 작성했지만 아직 있는지 없는지 검사하여 계산을 진행 안하는 부분이 빠졌다.       
    
**2차 메모 피보나치 수열**   
```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    if(memo[n] > 0){ // 여기서 0은 아직 값을 넣지 않았다는 뜻
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```
```함수의 시간복잡도 = 문제의 개수 x 문제 1개를 푸는 시간```에 의거하여       
* 문제의 개수 : N          
* 문제 1개를 푸는 시간 : 1 (더하기 연산만 있으므로)              
* 함수의 시간 복잡도 : O(N)            
   
의 결과를 나타내게 된다.       


***
# 2. 다이나믹 프로그래밍 구현 방식  
다이나믹 프로그래밍의 구현 방식에는 2가지 방법이 있다.  
   
1. Top-down
2. Bottom-up  

## 2.1. Top-down
Top-down 방식은 큰 문제를 작은 문제로 나누어서 푸는 것이다.  

1. 큰 문제를 작은 문제로 나눈다.  
2. 작은 문제를 푼다.  
3. 작은 문제를 풀었으니, 이제 큰 문제를 푼다.   
    
Top-down 방식은 이전에 우리가 했던 **재귀를 이용한** 피보나치 수열을 의미한다.     
큰 재귀 함수로부터 작은 재귀로 나뉘어져 작은 문제들을 해결하면서 올라오기 때문이다.   

1. 문제를 풀어야 한다. 
   * fibonacci(n)
2. 문제를 작은 문제로 나눈다.
   * fibonacci(n-1) 과 fibonacci(n-2)로 문제를 나눈다.  
3. 작은 문제를 푼다.  
   * fibonacci(n-1) 과 fibonacci(n-2)를 호출하여 문제를 푼다.   
4. 작은 문제를 풀었으니, 이제 문제를 푼다.  
   * fibonacci(n-1) 값과 fibonacci(n-2)의 값을 더해 문제를 푼다.   

**피보나치 수열**   
```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    if(memo[n] > 0){ // 여기서 0은 아직 값을 넣지 않았다는 뜻
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```

## 2.2. Bottom-up     
Botton-up 방식은 작은 문제부터 연산하여 큰 문제를 푸는 것이다.     
Top-down 방식과 헷갈리지만       
Top-down은 큰 문제에서 시작해서 작은 문제로 나누어 푸는것이고      
Botton-up은 애초에 작은 문제를 풀어서 후에 큰 문제를 푸는 것으로 시작 환경이 다르다.      

1. 문제를 크기가 작은 문제부터 차례대로 푼다.  
2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.  
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.  
4. 반복하다 보면 가장 큰 문제를 풀 수 있다.

**Bottom-up 방식의 피보나치 수열**
```c++
int d[100];
int fibonacci(int n){
   d[0] = 0;
   d[1] = 1;
   for(int i=2; i <= n; i++){
      d[i] = d[i-1] + d[i-2];
   }
   return d[n];
}
```
1. 문제를 크기가 작은 문제부터 차례대로 푼다.  
   * for(int i=2; i <= n; i++)
2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
   * for(int i=2; i <= n; **i++**)
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.  
   * d[i] = d[i-1] + d[i-2];
4. 반복하다 보면 가장 큰 문제를 풀 수 있다.
   * d[n]을 구하게 된다.  
