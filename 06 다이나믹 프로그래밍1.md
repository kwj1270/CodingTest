다이나믹 프로그래밍1 
=======================
# 1. 다이나믹 프로그래밍(동적계획법)  
   
* 큰 문제를 작은 문제로 나눠서 푸는 알고리즘     
* Dynamic Programming의 다이나믹은 아무 의미가 없다.    
* 이 용어를 처음 사용한 1940년 Richard Bellman은 멋있어 보여서 사용했다고 한다 ㅋㅋㅋ      
      
**다이나믹 프로그래밍(동적계획법) 속성**       
    
다이나믹 프로그래밍이 수행되려면 2가지 속성이 만족해야 된다.      
      
* Overlapping Subproblem : 겹치는 부분(작은)문제       
* Optimal Substructure : 최적부분구조       
       
피보나치 수열을 기준으로 두 속성의 사용처를 알아보겠다.   
   
## 1.1. Overlapping Subproblem : 겹치는 부분(작은)문제      
**피보나치 수열**
* f0 = 0   
* f1 = 1   
* fn = fn-1 + fn-2 (n >= 2)  
```
0,1,1,2,3,5,8,13,21,34,55....
```
* 문제 : N번째 피보나치 수를 구하는 문제  
* 작은 문제 : N-1 번째 피보나치 수를 구하는 문제, N-2 번째 피보나치 수를 구하는 문제 
* 위 같은 동작이 마지막 까지 반복....

큰 문제와 작은 문제는 상대적이다.      
문제를 작은 문제로 쪼갬으로 같은 형식의 구조를 취하고 있으니     
**큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.**      

## 1.2. Optimal Substructure : 최적부분구조           
* 문제의 정답을 작은 문제의 정답을 통해 얻을 수 있다.    
    
**예시**        
* 서울에서 부산을 가는 가장 빠른 길이 ```대전```, ```대구```를 순서대로 거쳐야 한다면      
* 대전에서 부산을 가는 가장 바른 길은 ```대구```를 거쳐가야 한다.           
      
이를 다시 피보나치로 대입시켜 보면 피보나치의 작은 문제들로 큰 문제의 값을 도출해내는 것이다.     
     
**꿀팁**   
Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.     
  
* 10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* 9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* ...
* 5번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
* 4번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
        
위에서 말하는 4번째 피보나치 수는 모두 같다!!!
하지만 여기서 알 수 있듯이 중복이 계속해서 발생하게 된다.   

## 1.3. 다이나믹 프로그래밍의 특징   
* 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.  
* Optimal Substructure를 만족하기 때문에, **같은 문제는 구할 때마다 정답이 같다.**   
* 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.   
* 이렇게 저장함으로써 중복된 계산을 진행하지 않고 빠르게 값만 활용할 수 있도록 한다.  
* 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.   
* 메모를 한다고 해서 영어로 Memorization이라고 한다.  

**일반적인 피보나치 수열**   
```c++
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```
이런식으로 코드를 작성할 경우 중복된 계산식이 많아져서 ```O(2^n)``` 의 복잡도를 가진다.
   
다이나믹 프로그래밍은 문제를 한번만 푸는 것이 좋다.   
이제 위의 코드를 Memorization을 이용하여 계산 복잡도를 낮춰보겠다.   

**1차 메모 피보나치 수열**   
```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```
메모 기능을 작성했지만 아직 있는지 없는지 검사하여 계산을 진행 안하는 부분이 빠졌다.       
    
**2차 메모 피보나치 수열**   
```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    if(memo[n] > 0){ // 여기서 0은 아직 값을 넣지 않았다는 뜻
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```
```함수의 시간복잡도 = 문제의 개수 x 문제 1개를 푸는 시간```에 의거하여       
* 문제의 개수 : N          
* 문제 1개를 푸는 시간 : 1 (더하기 연산만 있으므로)              
* 함수의 시간 복잡도 : O(N)            
의 결과를 나타내게 된다.       


***
# 2. 쇠막대기
