합분해까지
=======================  
# 1. 1,2,3 더하기 3  
* 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제  
* n = 4
* 1+1+1+1
* 1+1+2
* 1+2+1
* 2+1+1
* 2+2
* 1+3
* 3+1
   
이전에 했던 방법에 최적의 연산을 사용해야하고 숫자만 바꿔준것    
    
**코드**
```c++

#include <iostream>
using namespace std;

long long d[1000000];
int main() {

	int t;
	cin >> t;
	cin.ignore();

	while(t--){
		ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);

		int n ;
		cin >> n;
		cin.ignore();

		d[0] = 1;
		d[1] = 1;
		d[2] = 2;
		d[3] = 4;

		for (int i=4; i<=n; i++) {
			d[i] = 0;
		}
		for (int i=4; i <= n; i++) {
				d[i] += (d[i-1]+d[i-2]+d[i-3]) % 1000000009; 
		}
		cout << d[n] << "\n";
	}
}
```
    
    
    
***    
# 2. RGB거리           
* RGB 거리에 사는 사람들은 집을 빨강, 초록, 파랑중에 하나로 칠하려고한다.  
* 또한, 그들의 모든 이웃은 같은 색으로 칠할 수 없다는 규칙도 정했다.   
* 집 i의 이웃은 집 i-1과 집 i+1이고, 첫 집과 마지막 집은 이웃이 아니다.  
* 처음 집과 마지막 집은 이웃이 아니다.    
* 각 집을 빨강으로 칠할 때 드는 비용, 초록으로 칠할 때 드는 비용, 파랑으로 드는 비용이 주어질 때, 
모든 집을 칠하는 비용의 최솟값을 구하는 문제

* d[i][j] = i번 집을 색 j로 칠했을 때, 1~i번 집을 칠하는 비용의 최솟값     
	* j = 0 -> 빨강 
	* j = 1 -> 초록
	* j = 2 -> 파랑
* d[i][j] = i번 집을 색 j로 칠했을 때,  1~i번 집을 칠하는 비용의 최소값     
```
즉, 3개로 가정시 
[3][0] 이면 3번째 집이 [0]으로 끝나는 값
[3][1] 이면 3번째 집이 [1]으로 끝나는 값
[3][2] 이면 3번째 집이 [2]으로 끝나는 값

그렇다면 min(d[3-1][1],d[3-1][2])는 무엇일까? 왜 min을 한거지?
그림으로 그려보면 이해가 쉽다.  
d[2][1] 은 2개이고 마지막이 1로 끝나는 값이고 
d[2][2] 은 2개이고 마지막이 2로 끝나는 값이다.   

여기서 우리가 생각을 잘못하는 것이 있는데 d[][] 자체가 이미 최솟값을 의미하는 것으로  
너무 복잡하게 생각하지 말아야한다.  
나는 왜 2개를 합치지 않고 최소값을 구하는거지? 라고 생각했는데 
우리는 최솟값을 구하는것이지 모든 방법의 가격을 구하는 것이 아니다. 
즉, 2개중 1로 끝나는 최솟값이랑 2개중 2로 끝나는 최솟값만 있는 것이고 이를 비교하는 것일 뿐이다.  
그래야 3번째 가격을 더하더라도 가장 최솟값을 구할 수 있다.  
```

**코드**
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int d[10001][3];
int p[10001][3];

int main(void) { 
	
	int n;
	cin >> n;
	cin.ignore();

	for(int i=1;i <=n; i++){
		for(int j=0; j < 3;j++){
			cin >> p[i][j];
	
		}
	}
	for(int i=1; i <=n; i++){
		d[i][0] = min(d[i-1][1],d[i-1][2])+p[i][0];
		d[i][1] = min(d[i-1][0],d[i-1][2])+p[i][1];
		d[i][2] = min(d[i-1][0],d[i-1][1])+p[i][2];
	}
	cout << min(min(d[n][0], d[n][1]), d[n][2]) << "\n";

	return 0;
}
```
       
***    
# 3. 동물원       
* 가로로 두 칸, 세로로 N칸인 동물원이 있다.       
* 가로, 세로로 붙어있게 배치하면 안된다.       
* 가능한 배치의 수         
        
* D[N][0] = N번 줄에 배치하지 않음      
* D[N][1] = N번 줄의 왼쪽에만 배치함         
* D[N][2] = N번 줄의 오른쪽에만 배치함     
      
* D[N][0] = d[N-1][0] + d[N-1][1] + d[N-1][2]     
* D[N][1] = d[N-1][0] + d[N-1][2]         
* D[N][2] = d[N-1][0] + d[N-1][1]       
     
**코드**
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int d[100001][3]; // 2x1을 넣는데 양쪽에 넣으면 안된다.

int main(void) { 
	
	int n;
	cin >> n;
	cin.ignore();

	d[0][0] = 1;
	for(int i=1; i <= n; i++){
		d[i][0] = (d[i-1][0] + d[i-1][1] + d[i-1][2]) % 9901; 
		d[i][1] = (d[i-1][0] + d[i-1][2]) % 9901;
		d[i][2] = (d[i-1][0] + d[i-1][1]) % 9901;
	}

	cout << (d[n][0]+d[n][1]+d[n][2]) % 9901 << "\n";

	return 0;
}
```

***
# 4. 오르막 수     
* 오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다.         
* 인접한 수가 같아도 오름차순으로 친다.            
* 수의 길이가 N이 주어졌을 때, 오르막 수의 개수를 구하는 문제        
* 수는 0으로 시작할 수 있다.       
* 예: 1233345, 357, 888888, 1555999      
   
* d[i][j] = 길이가 i이고 마지막 숫자가 j인 오르막 수의 개수  
* d[1][i] = 1
* d[i][j] += d[i-1][k <= j]    
     
```  
내가 여기서 헷갈린게 오르막수인데  
계단식 처럼 1칸씩 올라가야 한다고 생각을 했다.    
그것이 아니라 현재 칸 보다 이하의 숫자면 되는데 이해를 잘못 했다.  
```    


```c++
#include <iostream>
using namespace std;

long long d[1001][10];
int main(void) { 
	int n;
	cin >> n;
	cin.ignore();

	for(int i=0; i < 10; i++){
		d[1][i] = 1;
	}

	for(int i=1; i <= n; i++){
		for(int j=0; j<10; j++){
			for(int k=0; k <= j; k++){
				d[i][j] += d[i-1][k];
				d[i][j] %= 10007;
			}
		}
	}
	long long result = 0;
	for(int i=0; i < 10; i++){
		result += d[n][i];
		result %= 10007;
	}
	cout << result << "\n";

	return 0;
}
``` 
     
***  
# 5. 스티커  
* 스티커 2n개가 2 x n 모양으로 배치되어 있다.      
* 스티커 한 장을 떼면 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없다.       
* 점수의 합을 최대로 만드는 문제         
  
**점화식**           
* d[i][j] = 2 x i 에서 얻을 수 있는 최대 점수, i번 열에서 뜯는 스티커는 j       
	* d[i] 는 최대 점수 [j]는 0과 1과 2로 이루어진 양자 택일        
* j = 0 뜯지 않음       
	* i-1열에서 스티커를 어떻게 뜯었는지 상관이 없다.   
	* max(d[i][0], d[i-1][1], d[i-1][2])   
* i = 1 위쪽 스티커를 뜯음         
	* i-1열에서 위쪽 스티커는 뜯으면 안된다.       
	* max(d[i][0], d[i-1][2]) + A[i][0]  
* i = 2 아래쪽 스티커를 뜯음         
	* i-1열에서 아래쪽 스티커는 뜯으면 안된다.      
	* max(d[i][0], d[i-1][2]) + A[i][1]  
    
```
A[i][] 가 무엇인지 이해가 안 갈 수 있는데    
A[i][] 는 열에 주어진 스티커의 가격을 의미. 즉, 0과 1로만 이루어진 가격 배열이다.   
```
        
**코드**
```c++
#include <iostream>
using namespace std;

long long d[100001][3];
long long a[100001][2];

int main(void) { 
	int t;
	cin >> t;
	cin.ignore();

	while(t--){
		int n;
		cin >> n;
		cin.ignore();

		for(int i=0; i < 2; i++){
			for(int j=1; j <= n; j++){
				cin >> a[j][i];
			}
		}

		for(int i=1; i <= n; i++){
			d[i][0] = max(d[i-1][0],max(d[i-1][1],d[i-1][2])); 
			d[i][1] = max(d[i-1][0],d[i-1][2]) + a[i][0]; 
			d[i][2] = max(d[i-1][0],d[i-1][1]) + a[i][1]; 
		}
		cout << max(d[n][0],max(d[n][1],d[n][2])) << "\n";
	}
	return 0;
}
```
     
***  
# 6. 포도주 시식
* D[i] = A[i],...,A[i] 까지 포도주를 마셨을 때, 마실수 있는 포도주의 최대 양
* i에게 가능한 경우
	1. i번째 포도주를 마시는 경우
	* d[i-1] + a[i]
	2. i번째 포도주를 마시지 않는 경우  
	* d[i-1]
* d[i] = max(d[i-1] + a[i], d[i-1])
* 하지만 위의 식은 포도주를 연속해서 3잔 마시면 안되는 경우를 처리하지 못한다.
* 내 개인적인 견해로 차원을 한단계 높인다 -> 0, 1, 2   
   
* D[i][j] = A[i],...,A[i] 까지 포도주를 마셨을 때, 마실수 있는 포도주의 최대 양
A[i]는 j번 연속해서 마신 포도주를 의미 
* d[i][0] = 0번 연속해서 마신 포도주 -> A[i]를 마시지 않음
	* max(d[i-1][0],d[i-1][1],d[i-1][2])
* d[i][1] = 1번 연속해서 마신 포도주 -> A[i-1]를 마시지 않음
	* d[i-1][0] + a[i]
* d[i][2] = 2번 연속해서 마신 포도주 -> A[i-1]를 마심 A[i-2]는 마시지 않았음
	* d[i-1][1] + a[i]   	

**위의 식을 토대로 만든 코드** 
```c++
#include <iostream>
using namespace std;

long long d[100001][3];
long long a[100001];
int main(void) { 
	int n;
	cin >> n;
	cin.ignore();
	
	for(int i=1; i<= n; i++){
		cin >> a[i];
	}

	for(int i=1;i <=n; i++){
		d[i][0] = max(d[i-1][0], max(d[i-1][1],d[i-1][2]));
		d[i][1] = d[i-1][0] + a[i];
		d[i][2] = d[i-1][1] + a[i];
	}

	cout <<  max(d[n][0], max(d[n][1],d[n][2])) << "\n";

	return 0;
}
```
그러나 사실 이러한 방식을 이용하지 않고 일차원 배열만으로 만들 수 있다.  
    
* D[i] = A[i],...,A[i] 까지 포도주를 마셨을 때, 마실수 있는 포도주의 최대 양
* d[i] 1번째 = 0번 연속해서 마신 포도주 -> A[i]를 마시지 않음
	* d[i-1]
* d[i] 2번째 = 1번 연속해서 마신 포도주 -> A[i-1]를 마시지 않음   
	* d[i-2] + a[i] (바로 전은 마시지 않았으나 이전 최대값은 사용하므로)   
* d[i] 3번째 = 2번 연속해서 마신 포도주 -> A[i-1]를 마심 A[i-2]는 마시지 않았음
	* d[i] = d[i-3] + a[i-1]+ a[i]; (바로 전에 마셨고 그 이전 맥스값을 얻어야 한다.)    	
* 그러나 -2 , -3 은 반복시 범위를 벗어나므로 예외처리를 진행해주자.  

**위의 식대로 작성한 코드**
```c++
#include <iostream>
using namespace std;

long long d[100001];
long long a[100001];
int main(void) { 
	int n;
	cin >> n;
	cin.ignore();
	
	for(int i=1; i<= n; i++){
		cin >> a[i];
	}

	for(int i=1;i <=n; i++){
		d[i] = max(d[i-1],max(d[i-2] + a[i], d[i-3] + a[i-1]+ a[i]));
	}

	cout <<  d[n] << "\n";

	return 0;
}
```
     
***  
# 7. 정수 삼각형  
* 아래층으로 내려올 때는 대각선 왼쪽 또는 대각선 오른쪽 있는 것만 선택할 수 있다.    
* A에서 선택할 수 있는 수: B,C      
* B에서 선택할 수 있는 수: D,E        
* C에서 선택할 수 있는 수: E,F     
  
___

* 반대로 생각해서 어떤 수가 선택되기 전에 선택된 수는 대각선 왼쪽 위, 오른쪽 위에 있는 것이다.    
* B에 오기전 : A     
* C에 오기전 : A  
* D에 오기전 : B   
* E에 오기전 : B, C   
* F에 오기전 : C     
   
___     
   
* d[i][j] = i행 j열이 선택 되었을때 최대합    
* (i,j)가 선택되기 전에 선택되는 수는 (i-1,j), (i-1,j-1) 중 하나이다.        
* d[i][j] = Max(D[i-1][j],D[i-1][j-1]) + A[i][j]        
   
**점화식을 토대로 작성한 코드**
```c++
#include <iostream>
using namespace std;

int d[501][10000];
int a[501][10000];
int main(void) { 
	int t;
	cin >> t;
	cin.ignore();
	int index = 1;
	int result = 0;

	for(int i=1; i <= t; i++){
		for(int j=1; j<=i; j++){
			cin >> a[i][j];
		}
	}

	for(int i=1; i <= t; i++){
		for(int j=1; j<=i; j++){
			d[i][j] = max(d[i-1][j], d[i-1][j-1]) + a[i][j];
			if(result < d[i][j]) result = d[i][j];
		}
	}

	cout << result << "\n";

	return 0;
}
```
   
***  
# 8. 가장 큰 증가 부분 수열   
* 수열 A가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.     
* 예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에         
* 합이 가장 큰 증가 부분 수열은 A = {**1**, 100, **2**, **50**, **60**, 3, 5, 6, 7, 8} 이고, 합은 113이다.      
```  
여기서 내가 이해를 못햇던게 큰 증가라고 해서 1 -> 100 은 99 증가잖아! 이렇게 이해를 했는데 그것이 아니구    
부분 수열이라 함은 저 배열에서 만들 수 있는 수열을 뜻하는 것으로   
1 다음 100이 나오면 100 이상의 값이 나와야 수열을 진행해야 하는데 그러지 못하므로 종료해야한다.     
하지만 2로 진행할 경우 50, 60 으로 진행이 가능하여 이들을 더한 113이라는 값을 얻어낼 수 있다.     
```  
___  
* 수열 A가 주어졌을때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 문제      
* D[i] = A[i],...,A[i] 까지 수열이 있을 때, A[i]을 마지막으로 하는 가장 큰 증가하는 부분 수열의 길이    
   
**코드**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i=0; i<n; i++) {
        cin >> a[i];
    }
    vector<int> d(n);
    for (int i=0; i<n; i++) {
        d[i] = a[i];
        for (int j=0; j<i; j++) {
            if (a[j] < a[i] && d[j]+a[i] > d[i]) {
                d[i] = d[j]+a[i];
            }
        }
    }
    
    cout << *max_element(d.begin(),d.end()) << '\n';
    return 0;
}
```
코드의 동작 원리가 이해가 안가서 처음부터 다시 코드를 짰다.         
j 는 i를 기준으로 i 보다 **미만**인 수들을 0번 인덱스부터 **i-1까지** 찾아서 반복을 진행한다.    
     
![KakaoTalk_20200501_154236152_02](https://user-images.githubusercontent.com/50267433/80787791-74efa480-8bc2-11ea-951f-c45f494a75a8.jpg)     
      
재미있는점은 d[0] = 1 , d[1] = 101 , d[2] = 3 이런식으로 각각의 위치에서의 최대의 값을 찾는다.                 
아마 내가 이부분에서 헷갈린것 같은데 기존 DP 에서는 ```d[n-1] + ?``` 으로 진행을 했기에                  
d[1] = 101 이 나왔어도 이는 d[2]와 관련이 없는데 관련이 있을것이라 개념이 박혀서 문제였던 것 같다.           
**때론 이렇게 단순하게 생각하는 방법도 사용할줄 알아야할 것 같다.**        
     
***   
# 9. 가장 긴 감소하는 부분 수열        
* 수열 A가 주어졌을 때, 그 수열의 감소하는 부분 수열 중에서 가장 긴 것을 구하는 문제        
   
**두 가지 방법이 있다.**           
1. 입력으로 주어진 수열 A를 뒤집어서 가장 긴 증가하는 부분 수열을 구하는 방법        
	* 가장 긴 증가하는 부분 수열과 비슷하게 구하는 방법 (뒤에서부터 구해야 한다)       
2. D[i] = A[i] 에서 시작하는 가장 긴 감소하는 부분 수열의 길이   
	* A[i]가 첫번째 수이고 그 뒤에 수는? 우리는 모른다. 그렇기에 임의의 j번째라 칭한다.  
	* j를 모르지만 '감소'이므로 인덱스 크기는 i < j 이지만 값은 a[i] > a[j] 형태를 띈다.  
	* 그러면 d[i] = max(d[j]+1) 및 d[j] 는 위 두 조건을 만족시켜야 한다.  
  
단 2번과 같이 진행할 경우 i가 시작이므로 뒤에서부터 진행을 해야 한다.      
즉, N 구하기 -> N-1 구하기 -> N-2 구하기... 이런식으로 진행을 해야한다.     

**코드**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int d[1001];
int a[1001];
int main() {
	int n;
	cin >> n;
	cin.ignore();

	for(int i=1; i <= n; i++){
		cin >> a[i];
	}

	for(int i=n; i > 0; i--){
		d[i] = 1;
		for(int j=i+1 ; j <= n; j++){
			if(a[i] > a[j] && d[i] < d[j]+1 ){
				d[i] = d[j]+1;
			}
		}
	}
	int result = d[1];
	for(int i=2; i<=n; i++){
		if(result < d[i]){
			result = d[i];
		}
	}
	cout << result << "\n";

    return 0;
}
```
  
***   
# 10. 가장 긴 바이토닉 부분 수열     
* 수열 A가 주어졌을 때, 그 수열의 바이토닉 부분 수열 중에서 가장 긴 것을 구하는 문제      
* 증가와 감소가 결합되어 있다. -> 어떤 특정 기준을 만나면 증가하거나 감소하거나로 바뀐다.    

* 방법은 간단하다 가장 긴 증가 수열과 가장 긴 감소 수열을 더해주고 -1 해주면 된다.
* -1 감소를 해야하는 이유는 가장 큰 값과 가장 작은 값의 기준이 중복이 되기 때문이다.  
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i=0; i<n; i++) {
        cin >> a[i];
    }
    vector<int> d(n);
    vector<int> d2(n);
    for (int i=0; i<n; i++) {
        d[i] = 1;
        for (int j=0; j<i; j++) {
            if (a[j] < a[i] && d[j]+1 > d[i]) {
                d[i] = d[j]+1;
            }
        }
    }
    for (int i=n-1; i>=0; i--) {
        d2[i] = 1;
        for (int j=i+1; j<n; j++) {
            if (a[i] > a[j] && d2[j]+1 > d2[i]) {
                d2[i] = d2[j]+1;
            }
        }
    }
    int ans = 0;
    for (int i=0; i<n; i++) {
        if (ans < d[i]+d2[i]-1) {
            ans = d[i]+d2[i]-1;
        }
    }

    cout << ans << '\n';
    return 0;
}
```
   
***   
# 11. 연속합2   
들어가기에 앞서 이건 진짜 머리를 유연하게 사용했다고 느꼈다......      
위 코드를 해석하는 것도 좋지만 어떻게 이러한 결과를 도출했는지에 대한 과정을 이끌어내보자         
    
* 수열의 연속합 중 가장 큰 합을 구하는 문제      
* 수는 하나 제거할 수 있다. 제거하지 않아도 된다.    
___   
    
* 어떤 수 A[i]를 제거했을 때, 매번 전체를 다 구하는 것은 비효율적이다.    
* DL[i] = i번째 수에서 끝나는 최대 연속합   
* DR[i] = i번째 수에서 시작하는 최대 연속합  
* 이 값을 이용해서 A[i]를 제거했을 때 최대 연속합을 구할 수 있다.     
* i번째 수를 제거하면 i-1 번째 수와 i+1번째 수가 연속하게 된다.    
* 따라서, DL[i-1] + DR[i+1]이 i번째 수를 제거했을 때, i번째 수가 포함되는 최대 연속합이 된다.     
   
**일반 d의 결과**     
```c++
10
6
9
10
15
21
-14
12
33
32
```
**리버스된 d의 결과**    
```c++
21
11
15
12
11
6
-2
33
21
-1
```


```c++
#include <iostream>

int d[100001];
int dr[100001];
int a[100001];
using namespace std;

int main() {
    int n;
    cin >> n;
	cin.ignore();

	for(int i=0; i< n; i++){
		cin >> a[i];
	}

	for(int i=0; i< n; i++){
		d[i] = a[i];
		if(i==0) continue;
		if(d[i] <  d[i-1]+a[i]){
			d[i] = d[i-1] + a[i];
		}
	}

	for (int i=n-1; i>=0; i--) {
        dr[i] = a[i];
        if (i == n-1) continue;
        if (dr[i] < dr[i+1] + a[i]) {
            dr[i] = dr[i+1] + a[i];
        }
    }
	
	int ans = d[0];
    for (int i=1; i<n; i++) {
        if (ans < d[i]) {
            ans = d[i];
        }
    } // ans = 33;

	for (int i=1; i<n-1; i++) {
        if (ans < d[i-1] + dr[i+1]) {
            ans = d[i-1] + dr[i+1];
        }
    } //  {21} -35 {33} -> 54

	cout << ans << "\n";

    return 0;
}
```
   
***   
# 12. 타일 채우기  
* 3 x n 크기의 벽을 2x1, 1x2 크기의 타일로 채우는 경우의 수를 구해보자
* d[i] = 3 x 1을 채우는 방법의 수   
* 마지막에 올 수 있는 가능한 경우의 수 
___
* 3 x n을 1 x 2, 2 x 1 로 채우는 방법의 수 
* d[i] = 3 x 1를 채우는 방법의 수        
	* d[i] = 3 * d[i-2] (아니다)       
	* 왜냐하면 더 가능한 경우의 수가 있기 때문이다.
* 4칸일 경우 2개가 더 생길 수 있으며    
* 6칸일 경우도 2개가 더 생길 수 있다. 그리고 이는 2개 증가마다 반복된다.  
즉, d[i] = 3 * d[i-2] + 2 * d[i-4] + 2 * d[i-6].... 

**코드**
```c++
#include <iostream>
using namespace std;
long long d[31];
int main(){
    int n;
    cin >> n;
    d[0] = 1;
    for (int i=2; i<=n; i+=2) {
        d[i] = d[i-2]*3;
        for (int j=i-4; j>=0; j-=2) {
            d[i] += d[j]*2;
        }
    }
    cout << d[n] << '\n';
    return 0;
}
```
여기서 재미있는 점은 홀수가 나오면 0으로 처리된다.       
이는 홀수일 경우 타일을 전부 다 채워야 한다는 조건에 부합하지 않기 때문이다.     
눈 여겨 볼 부분이 있는데   
```c++
        for (int j=i-4; j>=0; j-=2) {
            d[i] += d[j]*2;
        }
```
d[i] 에 추가적으로 값을 넣어주는 역할을 한다. 
d[j] * 2 는 
