합분해까지
=======================  
# 1. 1,2,3 더하기 3  
* 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제  
* n = 4
* 1+1+1+1
* 1+1+2
* 1+2+1
* 2+1+1
* 2+2
* 1+3
* 3+1
   
이전에 했던 방법에 최적의 연산을 사용해야하고 숫자만 바꿔준것    
    
**코드**
```c++

#include <iostream>
using namespace std;

long long d[1000000];
int main() {

	int t;
	cin >> t;
	cin.ignore();

	while(t--){
		ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);

		int n ;
		cin >> n;
		cin.ignore();

		d[0] = 1;
		d[1] = 1;
		d[2] = 2;
		d[3] = 4;

		for (int i=4; i<=n; i++) {
			d[i] = 0;
		}
		for (int i=4; i <= n; i++) {
				d[i] += (d[i-1]+d[i-2]+d[i-3]) % 1000000009; 
		}
		cout << d[n] << "\n";
	}
}
```
    
    
    
***    
# 2. RGB거리           
* RGB 거리에 사는 사람들은 집을 빨강, 초록, 파랑중에 하나로 칠하려고한다.  
* 또한, 그들의 모든 이웃은 같은 색으로 칠할 수 없다는 규칙도 정했다.   
* 집 i의 이웃은 집 i-1과 집 i+1이고, 첫 집과 마지막 집은 이웃이 아니다.  
* 처음 집과 마지막 집은 이웃이 아니다.    
* 각 집을 빨강으로 칠할 때 드는 비용, 초록으로 칠할 때 드는 비용, 파랑으로 드는 비용이 주어질 때, 
모든 집을 칠하는 비용의 최솟값을 구하는 문제

* d[i][j] = i번 집을 색 j로 칠했을 때, 1~i번 집을 칠하는 비용의 최솟값     
	* j = 0 -> 빨강 
	* j = 1 -> 초록
	* j = 2 -> 파랑
* d[i][j] = i번 집을 색 j로 칠했을 때,  1~i번 집을 칠하는 비용의 최소값     
```
즉, 3개로 가정시 
[3][0] 이면 3번째 집이 [0]으로 끝나는 값
[3][1] 이면 3번째 집이 [1]으로 끝나는 값
[3][2] 이면 3번째 집이 [2]으로 끝나는 값

그렇다면 min(d[3-1][1],d[3-1][2])는 무엇일까? 왜 min을 한거지?
그림으로 그려보면 이해가 쉽다.  
d[2][1] 은 2개이고 마지막이 1로 끝나는 값이고 
d[2][2] 은 2개이고 마지막이 2로 끝나는 값이다.   

여기서 우리가 생각을 잘못하는 것이 있는데 d[][] 자체가 이미 최솟값을 의미하는 것으로  
너무 복잡하게 생각하지 말아야한다.  
나는 왜 2개를 합치지 않고 최소값을 구하는거지? 라고 생각했는데 
우리는 최솟값을 구하는것이지 모든 방법의 가격을 구하는 것이 아니다. 
즉, 2개중 1로 끝나는 최솟값이랑 2개중 2로 끝나는 최솟값만 있는 것이고 이를 비교하는 것일 뿐이다.  
그래야 3번째 가격을 더하더라도 가장 최솟값을 구할 수 있다.  
```

**코드**
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int d[10001][3];
int p[10001][3];

int main(void) { 
	
	int n;
	cin >> n;
	cin.ignore();

	for(int i=1;i <=n; i++){
		for(int j=0; j < 3;j++){
			cin >> p[i][j];
	
		}
	}
	for(int i=1; i <=n; i++){
		d[i][0] = min(d[i-1][1],d[i-1][2])+p[i][0];
		d[i][1] = min(d[i-1][0],d[i-1][2])+p[i][1];
		d[i][2] = min(d[i-1][0],d[i-1][1])+p[i][2];
	}
	cout << min(min(d[n][0], d[n][1]), d[n][2]) << "\n";

	return 0;
}
```
       
***    
# 3. 동물원       
* 가로로 두 칸, 세로로 N칸인 동물원이 있다.       
* 가로, 세로로 붙어있게 배치하면 안된다.       
* 가능한 배치의 수         
        
* D[N][0] = N번 줄에 배치하지 않음      
* D[N][1] = N번 줄의 왼쪽에만 배치함         
* D[N][2] = N번 줄의 오른쪽에만 배치함     
      
* D[N][0] = d[N-1][0] + d[N-1][1] + d[N-1][2]     
* D[N][1] = d[N-1][0] + d[N-1][2]         
* D[N][2] = d[N-1][0] + d[N-1][1]       
     
**코드**
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int d[100001][3]; // 2x1을 넣는데 양쪽에 넣으면 안된다.

int main(void) { 
	
	int n;
	cin >> n;
	cin.ignore();

	d[0][0] = 1;
	for(int i=1; i <= n; i++){
		d[i][0] = (d[i-1][0] + d[i-1][1] + d[i-1][2]) % 9901; 
		d[i][1] = (d[i-1][0] + d[i-1][2]) % 9901;
		d[i][2] = (d[i-1][0] + d[i-1][1]) % 9901;
	}

	cout << (d[n][0]+d[n][1]+d[n][2]) % 9901 << "\n";

	return 0;
}
```

***
# 4. 오르막 수     
* 오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다.         
* 인접한 수가 같아도 오름차순으로 친다.            
* 수의 길이가 N이 주어졌을 때, 오르막 수의 개수를 구하는 문제        
* 수는 0으로 시작할 수 있다.       
* 예: 1233345, 357, 888888, 1555999      
   
* d[i][j] = 길이가 i이고 마지막 숫자가 j인 오르막 수의 개수  
* d[1][i] = 1
* d[i][j] += d[i-1][k <= j]    
     
```  
내가 여기서 헷갈린게 오르막수인데  
계단식 처럼 1칸씩 올라가야 한다고 생각을 했다.    
그것이 아니라 현재 칸 보다 이하의 숫자면 되는데 이해를 잘못 했다.  
```    


```c++
#include <iostream>
using namespace std;

long long d[1001][10];
int main(void) { 
	int n;
	cin >> n;
	cin.ignore();

	for(int i=0; i < 10; i++){
		d[1][i] = 1;
	}

	for(int i=1; i <= n; i++){
		for(int j=0; j<10; j++){
			for(int k=0; k <= j; k++){
				d[i][j] += d[i-1][k];
				d[i][j] %= 10007;
			}
		}
	}
	long long result = 0;
	for(int i=0; i < 10; i++){
		result += d[n][i];
		result %= 10007;
	}
	cout << result << "\n";

	return 0;
}
``` 
     
***  
# 5. 스티커  
* 스티커 2n개가 2 x n 모양으로 배치되어 있다.      
* 스티커 한 장을 떼면 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없다.       
* 점수의 합을 최대로 만드는 문제         
  
**점화식**           
* d[i][j] = 2 x i 에서 얻을 수 있는 최대 점수, i번 열에서 뜯는 스티커는 j       
	* d[i] 는 최대 점수 [j]는 0과 1과 2로 이루어진 양자 택일        
* j = 0 뜯지 않음       
	* i-1열에서 스티커를 어떻게 뜯었는지 상관이 없다.   
	* max(d[i][0], d[i-1][1], d[i-1][2])   
* i = 1 위쪽 스티커를 뜯음         
	* i-1열에서 위쪽 스티커는 뜯으면 안된다.       
	* max(d[i][0], d[i-1][2]) + A[i][0]  
* i = 2 아래쪽 스티커를 뜯음         
	* i-1열에서 아래쪽 스티커는 뜯으면 안된다.      
	* max(d[i][0], d[i-1][2]) + A[i][1]  
    
```
A[i][] 가 무엇인지 이해가 안 갈 수 있는데    
A[i][] 는 열에 주어진 스티커의 가격을 의미. 즉, 0과 1로만 이루어진 가격 배열이다.   
```
        
**코드**
```c++
#include <iostream>
using namespace std;

long long d[100001][3];
long long a[100001][2];

int main(void) { 
	int t;
	cin >> t;
	cin.ignore();

	while(t--){
		int n;
		cin >> n;
		cin.ignore();

		for(int i=0; i < 2; i++){
			for(int j=1; j <= n; j++){
				cin >> a[j][i];
			}
		}

		for(int i=1; i <= n; i++){
			d[i][0] = max(d[i-1][0],max(d[i-1][1],d[i-1][2])); 
			d[i][1] = max(d[i-1][0],d[i-1][2]) + a[i][0]; 
			d[i][2] = max(d[i-1][0],d[i-1][1]) + a[i][1]; 
		}
		cout << max(d[n][0],max(d[n][1],d[n][2])) << "\n";
	}
	return 0;
}
```
     
***  
# 6. 포도주 시식
* D[i] = A[i],...,A[i] 까지 포도주를 마셨을 때, 마실수 있는 포도주의 최대 양
* i에게 가능한 경우
	1. i번째 포도주를 마시는 경우
	* d[i-1] + a[i]
	2. i번째 포도주를 마시지 않는 경우  
	* d[i-1]
* d[i] = max(d[i-1] + a[i], d[i-1])
* 하지만 위의 식은 포도주를 연속해서 3잔 마시면 안되는 경우를 처리하지 못한다.
* 내 개인적인 견해로 차원을 한단계 높인다 -> 0, 1, 2   
   
* D[i][j] = A[i],...,A[i] 까지 포도주를 마셨을 때, 마실수 있는 포도주의 최대 양
A[i]는 j번 연속해서 마신 포도주를 의미 
* d[i][0] = 0번 연속해서 마신 포도주 -> A[i]를 마시지 않음
	* max(d[i-1][0],d[i-1][1],d[i-1][2])
* d[i][1] = 1번 연속해서 마신 포도주 -> A[i-1]를 마시지 않음
	* d[i-1][0] + a[i]
* d[i][2] = 2번 연속해서 마신 포도주 -> A[i-1]를 마심 A[i-2]는 마시지 않았음
	* d[i-1][1] + a[i]   	

**위의 식을 토대로 만든 코드** 
```c++
#include <iostream>
using namespace std;

long long d[100001][3];
long long a[100001];
int main(void) { 
	int n;
	cin >> n;
	cin.ignore();
	
	for(int i=1; i<= n; i++){
		cin >> a[i];
	}

	for(int i=1;i <=n; i++){
		d[i][0] = max(d[i-1][0], max(d[i-1][1],d[i-1][2]));
		d[i][1] = d[i-1][0] + a[i];
		d[i][2] = d[i-1][1] + a[i];
	}

	cout <<  max(d[n][0], max(d[n][1],d[n][2])) << "\n";

	return 0;
}
```
그러나 사실 이러한 방식을 이용하지 않고 일차원 배열만으로 만들 수 있다.  
    
* D[i] = A[i],...,A[i] 까지 포도주를 마셨을 때, 마실수 있는 포도주의 최대 양
* d[i] 1번째 = 0번 연속해서 마신 포도주 -> A[i]를 마시지 않음
	* d[i-1]
* d[i] 2번째 = 1번 연속해서 마신 포도주 -> A[i-1]를 마시지 않음   
	* d[i-2] + a[i] (바로 전은 마시지 않았으나 이전 최대값은 사용하므로)   
* d[i] 3번째 = 2번 연속해서 마신 포도주 -> A[i-1]를 마심 A[i-2]는 마시지 않았음
	* d[i] = d[i-3] + a[i-1]+ a[i]; (바로 전에 마셨고 그 이전 맥스값을 얻어야 한다.)    	
* 그러나 -2 , -3 은 반복시 범위를 벗어나므로 예외처리를 진행해주자.  

**위의 식대로 작성한 코드**
```c++
#include <iostream>
using namespace std;

long long d[100001];
long long a[100001];
int main(void) { 
	int n;
	cin >> n;
	cin.ignore();
	
	for(int i=1; i<= n; i++){
		cin >> a[i];
	}

	for(int i=1;i <=n; i++){
		d[i] = max(d[i-1],max(d[i-2] + a[i], d[i-3] + a[i-1]+ a[i]));
	}

	cout <<  d[n] << "\n";

	return 0;
}
```
     
***  
# 7. 정수 삼각형  
* 아래층으로 내려올 때는 대각선 왼쪽 또는 대각선 오른쪽 있는 것만 선택할 수 있다.    
* A에서 선택할 수 있는 수: B,C      
* B에서 선택할 수 있는 수: D,E        
* C에서 선택할 수 있는 수: E,F   
   
* 반대로 생각해서 어떤 수가 선택되기 전에 선택된 수는 대각선 왼쪽 위, 오른쪽 위에 있는 것이다.    
* B에 오기전 : A     
* C에 오기전 : A  
* D에 오기전 : B   
* E에 오기전 : B, C   
* F에 오기전 : C    
  
* d[i][j] = i행 j열이 선택 되었을때 최대합    
* (i,j)가 선택되기 전에 선택되는 수는 (i-1,j), (i-1,j-1) 중 하나이다.        
* d[i][j] = Max(D[i-1][j],D[i-1][j-1]) + A[i][j]        
   
**점화식을 토대로 작성한 코드**
```c++
#include <iostream>
using namespace std;

int d[501][10000];
int a[501][10000];
int main(void) { 
	int t;
	cin >> t;
	cin.ignore();
	int index = 1;
	int result = 0;

	for(int i=1; i <= t; i++){
		for(int j=1; j<=i; j++){
			cin >> a[i][j];
		}
	}

	for(int i=1; i <= t; i++){
		for(int j=1; j<=i; j++){
			d[i][j] = max(d[i-1][j], d[i-1][j-1]) + a[i][j];
			if(result < d[i][j]) result = d[i][j];
		}
	}

	cout << result << "\n";

	return 0;
}
```
