자료구조 연습하기
=======================
# 1. 단어 뒤집기 2

* 알파벳, 소문자, 숫자, 공백, 특수 문자(<,>)로 이루어진 문자열 S에서 단어를 뒤집는 문제     
* 태그 ```<``` 로 시작해서 ```>```로 끝나는 문자열, 사이에는 알파벳 소문자와 공백만 있다.    
* 단어, 알파벡 소문자와 숫자로만 이루어짐   
* 단어와 단어 사이에는 공백 한 칸, 단어와 태그 사이에는 공백이 없다.    
* ```<open>tag<close>``` -> ```<open>gat<close>```   
* ```<abcd>efgh<ijkl>``` -> ```<abcd>hgfe<ijkl>```  
     
```c++
#include <iostream> 
#include <string> 
#include <stack> 
using namespace std; 


void print(stack<char> &s){
	while(!s.empty()){
		cout << s.top();
		s.pop();
	}
}

int main(void) { 
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
	string str;
	getline(cin, str);
	bool tag = false;
	stack<char> s;
	for( char ch : str){
		if(ch == '<'){
			print(s); // 이전에 저장된 내용들 출력하라는 뜻이구나!
			tag = true;
			cout << ch; // < 출력 
		} else if( ch == '>'){
			tag = false;
			cout << ch;// > 출력
		} else if (tag){
			cout << ch;
		} else {
			if( ch ==' '){
				print(s);
				cout << ch; // 공백 출력
			} else {
				s.push(ch);
			}
		}
	}
    print(s);
    cout << '\n';
    return 0; 
}
```
    
***
# 2. 쇠막대기
* 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ```'()'```으로 표현된다.     
* 또한, 모든 ```'()'```는 반드시 레이저를 표현한다.      
* 쇠막대기의 왼쪽 끝은 여는 괄호 ```(```로, 오른쪽 끝은 닫힌 괄호 ```)```로 표현된다.   

* 올바른 괄호 문자열과 비슷하게 풀 수 있다.  
* ```()```가 나올 때 마다 스택에 들어있는 ```(``` 의 개수를 세어준다
* 그런데 , ```)```가 나왔을 때, 이것이 레이저인지 쇠막대인지 구문을 해줘야 한다.  
* 레이저는 항상 ```()```와 같이 붙어진 상태로 나온다 
* 스택에 ```(```의 인덱스를 넣어서 인덱스가 1차이 나는지 확인해야 한다.  

여기서 우리가 생각해볼 수 있는 점은 
```
레이저는 항상 ```()```와 같이 붙어진 상태로 나온다
```
이를 다르게 생각해보면 레이저는 괄호가 서로 붙어있다는 뜻이고 이는 인덱스가 1개밖에 차이가 안난다는 뜻이다.   

기준 : ```( ( ( ( ) ( ) ) ( ( ) ) ( ) ) ) ```
1,2,3,4 진행         
**5번 닫는 괄호가 나왔을 때**      
* 스택 : ```[1,2,3,4]```     
* 스택의 top 과 인덱스 차이가 1나기 때문에 레이져  
* 스택 : ```[1,2,3]```
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : 3     
   
6진행      
**7번 닫는 괄호가 나왔을 때**  
* 스택 : ```[1,2,3,6]```       
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저    
* 스택 : ```[1,2,3]```     
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.    
* 정답 : ```3 + 3 = 6```  
  
**8번 닫는 괄호가 나왔을 때**    
* 스택 : ```[1,2,3]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1,2]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 = 7```   
   
9,10 진행    
**11번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2,9,10]```     
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저  
* 스택 : ```[1,2,9]```   
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : ```3 + 3 + 1 + 3 = 10```   
   
**12번 닫는 괄호가 나왔을 때**    
* 스택 : ```[1,2,9]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1,2]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 1= 11```    
    
13번 진행
**14번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2,13]```     
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저  
* 스택 : ```[1,2]```   
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : ```3 + 3 + 1 + 3 + 2 = 12``` 

**15번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 2 + 1 = 13```   

**16번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[x]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 2 + 1 + 1 = 14```    

```c++

```
   
***
# 3. 오큰수 (오른쪽에 있으면서 가장 가까운 큰수)   
* 크기가 N인 수열 A=A_1,A_2...A_N이 있고, 각 원소 A_i의 오큰수 NGE(i)를 구하려고 한다.  
* A_i의 오큰수는 오른쪽에 있으면서 A_i보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다.   
그러한 수가 없는 경우에 오큰수는 -1 이다.     
* ```A = [3,5,2,7]``` -> ```NGE = [5,7,7,-1]```   
* ```A = [9,5,4,8]``` -> ```NGE = [-1,8,8,-1]```   

여기에서 한가지 생각할 점이 있는데 아래 주석을 보자  
```
[5,.....2,7] 이 존재한다고 가정시 오큰수가 [7......,-1] 인 경우는 
다시 생각해보면 5와 7 사이에는 5보다 큰수가 없다는 뜻을 의미한다.  
그리고 마지막 숫자는 오른쪽에 더는 숫자가 존재하지 않으므로 -1 값을 가질 수 밖에 없다.  
```
    
다시 시나리오대로 분석해보자     
```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|       |       |       |       |    
_____|_______|_______|_______|_______|
```
1. A[1] = 3 인 경우 아직 오큰수를 찾을 수 없다. 스택에 위치 1을 넣는다.
2. A[2] = 5, 스택 = [1]   
	* 스택의 가장 위의 있는 수 A[1] = 3이고, 현재 수는 A[2] = 5 이다.   
	* A[1] < A[2] 이기 대문에 , NGE(1) = 5 인 것을 알 수 있다.	
	* 스택 = []
	* 더 이상 스택에 수가 없기 때문에, 위치 2를 스택에 넣는다. 
	* 스택 = [2]


