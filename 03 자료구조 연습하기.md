자료구조 연습하기
=======================
# 1. 단어 뒤집기 2

* 알파벳, 소문자, 숫자, 공백, 특수 문자(<,>)로 이루어진 문자열 S에서 단어를 뒤집는 문제     
* 태그 ```<``` 로 시작해서 ```>```로 끝나는 문자열, 사이에는 알파벳 소문자와 공백만 있다.    
* 단어, 알파벡 소문자와 숫자로만 이루어짐   
* 단어와 단어 사이에는 공백 한 칸, 단어와 태그 사이에는 공백이 없다.    
* ```<open>tag<close>``` -> ```<open>gat<close>```   
* ```<abcd>efgh<ijkl>``` -> ```<abcd>hgfe<ijkl>```  
     
```c++
#include <iostream> 
#include <string> 
#include <stack> 
using namespace std; 


void print(stack<char> &s){
	while(!s.empty()){
		cout << s.top();
		s.pop();
	}
}

int main(void) { 
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
	string str;
	getline(cin, str);
	bool tag = false;
	stack<char> s;
	for( char ch : str){
		if(ch == '<'){
			print(s); // 이전에 저장된 내용들 출력하라는 뜻이구나!
			tag = true;
			cout << ch; // < 출력 
		} else if( ch == '>'){
			tag = false;
			cout << ch;// > 출력
		} else if (tag){
			cout << ch;
		} else {
			if( ch ==' '){
				print(s);
				cout << ch; // 공백 출력
			} else {
				s.push(ch);
			}
		}
	}
    print(s);
    cout << '\n';
    return 0; 
}
```
    
***
# 2. 쇠막대기
* 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ```'()'```으로 표현된다.     
* 또한, 모든 ```'()'```는 반드시 레이저를 표현한다.      
* 쇠막대기의 왼쪽 끝은 여는 괄호 ```(```로, 오른쪽 끝은 닫힌 괄호 ```)```로 표현된다.   

* 올바른 괄호 문자열과 비슷하게 풀 수 있다.  
* ```()```가 나올 때 마다 스택에 들어있는 ```(``` 의 개수를 세어준다
* 그런데 , ```)```가 나왔을 때, 이것이 레이저인지 쇠막대인지 구문을 해줘야 한다.  
* 레이저는 항상 ```()```와 같이 붙어진 상태로 나온다 
* 스택에 ```(```의 인덱스를 넣어서 인덱스가 1차이 나는지 확인해야 한다.  

여기서 우리가 생각해볼 수 있는 점은 
```
레이저는 항상 ```()```와 같이 붙어진 상태로 나온다
```
이를 다르게 생각해보면 레이저는 괄호가 서로 붙어있다는 뜻이고 이는 인덱스가 1개밖에 차이가 안난다는 뜻이다.   

기준 : ```( ( ( ( ) ( ) ) ( ( ) ) ( ) ) ) ```
1,2,3,4 진행         
**5번 닫는 괄호가 나왔을 때**      
* 스택 : ```[1,2,3,4]```     
* 스택의 top 과 인덱스 차이가 1나기 때문에 레이져  
* 스택 : ```[1,2,3]```
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : 3     
   
6진행      
**7번 닫는 괄호가 나왔을 때**  
* 스택 : ```[1,2,3,6]```       
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저    
* 스택 : ```[1,2,3]```     
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.    
* 정답 : ```3 + 3 = 6```  
  
**8번 닫는 괄호가 나왔을 때**    
* 스택 : ```[1,2,3]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1,2]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 = 7```   
   
9,10 진행    
**11번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2,9,10]```     
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저  
* 스택 : ```[1,2,9]```   
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : ```3 + 3 + 1 + 3 = 10```   
   
**12번 닫는 괄호가 나왔을 때**    
* 스택 : ```[1,2,9]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1,2]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 1= 11```    
    
13번 진행
**14번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2,13]```     
* 스택의 top과 인덱스 차이가 1나기 때문에 레이저  
* 스택 : ```[1,2]```   
* 스택의 크기는 레이저가 자르는 쇠막대기의 개수와 같다.  
* 정답 : ```3 + 3 + 1 + 3 + 2 = 12``` 

**15번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1,2]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[1]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 2 + 1 = 13```   

**16번 닫는 괄호가 나왔을 때**     
* 스택 : ```[1]```        
* 하지만 스택의 top과 인덱스 차이가 1나지 않기 때문에 쇠막대기의 끝이라 판단     
* 스택 : ```[x]```     
* 쇠막대기 1개를 레이저가 2번 자르면, 쇠막대기는 3개의 조각으로 나뉘어 진다.    
* 레이저가 자르는 횟수를 정답에 더했기 때문에(2개), 쇠막대기의 끝에서 정답을 1더해야 한다. (마지막 조각의미)   
* 즉 위의말은 1개를 2개 레이저로 나눈것이 3이니까 ```2(레이저)+1(남은 조각)```이다 표현하는 것       
* 정답 : ```3 + 3 + 1 + 3 + 2 + 1 + 1 = 14```    

```c++
#include <string>
#include <stack> 
#include <iostream>

using namespace std; 
int main(void) { 
    
    stack<int> s;
    string str;
    cin >> str; 
    
    int len = str.size();
    int sum = 0;
    for(int i = 0; i < len; i++){
		if(str[i] == '('){
			s.push(i);
		} else {
			if(s.top()+1 == i){
				s.pop();
				sum += s.size();
			} else {
				s.pop();
				sum += 1;
			}
		}
	}
    
    cout << sum << '\n';
    return 0; 
}
```
   
***
# 3. 오큰수 (오른쪽에 있으면서 가장 가까운 큰수)   
* 크기가 N인 수열 A=A_1,A_2...A_N이 있고, 각 원소 A_i의 오큰수 NGE(i)를 구하려고 한다.  
* A_i의 오큰수는 오른쪽에 있으면서 A_i보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다.   
그러한 수가 없는 경우에 오큰수는 -1 이다.     
* ```A = [3,5,2,7]``` -> ```NGE = [5,7,7,-1]```   
* ```A = [9,5,4,8]``` -> ```NGE = [-1,8,8,-1]```   

여기에서 한가지 생각할 점이 있는데 아래 주석을 보자  
```
[5,.....2,7] 이 존재한다고 가정시 오큰수가 [7......,-1] 인 경우는 
다시 생각해보면 5와 7 사이에는 5보다 큰수가 없다는 뜻을 의미한다.  
그리고 마지막 숫자는 오른쪽에 더는 숫자가 존재하지 않으므로 -1 값을 가질 수 밖에 없다.  
```
    
다시 시나리오대로 분석해보자     
```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|       |       |       |       |    
_____|_______|_______|_______|_______|
```
1. A[1] = 3 인 경우 아직 오큰수를 찾을 수 없다. 스택에 위치 1을 넣는다.
```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|   5   |       |       |       |    
_____|_______|_______|_______|_______|
```
2. A[2] = 5, 스택 = [1]   
	* 스택의 가장 위의 있는 수 A[1] = 3이고, 현재 수는 A[2] = 5 이다.   
	* A[1] < A[2] 이기 대문에 , NGE(1) = 5 인 것을 알 수 있다.	
	* 스택 = []
	* 더 이상 스택에 수가 없기 때문에, 위치2를 스택에 넣는다. 
	* 스택 = [2]   

```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|   5   |       |       |       |    
_____|_______|_______|_______|_______|
```

3. A[3] = 2, 스택 = [2]   
	* 스택의 가장 위에 있는 수 A[2] = 5이고, 현재 수는 A[3] = 2 이다.  
	* A[2] > A[3]이기 때문에, 현재 스택에 있는 수의 오큰수는 A[3]이 아니다. 
	* 스택에 들어있는 수의 오큰수는 3보다 큰 위치에 있기 때문에, 그냥 넘어간다.  
	* 위치 3을 스택에 넣는다. 
	* 스택 = [2,3]   
```
______________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|   5   |       |   7   |       |    
_____|_______|_______|_______|_______|
```	
4. A[4] = 7, 스택 = [2,3]   
	* 스택의 가장 위에 있는 수 A[3] = 2이고, 현재 수는 A[4] = 7 이다.  
	* A[3] < A[4]이기 때문에, NGE(3) = 7 인 것을 알 수 있다.   
	* 스택 = [2]
```
_____________________________________
__i__|___1___|___2___|___3___|___4___|
     |       |       |       |       |	
a[]  |   3   |   5   |   2   |   7   |    
_____|_______|_______|_______|_______|
     |       |       |       |       |	
NGE[]|   5   |   7   |   7   |  -1   |    
_____|_______|_______|_______|_______|
```
5. 스택에 [2] 만 남았는데 비교시 A[2] < A[4] 이기 때문에, NGE(2) = 7이다.  	
6. 마지막 NGE는 진척이 불가능 하므로 -1의 값을 넣어준다.  

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <queue>
#include <stack>

using namespace std;


int main(int argc, char* argv[]) {
	int n;
	cin >> n;
	vector<int> a(n);
	vector<int> ans(n);

	for(int i=0; i < n; i++){
		cin >> a[i];
	}
	// a는 어떤 친구지? 왜 사용하는 거지?
	// a는 인덱스 값을 저장한 배열이다.  

	// ans는 왜 사용하지? 이 문제점을 가지고 들어가보자 
	// ans는 오큰수를 저장한 배열이다.  

	stack<int> s; // 스택을 사용해야 편하다? -> 스택은 최근 값이 반환한다.
	// 우선 스택은 배열의 인덱스를 저장하는 것이다.
	// 단순 값을 저장하는게 아니라 인덱스 값을 저장한다.  
	// 스택은 검사 기준이 되는 배열의 인덱스 값을 저장한다.  

	s.push(0); // -> 우선 왼쪽이 비더라도 0으로 채우는것 같다.   
	// 0번 인덱스를 넣는것인가?  
	
	for(int i=1;i<n;i++){
		if(s.empty()){ // 스택이 비면 
			s.push(i); // i를 넣어라 -> 인덱스 값을 넣어라 // 여기부터 검사 시작하겠다.     
		}
		// 0부터 시작하고 1~n까지 돈다.
		// a[0] >= a[1] a[2]
		// a[0] < a[3] 형태가 되면
		// a[0]에 대한 오큰수는 a[3] 이므로 ans[0] 에 a[3] 을 넣는다.
		// 그리고 0은 이제 찾았으니 pop()을 진행해준다.  
		// 그리고 a[1], a[2] 는 a[0]과 a[3]보다 작다는 뜻이므로 무시하고
		// s.push(3)을 넣어서    
		while(!s.empty() && a[s.top()] < a[i]){ // 스택이 비지 않고 a[최근값] < a[i]이면 
			ans[s.top()] = a[i]; // ans[최근값] = a[i]
			s.pop(); // 찾은 것은 빼기  
		}
		s.push(i); // 다음 찾을 기준
	}

	while (!s.empty()){ // 안 비었을 수도 있다. 
		ans[s.top()] = -1; // 더 이상 큰 수가 없다는 뜻이므로 -1 준다.  
		s.pop(); // 빼준다.   
	}

	for (int i=0; i < n; i++){
		cout << ans[i] << ' ';
	}

	cout << '\n';
	return 0;

}
```
   
***
# 4. 오등큰수 (등장횟수)
```c++
int n;
cin >> n;
vector<int> a(n);
vector<int> ans(n);
for(int i=0; i< n; i++){
	cin >> a[i];
}
stack<int> s;
s.push(0);
for(int i=1;i<n;i++){
	if(s.empty()){
		s.push(i);
	}
	while(!s.empty() && freq[a[s.top()]] < freq[a[i]]){
		ans[s.top()] = a[i];
		s.pop();
	}
	s.push(i);
}
while (!s.empty()){
	ans[s.top()] = -1;
	s.pop();
}
for (int i=0; i < n; i++){
	cout >> ans[i] << ' ';
}
cout << '\n';
return 0;
```
