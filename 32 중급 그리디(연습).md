# 32 중급 그리디(연습)
## 잃어버린 괄호 https://www.acmicpc.net/problem/1541  
* 식에 괄호를 쳐서 식의 값을 최소로 만드는 문제    
* -가 나오면 뒤의 모든 식을 -로 만들 수 있습니다.      
  * 1+2+3-4-5+6+7+8-9+10-11-12+13+14+15     
  * 1+2+3-4-(5+6+7+8)-(9+10)-11-(12+13+14+15)     
* 즉 플러스가 나오다가 마이너스가 나오면 수를 빼주는 방식으로 구현할 수 있습니다.      
* 더 쉽게 말하자면 `1+2+3-4-5-6-7-8-9-10-11-12-13-14-15`식으로 계산이 되기 때문에 한번만 나와도 다 마이너스 처리한다.      
* 필자같은 경우는 브루트포스방식인 순열을 생각했는데 이는 시간이 너무 오래걸릴 것 같습니다.      

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
    string s;
    cin >> s;
    vector<int> num;
    vector<int> sign;
    bool minus = false;
    int cur = 0;
    sign.push_back(1); // 맨 앞은 더하기라 가정.
    for (int i=0; i<s.size(); i++) {
        if (s[i] == '+' || s[i] == '-') {
            if (s[i] == '+') {
                sign.push_back(1);
            } else {
                sign.push_back(-1);
            }
            num.push_back(cur); // 연산자가 오면 기존에 쌓였던 값 넣기.
            cur=0; // 그리고 자리수는 0으로 초기화.
        } else {
            cur = cur * 10 + (s[i] - '0'); // 값 계산하여 쌓기.
        }
    }
    num.push_back(cur); // 마지막이 수일테니 해다 숫자 넣기.
     
    int ans = 0; // 결과를 위한 값
    minus = false; // 처음은 마이넉스가 아니므로 false;
    for (int i=0; i<num.size(); i++) {
        if (sign[i] == -1) { // 마이너스라면
            minus = true; // 마이너스를 트루로바꿔주기.
        }
        if (minus) {
            ans -= num[i]; // 다빼버리기
        } else {
            ans += num[i]; // 다 더하기
        }
    }
    cout << ans << '\n';
    return 0;
}
// 1+2+3-4-5+6+7+8-9+10-11-12+13+14+15  가정했을 때  
// 1+2+3-4-(5+6+7+8)-(9+10)-11-(12+13+14+15) 로 변경이 가능하고 
// 1+2+3-4-5-6-7-8-9-10-11-12-13-14-15 식으로 계산이 가능하다.    
// 한번만 마이너스가 나오더라도 뒤에는 다 마이너스로 처리하면 된다는 의미이다.  
```
* 해당 문제에서 느낀점은 우선 무언가를 넣는다고 해서 무조건 브루트포스, 순열이 아니란점   
* 문제를 잘 읽어봐서 원하는 형태를 구상할 것   
* 구상한 것을 우선 다 계산해보고 거기서 패턴을 찾을 것   
* 계산하지도 않고 보기만해서 아는 경우는 거의 없다. -> 계산해보고 패턴 찾을 것     
   
## 수묶기 https://www.acmicpc.net/problem/1744  
* 길이가 N인 수열에서 두 수를 적절히 묶어서 수열의 합을 최대로 만드는 것  
* 수의 순서를 바꿔도 상관없다.      
* 같은 위치에 있는 수를 묶는 것은 불가능하고     
* 각 수는 단 한번만 묶거나 묶지 않아야 한다.   
* 묶은 후에는 두 수의 곱이 수가 됨 
* 이 때 최대 찾기      
   
이 방법에 대한 해법은 아래와 같다.          
* 양수는 양수끼리 최대한 큰수끼리     
* 음수는 음수끼리 최대한 작은 수 끼리  
* 0은 묶지
