합분해까지
=======================  
# 들어가기에 앞서 정리하면서 느낀점  
             
다이나믹을 사용할 때 거의 대부분 새로 배열을 만들어 사용한다.           
내가 현재 잘 못하는 것인데 해당 배열이 어떻게 사용하려는지를 알고 이해해야한다.           
예를 들면 모든 경우의 수, 최대값, 최소값 이렇게 나누어질 경우 어떤식으로 값을 더해줄지 신경써야 된다.        
          
그리고 최소값은 초기값으로 0을 넣어주면 안되는 것도 기억하자!       
      
그리고 막상 코드를 짜면 몇 줄 안되지만 이를 추적하기에는 너무 머리가 복잡하게 돌아간다.    
하지만 어떠한 패턴이 존재하고 이는 한 단계만 분리시켜주면 된다는 공식이다.      
앞서 말했듯이 d[] 의 속성이 무엇인지를 파악하고             
더해주는 값이 경우의 수이면 ```d[n] += d[n-?]...``` 로 하위 경우의 수를 다 더해주는 값을 가지고     
최소값이랑 최대값은 거의  ```d[n]=d[n-?]+...``` 이지만 조건식에 따라 결과가 차이나진다.         
   
또한 제약사항이 들어오면 배열이 새로 생기던가 차원이 하나 더 증가하고     
마지막 값을 이용하는 것도 차원이 하나더 생기는 식의 패턴이 있다.       
     
# 1. 가장 긴 증가하는 부분 수열 (LIS)           
* 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 문제           
* 예시          
* A=[10,20,10,30,20,50]            
* 가장 긴 증가하는 부분 수열 A=[**10**,**20**,10,**30**,20,**50**]                 
        
가장 길게 이어진 횟수를 구하는 문제로              
10 -> 20 -> 30 -> 50 순으로 4회를 걸쳐서 부분 수열을 나타낼 수 있다는 것을 알 수 있다.          
      
**코드**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i=0; i<n; i++) {
        cin >> a[i];
    }
    vector<int> d(n);
    for (int i=0; i<n; i++) {
        d[i] = 1;
        for (int j=0; j<i; j++) {
            if (a[j] < a[i] && d[j]+1 > d[i]) {
                d[i] = d[j]+1;
            }
        }
    }
    
    cout << *max_element(d.begin(),d.end()) << '\n';
    return 0;
}
```    
위 코드는 단순히 부분 수열의 길이를 구한것이다.             
          
그렇다면 해당하는 부분수열을 구하는 방법은 없을까?             
물론 존재한다!!        
            
여러 방법이 있지만 이번에는 인덱스를 저장하는 배열을 새로 만들어            
역추적을 통해 해당 값을 불러오는 방법을 사용해보겠다.                  
           	   
**역추적을 이용한 부분 수열 값 출력**        
```c++
#include <iostream>
using namespace std;
int a[1000];
int d[1000];
int v[1000];

void go(int p) { // 처음에는 count가 가장 많이 있는 인덱스가 들어온다.  
    if (p == -1) {
        return; // 재귀 -1 이라면 종료 
    }
    go(v[p]); // 재귀 반복 진행  
    cout << a[p] << ' '; // -> 선 재귀 후 출력이므로 가장 안쪽부터 출력되어 나온다.
	// 해당 코드에서 가장 안쪽을 의미하는 것은 앞쪽 인덱스를 의미
	// 즉, 가장 앞부터 뒤로 출력을 시킨다.  
} 

int main() {
    int n; // 입력 횟수
    cin >> n; 
    for (int i=0; i<n; i++) {
        cin >> a[i]; // 입력값을 통한 초기화 진행
    }
    for (int i=0; i<n; i++) { // count 구하기 
        d[i] = 1; // 모든수는 우선적으로 1회가 되므로 
        v[i] = -1; // 포인터 진행시 탈출 조건을 위한 값 기술 
        for (int j=0; j<i; j++) { // 부분 수열 만들기 
            if (a[j] < a[i] && d[i] < d[j]+1) { // 기준보다 앞에가 값이 작을 경우 && 수열 횟수가 높을 경우
                d[i] = d[j]+1; // 높은 수열 +1 로 해당 카운트를 가져온다. 
                v[i] = j; // 각 카운트가 저장될때의 위치 V배열에 저장한다.
            }
        }
    }

    int ans = d[0]; // ans는 최대 카운트수의 결과를 위한 것이다.  
    int p = 0; // 최대 카운트를 가진 인덱스 -> 후에 재귀로 값을 호출하기 위해서 빼냄
	// 위 코드에서는 j가 j<n 이므로 n이 가장 클 경우를 제외하기에 이러한 작업 필요  
    for (int i=0; i<n; i++) { // 가장 큰 값 탐색 
        if (ans < d[i]) { // 기준 보다 클 경우
            ans = d[i]; // 해당 값을 기준으로 변경 
            p = i; // 연산까지에서의 가장 큰 값의 인덱스
        }
    }
    cout << ans << '\n'; // 가장 많은 카운트 출력 
    go(p); // 출력을 위한 재귀 호출 
    cout << '\n'; // 개행
    return 0;
}
``` 
개인적으로 이외에도 배열을 이용해서 다른 방법을 취할 수 있을 것 같은데 이는 연구해봐야겠다.      
                 
***    
# 2. 연속합       
* n개의 정수로 이루어진 양의의 수열이 주어진다.          
* 우리는 이 중 연속된 몇 개의 숫자를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다.       
* 단, 숫자는 한 개 이상 선택해야 한다.       
* 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 가정시에        
* 여기서 정답은 12+21인 33이다.       
               
**요점**   
1. 음수는 합을 작게 만든다.    
2. 즉, 음수를 기준으로 수열을 나누어 주는 것이 좋다.     
3. 하지만 이는 위의 예시에서만 그렇고 3,-1,3 경우에는 3개를 다 합해서 5를 낼 수 있다.     
그래서 우리는 각각의 수를 통해서 연속합을 구하려고 한다.  

**점화식**
1. 기준 값이 ```-```일 때 
2. 기준 값을 더한 결과 값이 짜르고 새로 시작한 값보다 클 경우 자르지 않고    
3. 반대로 짜르고 새로 시작한 값이 더 클 경우 자른다.  
   
* d[i]=i번째 수로 끝나는 **가장 큰 연속합**    
              
**내가 짠 코드 == 24초**    
```c++
#include <iostream>
using namespace std;
    
int a[100000];
long long d[100000];

int main() {
    int num;
	cin >> num;

	for(int i=0; i < num; i++){
		cin >> a[i];
	}

	d[0] = a[0];
	for(int i=1; i < num; i++){ 
		if(a[i] > d[i-1]+a[i]){
			d[i] = a[i];			
		} else {
			d[i] = d[i-1]+a[i];
		}
	}
	int max = -99999;
	for(int i=0; i < num; i++){
		if(max < d[i]){
			max = d[i];
		}
	}

	cout << max << "\n";
	return 0;
}
```      
**강의 코드 == 8초**
```c++
#include <iostream>
using namespace std;
    
int a[100000];
long long d[100000];

int main() {
    int num;
	cin >> num;

	for(int i=0; i < num; i++){
		cin >> a[i];
	}

	d[0] = a[0];
	for(int i=1; i < num; i++){ 
		d[i] = a[i];
		if(d[i] < d[i-1]+a[i]){
			d[i] = d[i-1]+a[i];			
		} 
	}
	int max = -99999;
	for(int i=0; i < num; i++){
		if(max < d[i]){
			max = d[i];
		}
	}

	cout << max << "\n";
	return 0;
}
```

***
# 3. 제곱수의 합
* 주어진 자연수 N을 제곱수들의 합으로 표현할 때에 그 항의 최소 개수를 구하는 문제       
* 11 = 3^2 + 1^2 + 1^2;       
   
**점화식**
* d^2 + c^2 + b^2 + a^2 =N 는 [N-a^2] + a^2 =N 로 표현이 가능하다.    
* 문제는 항의 개수를 찾는 것이므로 **d[N-a^2] + 1 = N** 의 형식을 띈다.  
* 최소 개수를 구하는 문제이므로 min을 사용해서 값을 얻으면 된다.  

```c++
#include <iostream>
using namespace std;
int d[100001];
int main() {
    int n;
    cin >> n;
    for (int i=1; i<=n; i++) { // d[n] 을 구하기 위함 
        d[i] = i; // 2 같은 수들을 위한 최기화 진행  
		// 초기화를 왜 이렇게 진행했을까? -> 최대 많은 수는 1로 n번 더한것이므로  
		// 카드 구매하기2 처럼 초기값을 0으로 한 이유는 
		// 최소값일 때는 초기화를 0으로 하면 안된다. 
        for (int j=1; j*j <= i; j++) { // n까지 구하는 것이므로 루트n 까지만 생각
            if (d[i] > d[i-j*j]+1) { // i=4 부터 판단 가능 -> j는 2까지 가능 4 > 3 이므로
                d[i] = d[i-j*j]+1; 
			}
        }
    }
    cout << d[n] << '\n';
    return 0;
}
```
여기서 중요한 점은 초기 값을 왜 저렇게 주었느냐이다 이부분을 잘 생각해보자  
     
***  
# 4. 합분해
* 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수   
* D[k][n] = 0 부터 n 까지의 정수 k개를 더해서 그 합이 n이 되는 경우의 수  
* ?+?+?+?....+?+L = N   
* 위의 식이 나타내는 값 D[K][N]   
* ?+?+?+?....+?= N-L
* 위의 식이 나타내는 값 D[K][N-L]    
* D[K][N-L] = 시그마[k-1][N-L] (0 <= L <= N)

```c++
#include <iostream>
using namespace std;
long long d[201][201];
long long mod = 1000000000;
int main() {
    int n, k;
    cin >> n >> k;
    d[0][0] = 1LL;  // 이건 이유를 잘 모르겠다 다시 봐야겠다.   

    for (int i=1; i<=k; i++) {
        for (int j=0; j<=n; j++) {
            for (int l=0; l<=j; l++) {
                d[i][j] += d[i-1][j-l];
                d[i][j] %= mod;
            }
        }
    }
    cout << d[k][n] << '\n';
    return 0;
}
```
아마 이부분이 이해하기가 가장 어려운 부분이 아니었나 싶다.   
코드를 해석해보면서 이해를 해보도록 하자  
```20 2```이라고 입력을 진행을 한다면 2개의 식을 통해서만 20을 도출해야 한다.

```
a1 + a2  =  20
___K____   __N__
```
그럼 여기서 한 단계를 물러나서 생각하면 어떻게 될까?
```
a1  =  20-a2
__K-1__   __N-a2__
```
가 되고 ```K는 기존 K-1``` 이고 ```N은 n-a2```이다.            
a1과 a2는 정해진 수가 아니기에 a2를 추가적으로 ```L```이라는 이름을 가지도록 했다.       
         
a1과 a2는 서로의 값에 의해서 결정되기에     
앞서 ```k-1```에서의 값에 따라서 후에 값이 달라진다.      
즉, ```k-1```에서 1을 더했으면 ```k```에서는 19가 더해져야하고    
```k-1```에서 2를 더했으면 ```k```에서는 18이 더해져야한다.         
그리고 이렇게 구한 값들도 이미 이전에 얻은 경우의수들이 있으므로     
사실상 [n]은 [n-L]에 대한 모든 경우의 수를 합한 값이 되어야 한다.    
즉 ```반복(d[k][n] += d[k-1][n-L..])``` 형태를 가지게 된 것이다.    

