합분해까지
=======================
# 1. 가장 긴 증가하는 부분 수열 (LIS) 
* 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 문제  
* 예시 
* A=[10,20,10,30,20,50]   
* 가장 긴 증가하는 부분 수열 A=[**10**,**20**,10,**30**,20,**50**]     

```c++
#include <iostream>
using namespace std;
int a[1000];
int d[1000];
int v[1000];


void go(int p) { // 처음에는 count가 가장 많이 있는 인덱스가 들어온다.  
    if (p == -1) {
        return; // 재귀 -1 이라면 종료 
    }
    go(v[p]); // 재귀 반복 진행  
    cout << a[p] << ' '; // -> 선 재귀 후 출력이므로 가장 안쪽부터 출력되어 나온다.
	// 해당 코드에서 가장 안쪽을 의미하는 것은 앞쪽 인덱스를 의미
	// 즉, 가장 앞부터 뒤로 출력을 시킨다.  
} 

int main() {
    int n; // 입력 횟수
    cin >> n; 
    for (int i=0; i<n; i++) {
        cin >> a[i]; // 입력값을 통한 초기화 진행
    }
    for (int i=0; i<n; i++) { // count 구하기 
        d[i] = 1; // 모든수는 우선적으로 1회가 되므로 
        v[i] = -1; // 포인터 진행시 탈출 조건을 위한 값 기술 
        for (int j=0; j<i; j++) { // 부분 수열 만들기 
            if (a[j] < a[i] && d[i] < d[j]+1) { // 기준보다 앞에가 값이 작을 경우 && 수열 횟수가 높을 경우
                d[i] = d[j]+1; // 높은 수열 +1 로 해당 카운트를 가져온다. 
                v[i] = j; // 각 카운트가 저장될때의 위치 V배열에 저장한다.
            }
        }
    }

    int ans = d[0]; // ans는 최대 카운트수의 결과를 위한 것이다.  
    int p = 0; // 최대 카운트를 가진 인덱스 -> 후에 재귀로 값을 호출하기 위해서 빼냄
	// 위 코드에서는 j가 j<n 이므로 n이 가장 클 경우를 제외하기에 이러한 작업 필요  
    for (int i=0; i<n; i++) { // 가장 큰 값 탐색 
        if (ans < d[i]) { // 기준 보다 클 경우
            ans = d[i]; // 해당 값을 기준으로 변경 
            p = i; // 연산까지에서의 가장 큰 값의 인덱스
        }
    }
    cout << ans << '\n'; // 가장 많은 카운트 출력 
    go(p); // 출력을 위한 재귀 호출 
    cout << '\n'; // 개행
    return 0;
}
```


## 1.1. Overlapping Subproblem : 겹치는 부분(작은)문제      
## 1.2. Optimal Substructure : 최적부분구조           
## 1.3. 다이나믹 프로그래밍의 특징   
***
# 2. 다이나믹 프로그래밍 구현 방식  
## 2.1. Top-down
## 2.2. Bottom-up     
