합분해까지
=======================
# 1. 가장 긴 증가하는 부분 수열 (LIS)       
* 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 문제        
* 예시        
* A=[10,20,10,30,20,50]          
* 가장 긴 증가하는 부분 수열 A=[**10**,**20**,10,**30**,20,**50**]           
        
**코드**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i=0; i<n; i++) {
        cin >> a[i];
    }
    vector<int> d(n);
    for (int i=0; i<n; i++) {
        d[i] = 1;
        for (int j=0; j<i; j++) {
            if (a[j] < a[i] && d[j]+1 > d[i]) {
                d[i] = d[j]+1;
            }
        }
    }
    
    cout << *max_element(d.begin(),d.end()) << '\n';
    return 0;
}
```

**역추적을 이용한 부분 수열 값 출력**
```c++
#include <iostream>
using namespace std;
int a[1000];
int d[1000];
int v[1000];


void go(int p) { // 처음에는 count가 가장 많이 있는 인덱스가 들어온다.  
    if (p == -1) {
        return; // 재귀 -1 이라면 종료 
    }
    go(v[p]); // 재귀 반복 진행  
    cout << a[p] << ' '; // -> 선 재귀 후 출력이므로 가장 안쪽부터 출력되어 나온다.
	// 해당 코드에서 가장 안쪽을 의미하는 것은 앞쪽 인덱스를 의미
	// 즉, 가장 앞부터 뒤로 출력을 시킨다.  
} 

int main() {
    int n; // 입력 횟수
    cin >> n; 
    for (int i=0; i<n; i++) {
        cin >> a[i]; // 입력값을 통한 초기화 진행
    }
    for (int i=0; i<n; i++) { // count 구하기 
        d[i] = 1; // 모든수는 우선적으로 1회가 되므로 
        v[i] = -1; // 포인터 진행시 탈출 조건을 위한 값 기술 
        for (int j=0; j<i; j++) { // 부분 수열 만들기 
            if (a[j] < a[i] && d[i] < d[j]+1) { // 기준보다 앞에가 값이 작을 경우 && 수열 횟수가 높을 경우
                d[i] = d[j]+1; // 높은 수열 +1 로 해당 카운트를 가져온다. 
                v[i] = j; // 각 카운트가 저장될때의 위치 V배열에 저장한다.
            }
        }
    }

    int ans = d[0]; // ans는 최대 카운트수의 결과를 위한 것이다.  
    int p = 0; // 최대 카운트를 가진 인덱스 -> 후에 재귀로 값을 호출하기 위해서 빼냄
	// 위 코드에서는 j가 j<n 이므로 n이 가장 클 경우를 제외하기에 이러한 작업 필요  
    for (int i=0; i<n; i++) { // 가장 큰 값 탐색 
        if (ans < d[i]) { // 기준 보다 클 경우
            ans = d[i]; // 해당 값을 기준으로 변경 
            p = i; // 연산까지에서의 가장 큰 값의 인덱스
        }
    }
    cout << ans << '\n'; // 가장 많은 카운트 출력 
    go(p); // 출력을 위한 재귀 호출 
    cout << '\n'; // 개행
    return 0;
}
``` 
    
***
# 2. 연속합  
* n개의 정수로 이루어진 양의의 수열이 주어진다.  
* 우리는 이 중 연속된 몇 개의 숫자를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다.  
* 단, 숫자는 한 개 이상 선택해야 한다.  
* 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 가정시에  
* 여기서 정답은 12+21인 33이다.  
    
**요점**   
1. 음수는 합을 작게 만든다.    
2. 즉, 음수를 기준으로 수열을 나누어 주는 것이 좋다.     
3. 하지만 이는 위의 예시에서만 그렇고 3,-1,3 경우에는 3개를 다 합해서 5를 낼 수 있다.     
그래서 우리는 각각의 수를 통해서 연속합을 구하려고 한다.  

**점화식**
1. 기준 값이 ```-```일 때 
2. 기준 값을 더한 결과 값이 짜르고 새로 시작한 값보다 클 경우 자르지 않고    
3. 반대로 짜르고 새로 시작한 값이 더 클경우 자른다.  

* d[i]=i번째 수로 끝나는 **가장 큰 연속합** 
          
**내가 짠 코드 == 24초**    
```c++
#include <iostream>
using namespace std;
    
int a[100000];
long long d[100000];

int main() {
    int num;
	cin >> num;

	for(int i=0; i < num; i++){
		cin >> a[i];
	}

	d[0] = a[0];
	for(int i=1; i < num; i++){ 
		if(a[i] > d[i-1]+a[i]){
			d[i] = a[i];			
		} else {
			d[i] = d[i-1]+a[i];
		}
	}
	int max = -99999;
	for(int i=0; i < num; i++){
		if(max < d[i]){
			max = d[i];
		}
	}

	cout << max << "\n";
	return 0;
}
```      
**강의 코드 == 8초**
```c++
#include <iostream>
using namespace std;
    
int a[100000];
long long d[100000];

int main() {
    int num;
	cin >> num;

	for(int i=0; i < num; i++){
		cin >> a[i];
	}

	d[0] = a[0];
	for(int i=1; i < num; i++){ 
		d[i] = a[i];
		if(d[i] < d[i-1]+a[i]){
			d[i] = d[i-1]+a[i];			
		} 
	}
	int max = -99999;
	for(int i=0; i < num; i++){
		if(max < d[i]){
			max = d[i];
		}
	}

	cout << max << "\n";
	return 0;
}
```

***
# 3. 제곱수의 합
* 주어진 자연수 N을 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 문제  
* 11 = 3^2 + 1^2 + 1^2;

**점화식**
* d^2 + c^2 + b^2 + a^2 =N 는 [N-a^2] + a^2 =N 로 표현이 가능하다.    
* 문제는 항의 개수를 찾는 것이므로 **d[N-a^2] + 1 = N** 의 형식을 띈다.  
* 최소 개수를 구하는 문제이므로 min을 사용해서 값을 얻으면 된다.  

```c++
#include <iostream>
using namespace std;
int d[100001];
int main() {
    int n;
    cin >> n;
    for (int i=1; i<=n; i++) { // d[n] 을 구하기 위함 
        d[i] = i; // 2 같은 수들을 위한 최기화 진행  
		// 초기화를 왜 이렇게 진행했을까? -> 최대 많은 수는 1로 n번 더한것이므로  
		// 카드 구매하기2 처럼 초기값을 0으로 한 이유는 
		// 최소값일 때는 초기화를 0으로 하면 안된다. 
        for (int j=1; j*j <= i; j++) { // n까지 구하는 것이므로 루트n 까지만 생각
            if (d[i] > d[i-j*j]+1) { // i=4 부터 판단 가능 -> j는 2까지 가능 4 > 3 이므로
                d[i] = d[i-j*j]+1; 
			}
        }
    }
    cout << d[n] << '\n';
    return 0;
}
```
여기서 중요한 점은 초기 값을 왜 저렇게 주었느냐이다 이부분을 잘 생각해보자  
     
***  
# 4. 합분해
* 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수   
*
*
