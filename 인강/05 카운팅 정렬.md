항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여,     
선형 시간에 정렬하는 효율적인 알고리즘   

## 제한 사항  
* 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능   
    * 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.   
* 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.  

## 시간 복잡도  
O(n+k):n은 리스트 길이, k는 정수의 최대값  

카운팅 배열은   
각 숫자들의 누적합으로 정의한다.  

**정렬되지 않은 수**
|0|4|1|3|1|2|4|1|
|-|-|-|-|-|-|-|-|
    
**누적합(인덱스와 일치하는 숫자의 갯수-누적합**   
|1|4|5|6|8|   
|-|-|-|-|-|   

   
* 정렬하고 싶은 데이터의 맨 뒤를 본다.     
* 데이터의 카운팅 위치(카운트배열)를 본다.        
* 1은 4로 써져있다.   
* 4의 위치로 1을 이동시킨다.     
* 그리고 카운팅 위치(카운트배열)의 해당 인덱스 값을 1줄인다.   
  
**정렬이 완료될 배열**   
|0|0|0|1|0|0|0|0|
|-|-|-|-|-|-|-|-|

**누적합(인덱스와 일치하는 숫자의 갯수-누적합**   
|1|`3`|5|6|8|   
|-|-|-|-|-|   

___

**정렬되지 않은 수**
|0|4|1|3|1|2|x|x|
|-|-|-|-|-|-|-|-|

**정렬이 완료될 배열**   
|0|0|0|1|0|0|0|4|
|-|-|-|-|-|-|-|-|

**누적합(인덱스와 일치하는 숫자의 갯수-누적합**   
|1|3|4|6|`7`|   
|-|-|-|-|-|   

___

**정렬되지 않은 수**
|0|4|1|3|1|x|x|x|
|-|-|-|-|-|-|-|-|

**정렬이 완료될 배열**   
|0|0|0|1|2|0|0|4|
|-|-|-|-|-|-|-|-|

**누적합(인덱스와 일치하는 숫자의 갯수-누적합**   
|1|3|`4`|6|7|   
|-|-|-|-|-|   

___

```java
countingSort(A, B, K)   

    FOR i = 1 to k do         // k번
        C[i] = 0              // 0으로 초기화
    
    FOR j = 1 to n do         // n번 
        C[A[j]] = C[A[j]]+1   // 카운팅 작업 
    
    FOR i = 2 to k do         // k번 
        C[i] = C[i] + C[i+1]  // 카운팅 배열 변형 -> 누적합
    
    FOR j = n to 1 do         // n번
        B[--C[A[j]]] = A[j]   // 정렬 

end countingSort




```

# 단점 
수의 범위가 클 수록, 카운팅 배열 크기가 커져서 정렬하기 힘들 수 있다.  
