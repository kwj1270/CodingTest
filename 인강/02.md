# 재귀    
n개중 K개를 뽑는 조합의 경우의 수 계산을 재귀로 작성해보자    
  
1. 메서드(함수)역할을 명확히 정의하라! (What)       
2. 메서드가 기능을 수행하기 위해 필요한 매개체 값(매개변수-> 결정 요인)   
3. 재귀의 끝 (기저조건)   

필자의 경우 :    
1. 우선 알맞는 기저 조건을 만든다.  
2. 예외 조건을 만든다.    
3. 두 조건을 생각해서 파라미터를 만든다.    
4. 이후에는 정상 동작이니, 분기에 따른 재귀함수를 정의한다.    
4. 분기에 따른 재귀함수는 매개변수의 값을 조작하는 것을 의미한다.  

## 피보나치

```c++
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```

* f0 = 0   
* f1 = 1   
* fn = fn-1 + fn-2 (n >= 2)  

```c++
0,1,1,2,3,5,8,13,21,34,55....
```

* 문제 : N번째 피보나치 수를 구하는 문제  
* 작은 문제 : N-1 번째 피보나치 수를 구하는 문제, N-2 번째 피보나치 수를 구하는 문제 
* 위 같은 동작이 마지막 까지 반복....

큰 문제와 작은 문제는 상대적이다.      
문제를 작은 문제로 쪼갬으로 같은 형식의 구조를 취하고 있으니     
**큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.**    
   
**하지만,**     
같은 인풋을 주면, 같은 아웃풋이 나오는 코드가 너무 많다.     
즉, 이미 한 번 계산한 경험이 있지만, 중복해서 계산하는 코드가 많다.    
더불어 인풋값만 이용하지, 랜덤이나 다른 값을 이용하는 코드가 전혀 없다.   
즉 같은 인풋이면 같은 아웃풋을 보장하는 코드가 중복되서 일어난다.  
(**인풋에만 의존하는 코드가 아니면 아웃풋이 다를 수 있지만, 위 예시는 아니다.**)        

그렇기에 이를 조금 더 해결하고자 [Memoization](#memoization)을 이용한다.   

```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    if(memo[n] > 0){ // 여기서 0은 아직 값을 넣지 않았다는 뜻
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```


### Memoization    
메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서     
매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다.     
동적 계획법의 핵심이 되는 기술이다.     
   
메모이제이션은 글자 그대로 해석하면 메모리에 넣기라는 의미이며       
기억되어야 할 것이라는 뜻의 라틴어에서 파생되었다.     
  
흔히 기억하기 암기하기라는 뜻의 메모라이제이션과 홍동하지만,     
정확한 단어는 메모이제이션이다.     


