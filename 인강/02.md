# 재귀    
n개중 K개를 뽑는 조합의 경우의 수 계산을 재귀로 작성해보자    
  
1. 메서드(함수)역할을 명확히 정의하라! (What)       
2. 메서드가 기능을 수행하기 위해 필요한 매개체 값(매개변수-> 결정 요인)   
3. 재귀의 끝 (기저조건)   

필자의 경우 :    
1. 우선 알맞는 기저 조건을 만든다.  
2. 예외 조건을 만든다.    
3. 두 조건을 생각해서 파라미터를 만든다.    
4. 이후에는 정상 동작이니, 분기에 따른 재귀함수를 정의한다.    
4. 분기에 따른 재귀함수는 매개변수의 값을 조작하는 것을 의미한다.  

## 피보나치

```c++
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```

* f0 = 0   
* f1 = 1   
* fn = fn-1 + fn-2 (n >= 2)  

```c++
0,1,1,2,3,5,8,13,21,34,55....
```

* 문제 : N번째 피보나치 수를 구하는 문제  
* 작은 문제 : N-1 번째 피보나치 수를 구하는 문제, N-2 번째 피보나치 수를 구하는 문제 
* 위 같은 동작이 마지막 까지 반복....

큰 문제와 작은 문제는 상대적이다.      
문제를 작은 문제로 쪼갬으로 같은 형식의 구조를 취하고 있으니     
**큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.**    
   
**하지만,**     
같은 인풋을 주면, 같은 아웃풋이 나오는 코드가 너무 많다.     
즉, 이미 한 번 계산한 경험이 있지만, 중복해서 계산하는 코드가 많다.    
더불어 인풋값만 이용하지, 랜덤이나 다른 값을 이용하는 코드가 전혀 없다.   
즉 같은 인풋이면 같은 아웃풋을 보장하는 코드가 중복되서 일어난다.  
(**인풋에만 의존하는 코드가 아니면 아웃풋이 다를 수 있지만, 위 예시는 아니다.**)        

그렇기에 이를 조금 더 해결하고자 [Memoization](#memoization)을 이용한다.   

```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    if(memo[n] > 0){ // 여기서 0은 아직 값을 넣지 않았다는 뜻
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```

참고로 재귀를 위한 조건은 2가지 상황으로 구분된다.  
  
1. 재귀를 태운다음 거기서 탈출
2. 조건을 검사한 후 재귀를 태움
  
단, 이것은 개발자의 성향이며 자신에게 맞는 작업을 해주면 된다.     

## 반복 VS 재귀   
* 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택     
* 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다.   
    * 추상 자료형의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많다.(tree)    
* 일반적으로, 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 한다.   
* 입력값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.   

||재귀|반복|
|-|---|----|
|종료|재귀 함수 호출이 종료되는 베이스 케이스|반복문의 종료 조건|
|수행 시간|상대적 느림|빠름|
|메모리 공간|많이 사용|적게 사용|
|소스 코드 길이|짧고 간결|길다|
|소스 코드 형태|선택 구조|반복 구조|
|무한 반복 시|스택 오버플로우|cpu를 반복해서 점유|

## 하노이 타워  

```java
import java.util.Scanner;

public class Main {

    public static final Scanner SCANNER = new Scanner(System.in);
    public static int n;
    public static int count=0;
    public static StringBuilder stringBuilder = new StringBuilder();

    public static void main(String[] args) {
        n = SCANNER.nextInt();
        hanoi(n,1,2,3);
        System.out.println(count);
        System.out.println(stringBuilder.toString());
    }

    public static void hanoi(int n, int start, int temp, int destination){
        count++;
        if(n == 1) {
            stringBuilder.append(start+ " "+destination).append("\n");
            return;
        }
        hanoi(n-1, start, destination, temp);   // n-1를 임시로 보내야지 일단. , 한 칸위 접시들은 알아서 돌겠지
        stringBuilder.append(start+" "+destination).append("\n");   // 나를 최종으로 보냄(가장 큰놈)  
        hanoi(n-1, temp, start, destination);   // 임시에 있는 n-1를 목적지로 보내야지 , 한 칸위 접시들은 알아서 돌겠지  
    }

}
```

## 2차원 배열   
* Array of Array  
* 2차원 이상의 다차원 배열은 각 차원에 따라 크기를 명시한다.   
* 2차원 배열의 생성은 세로길이, 가로길이를 필요로한다.  

### 배열 순회  
N x M 배열의 모든 원소를 빠짐없이 조사하는 방법 

**행 우선 순회**
```java
int i;
int j;

for i form 0 to n-1
    for j form 0 to m-1
        Array[i][j] // 필요한 연산 수행 
```


**열 우선 순회**
```java
int i;
int j;

for j form 0 to m-1
    for i form 0 to n-1
        Array[i][j] // 필요한 연산 수행 
```


**지그재그 우선 순회**
```java
int i;
int j;

for i form 0 to n-1
    for j form 0 to m-1
        Array[i][j + ((m-1-(2*j) * (i % 2))] // 필요한 연산 수행 
        // (열의크기-1)-(2*j) * (i 나누기 2의 나머지)
        // 짝수일 경우 일반 j 진행 
        // 홀수일 경우 곱한 j 진행 
        // 그러나 꼭 이렇게 한 줄로 안짜도 된다. -> 상황에 따라서 홀짝에 맞게끔 짜도 된다.  
        
        
        // 0      3    3만큼 더함 
        // 1      2    1만큼 더함
        // 2      1    1만큼 줄어듬
        // 3      0    3만큼 줄어듬 
        
        // 중간에 어떤 연산을 해주어야겠네?
        // 그리고 인덱스가 짝수이면 원래값 되도록
        
        // 1. 짝수 == 0으로 홀수 == 1로 곱하는 제약을 넣자  
        
        // 중간 연산
        // 3 - 0
        // 3 - 2
        // 3 - 4
        // 3 - 6
        
        // 3이 고정됨 (m-1)  
        // 2배씩 늘어남 (2*j)  
        // 찢었다..
```

시뮬레이션 문제는 배열을 내가 가지고 놀아야 된다.     


## 2차원 배열의 접근 
### 델타를 이용한 2차 배열 탐색 

```java
ary[0..n-1][0..n-1]
dr[] <- {-1, 1, 0, 0}; // 상하 좌우 
dc[] <- {0, 0, -1, 1};

for r from 0 to n-1
    for c from 0 to n-1
        for d from 0 to 3 {
            nr = r + dr[d]
            nc = c + dc[d]
            arr[nr][nc];
            // 4의 조건 검사 -> (nr  >= 0 && nr < n) && (nc  >= 0 && nc < n)  안에 있어야 한다.
            
}
```

### 전치 행렬
행과 열을 뒤집어보자  
```java
int arr[3][3];
int i;
int j;

for i from 0 to 2   
    for j form 0 to 2
        if( i < j )     // 이게 중요한 듯, 한번에 처리하기도 하고     
            swap(arr[i][j], arr[j][i]);

1,2,3
4,5,6
7,8,9

// 중요한건 159는 그대로 놔두어도 된다.
// i == j 일 경우 대각선 \ 형태
// i > j 일 경우 이를 뒤집는거 어때?  
23    4
 6 과 78

// 좀 더 개선된 방안 

int arr[3][3];
int i;
int j;

for i from 0 to 2   
    for j form i+1 to 2
            swap(arr[i][j], arr[j][i]);

j자체를 i보다 1칸 더 크게 시작하면 if 넣을 필요 없다.   

```

## 연습 문제





## Memoization    
메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서     
매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다.     
동적 계획법의 핵심이 되는 기술이다.     
   
메모이제이션은 글자 그대로 해석하면 메모리에 넣기라는 의미이며       
기억되어야 할 것이라는 뜻의 라틴어에서 파생되었다.     
  
흔히 기억하기 암기하기라는 뜻의 메모라이제이션과 홍동하지만,     
정확한 단어는 메모이제이션이다.     


