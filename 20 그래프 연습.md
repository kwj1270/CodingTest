그래프 연습
=======================
# 1. Two Dots

* Two Dots 게임에서 크기가 4이상인 사이클의 존재 여부를 구하는 문제  
* 우리는 DFS 알고리즘을 이용할 것이다.   
* 크기가 4이상의 사이클이 존재하려면 4번은 이동해야 한다.  
* 그렇기에 존재 여부를 확인하는 것이기 때문에, 최소 4칸 이동할 수 있는지 검사하면 된다.   

```c++
// x y 는 현재 위치  
// cnt 는 연속된 카운트의 수  
// color는 내 색깔  
bool go (int x, int y, int cnt, char color){
	if(cnt == 4) return true;
	for(int k=0; k < 4 ; k++){
		int nx = x+dx[k], ny = y+dy[k]; // 상하 좌우   
		if(0 <= nx && nx < n && 0 <= ny && ny < m){ // 0보다 크고 끝보다 작으면 -> 다음 이동
			if(check[nx][ny] == false && a[nx][ny] == color){
				if(go(nx, ny, cnt+1, color)){ 
					return true;
				}
			}
		}
	}
	false; // 갈곳이 없다는 뜻으로 false 됨
}
```
그런데 이 코드는 4칸이상 이동하는 **사이클**을 찾는 것이 아닌      
단순히 사이클이 있는지 없는지 true/false 만 나타내주는 코드이다.      
그래서 아래와 같이 코드를 수정해보았다.  

* 각 칸을 방문할때, 시작점으로부터 거리를 기록해서 4이상이면 사이클을 찾았다고 할 수 있다.  
```
4/0      1
()-------()
|         |
()-------()
3         2
```
단 조심해야 할 점은 갔다가 원래 자리로 돌아오는 것도 카운터에 포함되니 이러한 것은 예외 처리를 해준다.   

```c++

// x y 는 현재 위치  
// cnt 는 연속된 카운트의 수  
// color는 내 색깔  
bool go (int x, int y, int cnt, char color){
	// 이미 방문한적 있으면 4이상의 차이가 있는지 확인해본다.  
	if(check[x][y]) return (cnt - dist[x][y]) >= 4; 
	// () ==> () 갔다가 () <== () 가는 형태가 cnt가 2가된다. 이를 방지해야하기 위해 작성했다.   
	
	// 0/4    1
	// () ==> ()     
	// ||	  ||
	// () <== () 
	// 3       2

	// dist[][]는 당시 cnt 값을 가진다.
	// 이렇게 가야 처음 dist[x][y] = 0 이었고 돌아왔을때 cnt가 4가 되므로
	// 4-0은 4가 되는 것이다.  
	// 위 같은 모형은 최소 크기의 사이클을 돌았다는 뜻이다.   
	
  
	// 0     5/1     2       
	// () ==> () ==> ()     
	//        ||	   ||
	//        () <== () 
	//        4       3
  	// 5-1 >= 4
  
  	// 6/0     1     2       
	// () ==> () ==> ()     
	// ||     ||	   ||
	// () <== () <== () 
	// 5      4       3
 	 // 6-0 >= 6
  
  
	check[x][y] = true; // 도착했으니 true 표시 -> xy에 방문한거고  
	dist[x][y] = cnt; // 시작점으로부터의 거리 -> 지금까지 이동한 칸의 갯수
	// 단 몇번만에 갔냐 이걸 말하는거지 최소 이동은 아니다.  
	// 왜냐하면 방향성은 dx dy의 배치에 따라 다르기에 
	// 그냥 주어진 환경에서 몇번만에 왔냐를 의미한다.  

	// 어떤 기준으로 x,y에 위치했을때의 거리 차이를 의미한다.  

	for(int k=0; k < 4 ; k++){
		int nx = x+dx[k], ny = y+dy[k]; // 상하 좌우   
		if(0 <= nx && nx < n && 0 <= ny && ny < m){ // 0보다 크고 끝보다 작으면 -> 다음 이동
			if(a[nx][ny] == color){
				if(go(nx, ny, cnt+1, color)){ 
					return true;
				}
			}
		}
	}
	false; // 갈곳이 없다는 뜻으로 false 됨
}
```

* 이전 칸과 다른 칸으로 연속해서 이동했을때,  
이미 방문한 칸을 방문햇으면 사이클이 존재한다고 볼 수 있다.   




***
# 2. 이분 그래프   
* 그래프가 2개로 나누어진 그래프      
* 한쪽과 다른 한쪽으로 나누어져 있어서     
* 모든 간선이 A 와 B사이에 만 있는 그래프        
* 예를 들면 여러 사람이 여러 물건중 하나를 선택하는 구조      
* 다른 예로 학생이 수업을 수강신청하는 구조로 
___
* 그래프를 다음과 같이 A와 B로 나눌 수 있으면 이분 그래프라고 한다.   
* A 에 포함되어 있는 정점끼리 연결된 간선이 없음  
* B 에 포함되어 있는 정점끼리 연결된 간선이 없음 
* 모든 간선의 한 끝 점은 A에, 다른 끝점은 B에  

***
# 3. 단지번호 붙이기
* 정사각형 모양의 지도가 있다.     
* 0은 집이 없는 곳, 1은 집이 있는 곳      
* 지도를 가지고 연결된 집의 모양인 단지를 정의하고, 단지에 번호를 붙이려고 한다.    
* 연결 : 좌-우 아래-위로 집이 있는 경우    
___
* DFS나 BFS 알고리즘을 이용해서 어떻게 이어져있는지 확인할 수 있다.  
* d[i][j] = (i,j)를 방문 안했으면 0, 했으면 단지 번호를 입력  

***
# 4. 섬의 개수   
단지번호 붙이기와 비슷하지만 4방향이 아니라 대각 방향도 추가해서 8방향이다.   


***
# 5. 미로 탐색  
**그리드 탐색!!**    
   
* (1,1)에서 (N,M)으로 가는 가장 빠른 길을 구하는 문제  
* DFS 탐색으로는 문제를 풀 수 없다.   
* BFS 탐색을 사용해야 한다.  
* BFS는 단계별로 진행된다는 사실을 이용  

***
# 6. 토마토
   
* 하루가 지나면, 익은 토마토의 인접한 곳에 있는 익지 않은 토마토들이 익게된다.     
* 인접한 곳: 앞, 뒤, 왼쪽, 오른쪽      
* 토마토가 저절로 익는 경우는 없다.       
* 상자안의 익은 토마토와 익지 않은 토마토가 주어졌을 때,         
며칠이 지나면 토마토가 모두 익는지 구하는 문제      
  
***
# 7. 나이트의 이동
* 체스판 위에 한 나이트가 있을 때, 나이트가 이동하려고 하는 칸이 주어짐   
* 이 때, 최소 몇 번만에 이동할 수 있는지 구하는 문제  

