그래프 연습
=======================
# 1. Two Dots

* Two Dots 게임에서 크기가 4이상인 사이클의 존재 여부를 구하는 문제  
* 우리는 DFS 알고리즘을 이용할 것이다.   
* 크기가 4이상의 사이클이 존재하려면 4번은 이동해야 한다.  
* 그렇기에 존재 여부를 확인하는 것이기 때문에, 최소 4칸 이동할 수 있는지 검사하면 된다.   

```c++
// x y 는 현재 위치  
// cnt 는 연속된 카운트의 수  
// color는 내 색깔  
bool go (int x, int y, int cnt, char color){
	if(cnt == 4) return true;
	for(int k=0; k < 4 ; k++){
		int nx = x+dx[k], ny = y+dy[k]; // 상하 좌우   
		if(0 <= nx && nx < n && 0 <= ny && ny < m){ // 0보다 크고 끝보다 작으면 -> 다음 이동
			if(check[nx][ny] == false && a[nx][ny] == color){
				if(go(nx, ny, cnt+1, color)){ 
					return true;
				}
			}
		}
	}
	false; // 갈곳이 없다는 뜻으로 false 됨
}
```
그런데 이 코드는 4칸이상 이동하는 **사이클**을 찾는 것이 아닌      
단순히 사이클이 있는지 없는지 true/false 만 나타내주는 코드이다.      
그래서 아래와 같이 코드를 수정해보았다.  

* 각 칸을 방문할때, 시작점으로부터 거리를 기록해서 4이상이면 사이클을 찾았다고 할 수 있다.  
```
4/0      1
()-------()
|         |
()-------()
3         2
```
단 조심해야 할 점은 갔다가 원래 자리로 돌아오는 것도 카운터에 포함되니 이러한 것은 예외 처리를 해준다.   

```c++

// x y 는 현재 위치  
// cnt 는 연속된 카운트의 수  
// color는 내 색깔  
bool go (int x, int y, int cnt, char color){
	// 이미 방문한적 있으면 4이상의 차이가 있는지 확인해본다.  
	if(check[x][y]) return (cnt - dist[x][y]) >= 4; 
	// () ==> () 갔다가 () <== () 가는 형태가 cnt가 2가된다. 이를 방지해야하기 위해 작성했다.   
	
	// 0/4    1
	// () ==> ()     
	// ||	  ||
	// () <== () 
	// 3       2

	// dist[][]는 당시 cnt 값을 가진다.
	// 이렇게 가야 처음 dist[x][y] = 0 이었고 돌아왔을때 cnt가 4가 되므로
	// 4-0은 4가 되는 것이다.  
	// 위 같은 모형은 최소 크기의 사이클을 돌았다는 뜻이다.   
	
  
	// 0     5/1     2       
	// () ==> () ==> ()     
	//        ||	   ||
	//        () <== () 
	//        4       3
  	// 5-1 >= 4
  
  	// 6/0     1     2       
	// () ==> () ==> ()     
	// ||     ||	   ||
	// () <== () <== () 
	// 5      4       3
 	 // 6-0 >= 6
  
  
	check[x][y] = true; // 도착했으니 true 표시 -> xy에 방문한거고  
	dist[x][y] = cnt; // 시작점으로부터의 거리 -> 지금까지 이동한 칸의 갯수
	// 단 몇번만에 갔냐 이걸 말하는거지 최소 이동은 아니다.  
	// 왜냐하면 방향성은 dx dy의 배치에 따라 다르기에 
	// 그냥 주어진 환경에서 몇번만에 왔냐를 의미한다.  

	// 어떤 기준으로 x,y에 위치했을때의 거리 차이를 의미한다.  

	for(int k=0; k < 4 ; k++){
		int nx = x+dx[k], ny = y+dy[k]; // 상하 좌우   
		if(0 <= nx && nx < n && 0 <= ny && ny < m){ // 0보다 크고 끝보다 작으면 -> 다음 이동
			if(a[nx][ny] == color){
				if(go(nx, ny, cnt+1, color)){ 
					return true;
				}
			}
		}
	}
	false; // 갈곳이 없다는 뜻으로 false 됨
}
```
**전체 코드**
```c++
#include <iostream>
#include <cstring>
using namespace std;

char a[55][55];
bool check[55][55];
int dist[55][55];
int n, m;
int dx[] = {0,0,1,-1};
int dy[] = {1,-1,0,0};

bool go(int x, int y, int cnt, char color) {
    if (check[x][y]) { // 처음에는 상관 없지만 재귀해서 다시 들어왔을때 
        if (cnt-dist[x][y] >= 4) { // 거리를 빼줬는데 4이상이다? 
            return true; // true 리턴 
        } else {
            return false; // 아니면 false 리턴  
        }
    }
	/// 위 구역은 재귀를 끝나는 구역이다. /// 

    check[x][y] = true; // 처음 들어왔으면 true로 변화     
    dist[x][y] = cnt; // 기준점으로부터 카운트 값 넣어준다.       
    for (int k=0; k<4; k++) { // 4방향 검증을 위한 for 문  
        int nx = x+dx[k]; // 다음 x 
        int ny = y+dy[k]; // 다음 y 
        if (0 <= nx && nx < n && 0 <= ny && ny < m) { // 범위내에 존재한다면  
            if (a[nx][ny] == color) { // 색깔이 같다면 
                if (go(nx, ny, cnt+1, color)) { // 일단 묻지도 말고 따지지도 말고 go -> false/true 리턴될 것이다.   
                    return true; // true 리턴 되었었으면 true 리턴
                }
            }
        }
    }
    return false; // 리턴된 것이 없다면 false 리턴 
}
int main() {
    cin >> n >> m; // 세로 가로 입력받음  
    for (int i=0; i<n; i++) { 
        cin >> a[i]; // 한번에 한줄 씩 입력받기   
    }   
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (check[i][j]) continue; // 체크되어 있다면 넘겨라 
			// 모든 x y 하나하나 다 확인할 생각인가보다   
            memset(dist,0,sizeof(dist)); // 1개씩 할 때마다 거리는 0으로 초기화 
            bool ok = go(i, j, 1, a[i][j]); // 여기서 부터 시작할 때 사이클이 있는지 묻는것   
            if (ok) { // 있으면 
                cout << "Yes" << '\n'; // YES 출력 
                return 0; // 하나라도 있으면 되니까 종료  
            }
        }
    }
    cout << "No" << '\n'; // 하나도 없다는 뜻이니 No 틀고 종료해준다
    return 0;
}
```
____    
* 이전 칸과 다른 칸으로 연속해서 이동했을때, 이미 방문한 칸을 방문했으면 사이클이 존재한다고 볼 수 있다.       
* 이 말은 어렵게 표현했는데 그리드 사각 구조에서 자기가 방금 지나온곳을 가지 않는다는 가정을 하면     
* 다시 내가 왔던곳에 가는 것은 최소 4 사이클이 완성된다는 그리드의 특징을 이용한 것이다.      
* (다시 뒤로 못가니 나머지 3방향으로 가니)       
   
```c++
// x y 는 현재 위치  
// cnt 는 연속된 카운트의 수  
// color는 내 색깔  
bool go (int x, int y, int px, int py, char color){ // 과거 좌표
	if(check[x][y]) return true;
	check[x][y] = true; // 도착했으니 true 표시 -> xy에 방문한거고  
	
	for(int k=0; k < 4 ; k++){
		int nx = x+dx[k], ny = y+dy[k]; // 상하 좌우   
		if(0 <= nx && nx < n && 0 <= ny && ny < m){ // 0보다 크고 끝보다 작으면 -> 다음 이동
			if(!(nx==px && ny == py) && a[nx][ny] == color){ // 과거 좌표가 아닐경우
				if(go(nx, ny, x, y, color)){ 
					return true;
				}
			}
		}
	}
	false; // 갈곳이 없다는 뜻으로 false 됨
}
```
**전체 코드**        
```c++
#include <iostream>
using namespace std;
char a[55][55];
bool check[55][55];
int n, m;
int dx[] = {0,0,1,-1};
int dy[] = {1,-1,0,0};

bool go(int x, int y, int px, int py, char color) { // 현재 x y 부모 x y 컬러   
    if (check[x][y]) { // 방금 왔던 길로는 안가므로 그리드 구조에서는 다시 온것은 사이클을 한번 돌은 것이다.   
        return true; // 그래서 리턴 트루     
    }      
    check[x][y] = true; // 처음왔으면 true로 변경 
    for (int k=0; k<4; k++) { // 4방향 이동 반복문   
        int nx = x+dx[k];
        int ny = y+dy[k];
        if (0 <= nx && nx < n && 0 <= ny && ny < m) { // 범위내에 있으면 
            if (!(nx == px && ny == py)) { // 그리고 방금 왔던 길이 아니면  
                if (a[nx][ny] == color) { // 그리고 컬러가 같으면  
                    if (go(nx, ny, x, y, color)) { // 재귀 호출해라 그리고 한바퀴 돌았다면 true 반환
                        return true; // 돌았으니 true 반환 
                    }
                }
            }
        }
    }
    return false; // 한바퀴 돌지 않았던가 없으면 false 리턴 
}
int main() {
    cin >> n >> m;
    for (int i=0; i<n; i++) {
        cin >> a[i]; // 문자열 한줄씩 입력 
    }
    for (int i=0; i<n; i++) {     
        for (int j=0; j<m; j++) {   
            if (check[i][j]) continue; // 체크했었다면 넘겨라  
            bool ok = go(i, j, -1, -1, a[i][j]); // 시작이니 처음만 일단 -1 해주지 막상 들어가면 i j 가 다음 재귀시 패런트가 된다.
            if (ok) { // true 있었다면 
                cout << "Yes" << '\n'; // YES 출력하고 종료 
                return 0;
            }
        }
    }
    cout << "No" << '\n'; // 없었다면 No 출력하고 종료
    return 0;
}
```
***
# 2. 서울 지하철 2호선    
* 지하철 2호선은 순호나선 1개와 2개의 지선으로 이루어져 있다.  
* N개의 정점과 N개의 간선으로 이루어져 있는 그래프로 나타낼 수 있다.  
* 모든 정점이 순환선과 얼마나 떨어져 있는지 구하는 문제 <- 무슨 말이지  
이를 해결하기 위해서는 총 2단계로 나누어져 있는데,   
1. 순환선을 찾아야 한다.  
2. 순환선에서 부터 떨어져 있는 거리를 찾아야 한다. 
___
순환선은 **사이클**을 의미한다.    
* N개의 정점과 N개의 간선으로 이루어져 있으면 사이클은 1개밖에 없다는 뜻이다.  
* 사이클을 도는 동안 스택에 경로를 넣고 pop 해주면서 되돌아가는 방식 (스택이 빌때까지)    

```c++
()->()->()
|	 |
()->()->()
```

* 그러나 항상 이런건 아니고 시작이 사이클이었던 곳이 아닐 경우 사이클이 아닌 공간도 pop하게 된다. 

```c++
()->()->()
|	 |
()->()->()
    |
    ()   <- 여기부터 시작했다면 마지막 stack에 저장된 여기도 빼주게 된다...
```
* 그러니 사이클에 포함된 정점에서 시작했을 경우는 stack을 다 비워도 상관이 없지만 
* 반대로 사이클이 아닌곳은 stack을 다 비우면 안된다.  
* 간략한 방법으로 사이클에 속한 정점인 곳을 찾아서 문제를 풀면 쉬워지기에 정점에 속한 사이클을 찾자.      
___
```c++
()->()->()
|	 |
()->()->()
    |
    ()   <- 여기부터 시작했다하더라도 방문했던 곳을 방문하면 
사이클의 정점이라 볼 수 있고 사이클의 시작이라 볼 수있다.
```
* 시작점을 발견하면 해당 시작점의 값을 리턴한다.
* 스택 마지막 값과 리턴하는 시작점 값을 비교해서 다르면 pop
* 그러다 보면 2번째까지 pop을 진행하고 시작점은 다시 자기 자신과 마주치게되고
* 시작점 == 스택에서 나온값이 같을 경우 멈춰준다.
* 그리고 스택에 담긴 그 이후의 값들은 사이클내에 존재하지 않는 값이라는 것을 알 수 있다.  

```c++
// p는 과거
// x는 현재 위치 
int go (int x, int p){
	// -2: 사이클을 찾음, 포함되지 않음
	// -1: 사이클을 못찾음, 
	// 0~n-1: 사이클을 찾음, 시작 인덱스  

	if(check[x] == 1) return x; // 방문 했다면 -> 현재 정점번호 리턴 
	check[x] = 1; // 방문하지 않았다면 방문했다는 표시
	
	for(int y : a[x]){ // 현재 위치와 연결된 다음 위치들 (인접리스트 이용) 
		if(y == p) continue; // 과거 이동 구역일 경우 다시 
		int res = go(y,x); // 다음으로 이동하고 반환된 값 
		if(res == -2) return -2; // 사이클을 찾았는데 포함되지 않는다는 의미 

		   ////////////// 이후 부터는 찾았다는 얘기이다.///////////////////
		/// 그래서 여기서 -2 리턴 하는것이 위에 res == -2 와 연관이 있고 ///
		/// 그리고 사이클을 찾았는데 포함되지 않는것을 찾았으니 밑은 포함된거다. ///

		if(res >= 0){ // 찾았다면 
			check[x] = 2; // 사이클을 찾았고 사이클의 일부인것  
			if(x == res) return -2; // 현재 정점이 사이클과 시작점이 같으면 지금부터 리턴되는 정점은 사이클에 포함되지 않는 정점이다.
			else return res; // 아직 사이클을 찾지 못한것이다.  
		}
	}
	return -1;
}
```   
![이해 안되던거](https://user-images.githubusercontent.com/50267433/84262607-d8bda380-ab58-11ea-8328-2f6845ccc181.jpg)      
      
* dist[i] = 시작점으로부터 i 까지의 **거리**를 담아두는 것                 
* bfs에서 u에서 v를 방문하면은 v까지의 거리는 u까지의 거리에 +1 한 것이다.            

