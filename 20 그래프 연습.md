그래프 연습
=======================
# 1. Two Dots

* Two Dots 게임에서 크기가 4이상인 사이클의 존재 여부를 구하는 문제  
* 우리는 DFS 알고리즘을 이용할 것이다.   
* 크기가 4이상의 사이클이 존재하려면 4번은 이동해야 한다.  
* 그렇기에 존재 여부를 확인하는 것이기 때문에, 최소 4칸 이동할 수 있는지 검사하면 된다.   

```c++
// x y 는 현재 위치  
// cnt 는 연속된 카운트의 수  
// color는 내 색깔  
bool go (int x, int y, int cnt, char color){
	if(cnt == 4) return true;
	for(int k=0; k < 4 ; k++){
		int nx = x+dx[k], ny = y+dy[k]; // 상하 좌우   
		if(0 <= nx && nx < n && 0 <= ny && ny < m){ // 0보다 크고 끝보다 작으면 -> 다음 이동
			if(check[nx][ny] == false && a[nx][ny] == color){
				if(go(nx, ny, cnt+1, color)){ 
					return true;
				}
			}
		}
	}
	false; // 갈곳이 없다는 뜻으로 false 됨
}
```
그런데 이 코드는 4칸이상 이동하는 **사이클**을 찾는 것이 아닌      
단순히 사이클이 있는지 없는지 true/false 만 나타내주는 코드이다.      
그래서 아래와 같이 코드를 수정해보았다.  

* 각 칸을 방문할때, 시작점으로부터 거리를 기록해서 4이상이면 사이클을 찾았다고 할 수 있다.  
```
4/0      1
()-------()
|         |
()-------()
3         2
```
단 조심해야 할 점은 갔다가 원래 자리로 돌아오는 것도 카운터에 포함되니 이러한 것은 예외 처리를 해준다.   

```c++

// x y 는 현재 위치  
// cnt 는 연속된 카운트의 수  
// color는 내 색깔  
bool go (int x, int y, int cnt, char color){
	// 이미 방문한적 있으면 4이상의 차이가 있는지 확인해본다.  
	if(check[x][y]) return (cnt - dist[x][y]) >= 4; 
	// () ==> () 갔다가 () <== () 가는 형태가 cnt가 2가된다. 이를 방지해야하기 위해 작성했다.   
	
	// 0/4    1
	// () ==> ()     
	// ||	  ||
	// () <== () 
	// 3       2

	// dist[][]는 당시 cnt 값을 가진다.
	// 이렇게 가야 처음 dist[x][y] = 0 이었고 돌아왔을때 cnt가 4가 되므로
	// 4-0은 4가 되는 것이다.  
	// 위 같은 모형은 최소 크기의 사이클을 돌았다는 뜻이다.   
	
  
	// 0     5/1     2       
	// () ==> () ==> ()     
	//        ||	   ||
	//        () <== () 
	//        4       3
  	// 5-1 >= 4
  
  	// 6/0     1     2       
	// () ==> () ==> ()     
	// ||     ||	   ||
	// () <== () <== () 
	// 5      4       3
 	 // 6-0 >= 6
  
  
	check[x][y] = true; // 도착했으니 true 표시 -> xy에 방문한거고  
	dist[x][y] = cnt; // 시작점으로부터의 거리 -> 지금까지 이동한 칸의 갯수
	// 단 몇번만에 갔냐 이걸 말하는거지 최소 이동은 아니다.  
	// 왜냐하면 방향성은 dx dy의 배치에 따라 다르기에 
	// 그냥 주어진 환경에서 몇번만에 왔냐를 의미한다.  

	// 어떤 기준으로 x,y에 위치했을때의 거리 차이를 의미한다.  

	for(int k=0; k < 4 ; k++){
		int nx = x+dx[k], ny = y+dy[k]; // 상하 좌우   
		if(0 <= nx && nx < n && 0 <= ny && ny < m){ // 0보다 크고 끝보다 작으면 -> 다음 이동
			if(a[nx][ny] == color){
				if(go(nx, ny, cnt+1, color)){ 
					return true;
				}
			}
		}
	}
	false; // 갈곳이 없다는 뜻으로 false 됨
}
```
    
* 이전 칸과 다른 칸으로 연속해서 이동했을때, 이미 방문한 칸을 방문했으면 사이클이 존재한다고 볼 수 있다.       
* 이 말은 어렵게 표현했는데 그리드 사각 구조에서 자기가 방금 지나온곳을 가지 않는다는 가정을 하면     
* 다시 내가 왔던곳에 가는 것은 최소 4 사이클이 완성된다는 그리드의 특징을 이용한 것이다.      
* (다시 뒤로 못가니 나머지 3방향으로 가니)       
   
```c++
// x y 는 현재 위치  
// cnt 는 연속된 카운트의 수  
// color는 내 색깔  
bool go (int x, int y, int px, int py, char color){ // 과거 좌표
	if(check[x][y]) return true;
	check[x][y] = true; // 도착했으니 true 표시 -> xy에 방문한거고  
	
	for(int k=0; k < 4 ; k++){
		int nx = x+dx[k], ny = y+dy[k]; // 상하 좌우   
		if(0 <= nx && nx < n && 0 <= ny && ny < m){ // 0보다 크고 끝보다 작으면 -> 다음 이동
			if(!(nx==px && ny == py) && a[nx][ny] == color){ // 과거 좌표가 아닐경우
				if(go(nx, ny, x, y, color)){ 
					return true;
				}
			}
		}
	}
	false; // 갈곳이 없다는 뜻으로 false 됨
}
```
    
***
# 2. 서울 지하철 2호선    
* 지하철 2호선은 순호나선 1개와 2개의 지선으로 이루어져 있다.  
* N개의 정점과 N개의 간선으로 이루어져 있는 그래프로 나타낼 수 있다.  
* 모든 정점이 순환선과 얼마나 떨어져 있는지 구하는 문제 <- 무슨 말이지  
이를 해결하기 위해서는 총 2단계로 나누어져 있는데,   
1. 순환선을 찾아야 한다.  
2. 순환선에서 부터 떨어져 있는 거리를 찾아야 한다. 
___
순환선은 **사이클**을 의미한다.    
* N개의 정점과 N개의 간선으로 이루어져 있으면 사이클은 1개밖에 없다는 뜻이다.  
* 사이클을 도는 동안 스택에 경로를 넣고 pop 해주면서 되돌아가는 방식 (스택이 빌때까지)    

```c++
()->()->()
|	 |
()->()->()
```

* 그러나 항상 이런건 아니고 시작이 사이클이었던 곳이 아닐 경우 사이클이 아닌 공간도 pop하게 된다. 

```c++
()->()->()
|	 |
()->()->()
    |
    ()   <- 여기부터 시작했다면 마지막 stack에 저장된 여기도 빼주게 된다...
```
* 그러니 사이클에 포함된 정점에서 시작했을 경우는 stack을 다 비워도 상관이 없지만 
* 반대로 사이클이 아닌곳은 stack을 다 비우면 안된다.  
* 간략한 방법으로 사이클에 속한 정점인 곳을 찾아서 문제를 풀면 쉬워지기에 정점에 속한 사이클을 찾자.      
___
```c++
()->()->()
|	 |
()->()->()
    |
    ()   <- 여기부터 시작했다하더라도 방문했던 곳을 방문하면 
사이클의 정점이라 볼 수 있고 사이클의 시작이라 볼 수있다.
```
* 시작점을 발견하면 해당 시작점의 값을 리턴한다.
* 스택 마지막 값과 리턴하는 시작점 값을 비교해서 다르면 pop
* 그러다 보면 2번째까지 pop을 진행하고 시작점은 다시 자기 자신과 마주치게되고
* 시작점 == 스택에서 나온값이 같을 경우 멈춰준다.
* 그리고 스택에 담긴 그 이후의 값들은 사이클내에 존재하지 않는 값이라는 것을 알 수 있다.  

```c++
// p는 과거
// x는 현재 위치 
int go (int x, int p){
	// -2: 사이클을 찾음, 포함되지 않음
	// -1: 사이클을 못찾음, 
	// 0~n-1: 사이클을 찾음, 시작 인덱스  

	if(check[x] == 1) return x; // 방문 했다면 -> 현재 정점번호 리턴 
	check[x] = 1; // 방문하지 않았다면 방문했다는 표시
	
	for(int y : a[x]){ // 현재 위치와 연결된 다음 위치들 (인접리스트 이용) 
		if(y == p) continue; // 과거 이동 구역일 경우 다시 
		int res = go(y,x); // 다음으로 이동하고 반환된 값 
		if(res == -2) return -2; // 사이클을 찾았는데 포함되지 않는다는 의미 

		   ////////////// 이후 부터는 찾았다는 얘기이다.///////////////////
		/// 그래서 여기서 -2 리턴 하는것이 위에 res == -2 와 연관이 있고 ///
		/// 그리고 사이클을 찾았는데 포함되지 않는것을 찾았으니 밑은 포함된거다. ///

		if(res >= 0){ // 찾았다면 
			check[x] = 2; // 사이클을 찾았고 사이클의 일부인것  
			if(x == res) return -2; // 현재 정점이 사이클과 시작점이 같으면 지금부터 리턴되는 정점은 사이클에 포함되지 않는 정점이다.
			else return res; // 아직 사이클을 찾지 못한것이다.  
		}
	}
	return -1;
}
```   
![이해 안되던거](https://user-images.githubusercontent.com/50267433/84262607-d8bda380-ab58-11ea-8328-2f6845ccc181.jpg)      
      
* dist[i] = 시작점으로부터 i 까지의 **거리**를 담아두는 것                 
* bfs에서 u에서 v를 방문하면은 v까지의 거리는 u까지의 거리에 +1 한 것이다.            

