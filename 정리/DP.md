# DP
* 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
* 주로 패턴이 있으며 한단계 한단계 진행되서 올라온다고 보면 된다.   
* 다이나믹 프로그래밍이 수행되려면 2가지 속성이 만족해야 된다.
  * Overlapping Subproblem : 겹치는 부분(작은)문제 -> 큰 문제와 작은 문제의 풀이가 같다.   
  * Optimal Substructure : 최적부분구조 -> 작은 문제의 조합으로 큰 문제를 풀 수 있다.  
* **문제에서 출력하기 원하는 값은 dp 의 값이다.**        

## 다이나믹 프로그래밍의 특징 
* 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
* Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.
* 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.
* 이렇게 저장함으로써 중복된 계산을 진행하지 않고 빠르게 값만 활용할 수 있도록 한다.
* 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.
* 메모를 한다고 해서 영어로 Memorization이라고 한다.

## 기본적인 DP 문제들    
* **2 X N 타일 :** https://www.acmicpc.net/problem/11726
	* 정답 : https://www.acmicpc.net/source/23220812
	* 아주 베이직한 점화식 문제
	* 2x1, 1x2 이므로 한칸전 모든 경우의수 + 두칸전 모든 경우의수 = 답 
	* 여기서 얻어갈 점은 **도식화하여 생각하는 기초를 얻을 수 있다.**   
* **2 X N 타일 :** https://www.acmicpc.net/problem/11727
	* 정답 : https://www.acmicpc.net/source/23220863
	* 2 X N 타일의 변형문제 
	* 마찬가지로 **도식화하여 생각하는 기초를 얻을 수 있다.**
	* 중복개념이 발생할 경우가 있으므로 연산을 추가하는 방식을 사용한다.    
* **123 더하기 :** https://www.acmicpc.net/problem/9095
	* 정답 : https://www.acmicpc.net/source/23220496
	* 내가 가장 부족한 **점화식 세우는것에 있어 가장 기초적인 문제**   
	* 우선 정답은 `d[n] = d[n-1] + d[n-2] + d[n-3]` 이다. 
	* 풀이 방법은 이전 방법들에서 1씩 더하거나, 2씩 더하거나, 3씩 더하는 방법이다.   
	* 점화식을 세우는 것이 가장 중요하다.
		* 필자같은 경우는 **이전에서 값을 앞 뒤로 더해주면서 문제를 풀었다.**    
		* 예를 들면 `12, 21 -> 112, 121, 121, 211`
		* 하지만 중복 발생이랑 모든 경우의 수를 일일이 계산해야하니 효율성이 매우 떨어지며 결과적으로 점화식을 세우지 못한다.    
		* 해당 문제는 -x 값만큼 증가하는 식이다. 즉, -1 이면 이전에서 +1이 되었다 볼 수 있다.   
		* 4를 구하는 문제에서는 3까지 올 수 있는 모든 경우에 1을 더한것이 `d[4-1]`
		* 4를 구하는 문제에서는 3까지 올 수 있는 모든 경우에 2을 더한것이 `d[4-2]`
		* 4를 구하는 문제에서는 3까지 올 수 있는 모든 경우에 3을 더한것이 `d[4-3]` 식으로 문제를 푼것이다. 
	* 후에 다시 기술하겠지만 유사한 문제 - 고층빌딩 : https://www.acmicpc.net/problem/1328	
* **카드 구매하기 :** https://www.acmicpc.net/problem/11502
	* 정답 : https://www.acmicpc.net/source/23221928
	* dp 를 이용해서 최대값을 찾는 것이다.   
	* 123의 변형 형태라 볼 수 있으며 점화식을 세우면 간단하게 값을 얻을 수 있습니다.  
	* `d[n] = d[n-x] + arr[x]` 형태로 123과 달리 단지 이전 단계만 정해져 있지 않았을 뿐입니다. 
	* 그렇기에 모든 단계를 계산하기 위해 `for` 구문을 이용해서 순회하면서 최대값을 찾는것입니다.  
	* **이렇게 이전 단계가 정해져 있지 않으면 주로 for 구문하고 if 구문을 사용하여 해당하는 작은 부분을 큰 부분에 추가시킵니다.**          
* **카드 구매하기2 :** https://www.acmicpc.net/problem/16194
	* 정답 : https://www.acmicpc.net/source/19355309
	* dp 를 이용해서 최소값을 찾는 것이다.   
	* 기존 카드 구매하기와 개념적으로 반대로 풀면 된다.   
	* 단 기존에 존재하는 값이 0이 아닌 최대값으로 넣어 작은값으로 계산해야 한다.    
* **123 더하기 5 :** https://www.acmicpc.net/problem/15990
	* 정답 : https://www.acmicpc.net/submit/15990/23224806
	* 기존 123 문제의 변형으로 같은 수를 중복으로 사용하면 안되는 문제입니다.    
		* 예를 들면 1+1 은 안됩니다. , 2+2도 안됩니다. 단, 1+2+1은 가능합니다.    
	* 이전 값을 사용하지 못한다는 전제가 있기 때문에 이전값을 기억해야합니다.
	* **차원 높이기의 대표적인 문제입니다. -> 비슷한 문제로 와인/쉬운 계단이 있습니다.**	  
	* 이전 값을 가진 차원을 생성하여 해당 값이 아닌 것들끼리만 더해줍니다.   
	* 개인적으로 해당 문제를 std를 이용해서 풀었는데 속도줄이는 문구를 안써주면 96ms 이나 차이가 난다. -> 꼭 쓸것  
* **쉬운 계단 수 :** https://www.acmicpc.net/problem/10844
	* 정답 : https://www.acmicpc.net/source/19453145
	* **차원 높이기의 두번째 대표적인 문제입니다.
	* `[길이][마지막 계단]` 형식의 문제로 `마지막 계단-1 >= 0` 이면 현재가 1 이상이므로 올라온 경우를 더해주고,
	* `마지막 계단+1 <= 9` 이면 현재가 8 이하이므로 내려온 경우를 더해줄 수 있다.     
* **오르막 수 :** https://www.acmicpc.net/problem/11057
	* 정답 : https://www.acmicpc.net/source/19504443
	* `[길이][현재]` 행태로 되어있기 때문에 `이하 값`들을 모두 더해주는 방식으로 진행하면 됩니다.    
	
