# DP
* 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
* 주로 패턴이 있으며 한단계 한단계 진행되서 올라온다고 보면 된다.   
* 다이나믹 프로그래밍이 수행되려면 2가지 속성이 만족해야 된다.
  * Overlapping Subproblem : 겹치는 부분(작은)문제 -> 큰 문제와 작은 문제의 풀이가 같다.   
  * Optimal Substructure : 최적부분구조 -> 작은 문제의 조합으로 큰 문제를 풀 수 있다.  
* **문제에서 출력하기 원하는 값은 dp 의 값이다.**        

## 다이나믹 프로그래밍의 특징 
* 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
* Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.
* 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.
* 이렇게 저장함으로써 중복된 계산을 진행하지 않고 빠르게 값만 활용할 수 있도록 한다.
* 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.
* 메모를 한다고 해서 영어로 Memorization이라고 한다.

## 기본적인 DP 문제들    
* **2 X N 타일 :** https://www.acmicpc.net/problem/11726
	* 정답 : https://www.acmicpc.net/source/23220812
	* 아주 베이직한 점화식 문제
	* 2x1, 1x2 이므로 한칸전 모든 경우의수 + 두칸전 모든 경우의수 = 답 
	* 여기서 얻어갈 점은 **도식화하여 생각하는 기초를 얻을 수 있다.**   
* **2 X N 타일 :** https://www.acmicpc.net/problem/11727
	* 정답 : https://www.acmicpc.net/source/23220863
	* 2 X N 타일의 변형문제 
	* 마찬가지로 **도식화하여 생각하는 기초를 얻을 수 있다.**
	* 중복개념이 발생할 경우가 있으므로 연산을 추가하는 방식을 사용한다.    
* **123 더하기 :** https://www.acmicpc.net/problem/9095
	* 정답 : https://www.acmicpc.net/source/23220496
	* 내가 가장 부족한 **점화식 세우는것에 있어 가장 기초적인 문제**   
	* 우선 정답은 `d[n] = d[n-1] + d[n-2] + d[n-3]` 이다. 
	* 풀이 방법은 이전 방법들에서 1씩 더하거나, 2씩 더하거나, 3씩 더하는 방법이다.   
	* 점화식을 세우는 것이 가장 중요하다.
		* 필자같은 경우는 **이전에서 값을 앞 뒤로 더해주면서 문제를 풀었다.**    
		* 예를 들면 `12, 21 -> 112, 121, 121, 211`
		* 하지만 중복 발생이랑 모든 경우의 수를 일일이 계산해야하니 효율성이 매우 떨어지며 결과적으로 점화식을 세우지 못한다.    
		* 해당 문제는 -x 값만큼 증가하는 식이다. 즉, -1 이면 이전에서 +1이 되었다 볼 수 있다.   
		* 4를 구하는 문제에서는 3까지 올 수 있는 모든 경우에 1을 더한것이 `d[4-1]`
		* 4를 구하는 문제에서는 3까지 올 수 있는 모든 경우에 2을 더한것이 `d[4-2]`
		* 4를 구하는 문제에서는 3까지 올 수 있는 모든 경우에 3을 더한것이 `d[4-3]` 식으로 문제를 푼것이다. 
	* 후에 다시 기술하겠지만 유사한 문제 - 고층빌딩 : https://www.acmicpc.net/problem/1328	
* **카드 구매하기 :** https://www.acmicpc.net/problem/11502
	* 정답 : https://www.acmicpc.net/source/23221928
	* dp 를 이용해서 최대값을 찾는 것이다.   
	* 123의 변형 형태라 볼 수 있으며 점화식을 세우면 간단하게 값을 얻을 수 있습니다.  
	* `d[n] = d[n-x] + arr[x]` 형태로 123과 달리 단지 이전 단계만 정해져 있지 않았을 뿐입니다. 
	* 그렇기에 모든 단계를 계산하기 위해 `for` 구문을 이용해서 순회하면서 최대값을 찾는것입니다.  
	* **이렇게 이전 단계가 정해져 있지 않으면 주로 for 구문하고 if 구문을 사용하여 해당하는 작은 부분을 큰 부분에 추가시킵니다.**          
* **카드 구매하기2 :** https://www.acmicpc.net/problem/16194
	* 정답 : https://www.acmicpc.net/source/19355309
	* dp 를 이용해서 최소값을 찾는 것이다.   
	* 기존 카드 구매하기와 개념적으로 반대로 풀면 된다.   
	* 단 기존에 존재하는 값이 0이 아닌 최대값으로 넣어 작은값으로 계산해야 한다.    
* **123 더하기 5 :** https://www.acmicpc.net/problem/15990
	* 정답 : https://www.acmicpc.net/submit/15990/23224806
	* 기존 123 문제의 변형으로 같은 수를 중복으로 사용하면 안되는 문제입니다.    
		* 예를 들면 1+1 은 안됩니다. , 2+2도 안됩니다. 단, 1+2+1은 가능합니다.    
	* 이전 값을 사용하지 못한다는 전제가 있기 때문에 이전값을 기억해야합니다.
	* **차원 높이기의 대표적인 문제입니다. -> 비슷한 문제로 와인/쉬운 계단이 있습니다.**	  
	* 이전 값을 가진 차원을 생성하여 해당 값이 아닌 것들끼리만 더해줍니다.   
	* 개인적으로 해당 문제를 std를 이용해서 풀었는데 속도줄이는 문구를 안써주면 96ms 이나 차이가 난다. -> 꼭 쓸것  
* **쉬운 계단 수 :** https://www.acmicpc.net/problem/10844
	* 정답 : https://www.acmicpc.net/source/19453145
	* **차원 높이기의 두번째 대표적인 문제입니다.
	* `[길이][마지막 계단]` 형식의 문제로 `마지막 계단-1 >= 0` 이면 현재가 1 이상이므로 올라온 경우를 더해주고,
	* `마지막 계단+1 <= 9` 이면 현재가 8 이하이므로 내려온 경우를 더해줄 수 있다.     
* **오르막 수 :** https://www.acmicpc.net/problem/11057
	* 정답 : https://www.acmicpc.net/source/19504443
	* `[길이][현재]` 행태로 되어있기 때문에 `이하 값`들을 모두 더해주는 방식으로 진행하면 됩니다.    
* **이친 수 :** https://www.acmicpc.net/problem/2193
	* 정답 : https://www.acmicpc.net/source/19363600
	* 0과 1로만 이루어진 수를 이진수로 하는데 아래와 같은 추가조건이 붙으면 이친수이다.  
		* 이친수는 0으로 시작하지 않는다.   
		* 이친수에서 1은 2번 연속해서 나오지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.   
	* N자리 이친수를 구하는 문제   
	* 기존과 같이 `[i-1][0] + [i-1][1]` 로 구할 수 있다.   
	* 하지만 1은 두번 연속 나오지 않는 다는 성질을 이용해서 1차원으로도 구할 수 있다.  
		* 현재가 0인 경우 앞에가 0이든 1이든 무엇이든 상관없다 `d[i-1]`
		* 현재가 1인 경우 앞에가 0이어야한다. 이말은 반대로 전이 0이기에 전전은 무엇이든 상관없다. `d[i-2]`
* **스티커 :** https://www.acmicpc.net/problem/9465
	* 정답 : https://www.acmicpc.net/source/19505187
	* 2 x n 타일링과 비슷한 문제이며 제한 조건이 추가된 것 뿐이라 생각이 들 수 있지만
	* **현재 '상태'를 dp로 저장하는 방식이다.**   
	* 기존 내가 생각했던 방식은 `[2][n]`으로 차근 차근 풀어나갈 생각이었다.   
	* 편의를 위해서 문제에서 나온 차워을 뒤집어서 설명해보겠다.  
		* `[0][n]` 아무것도 뜯지 않음 -> 뒤에 뜯지 않던, 위에 뜯던, 아래 뜯던 상관없음 
		* `[1][n]` 아래 뜯음 -> 이전에 뜯지 않음 또는 위에 뜯음만 가능 
		* `[2][n]` 위에 뜯음 -> 이전에 뜯지 않음 또는 아래 뜯음만 가능 
	* 결론적으로 말하자면 **문제에 주어진 수치를 가지고서만 dp를 세우는 것이 아니다**  
	* '상태'를 dp로 만들 수도 있으며 후에 '플레이리스트'라는 문제에서도 `[넣은곡][남은곡]` 식으로 dp를 만들기도 한다.   
	* 지금 생각된것인데 **'이전 조건이나 상태'로 인해 현재 계산되는 '방법'이 달라진다면 차원을 늘려서 사용하자**    
* 
  
