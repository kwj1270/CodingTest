건너 뛰며 해보기
=======================  
# 1. 카잉 달력
* M 과 N보다 작거나 같은 두 자연수 x,y를 이용해서 년도를 ```<x:y>``` 로 표시한다.
* 첫 번째 해는 ```<1:1>```, 두 번째 해는 ```<2:2>```이다.  
* ```<x:y>```의 다음 해는 ```<x:y>```이다.  
  * x < M 이면 x = x+1, 아니면 x = 1 
  * y < N 이면 y = y+1, 아니면 y = 1
* M, N, x, y 가 주어졌을 때, ```<x:y>```이 몇 번째 해인지 구하는 문제  
  
즉 쉽게 말해서 M=10 N=12 일 경우 ```<10:10>``` 에서 다음은 ```<1:11>``` 이렇게 되는 것이고    
몇 번째 년도의 값이어야 ```<x:y>```가 나오는지 구하는 것이다     

여기서 중요한 방법이 하나 있는데 
위 처럼 N이나 M을 넘길경우 다시 1로 시작하는 방법이어야 한다.   
하지만 그상태 그대로 나머지를 할 경우 0으로 초기화 되어버린다.   
이를 방지하고자 전체값을 -1 해주고 계산을 한 다음에 후에 다시 1을 더해주는 방식을 사용하면 된다
```
		M = 5 , N = 7이라 가정시
		// 35일경우 둘다 0,0이 된다.  
		// 다시 5,5 라고 가정시에 -> 0,5가 된다.
		// 다시 6,6 라고 가정시에 -> 1,6이 된다.  
		
    // 이렇게 된 0을 다시 1로 만들어주는 작업을 하는 것보다
    // 애초에 작업 자체가 1값이 나올 수 있도록 처리해주는 것이 좋은데
    // 바로 전체값 -1 을 하고 후에 +1을 해주는 것이다.
    
		// 5,5 가정시에 전체값 -1인 4,4로 바꾸면 -> 4,4가 된다.
		// 여기에 다시 1을 더해주면 -> 5,5가 된다.
		// 6,6 가정시에 전체값 -1인 5,5로 바꾸면 -> 0,5가 된다.
		// 여기에 다시 1을 더해주면 -> 1,6이 된다.
		// 이런 동작을 취해주는 것이 좋다.  
```
```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <stack>
#include <queue>
#include <deque>

using namespace std;

int main(void){
	
	int t;
	cin >> t;

	while(t--){
		int m, n, x, y;
		cin >> m >> n >> x >> y;

		// m 과 n 은 단순 기준만 나타내기에 -1을 할 필요가 없다
		x-=1; // 전체값 -1
		y-=1; // 전체값 -1
		bool ok = false;
		for (int k=x; k<(n*m); k+=m) { // 최대공배수가 되면 다시 1,1로 원상 복귀 되니까 
            if (k%n == y) {
                cout << k+1 << '\n'; // 이 의미는 조금더 알아봐야겠다.  
                ok = true;
                break;
            }
        }
        if (!ok) {
            cout << -1 << '\n';
        }
	}

	return 0;
}
```
# 2. 수 이어쓰기  
* 1부터 N까지 수를 이어서 쓰면 새로운 하나의 수를 얻게 된다. (1 <= N <= 100,000,000)  
* 12345678910111213141516171819202122...
* 이때, 새로운 수는 몇 자리 수일까? (길이 구하기)         
    
한가지 패턴을 발견해보자면 **수의 자리수별로 나누어서 문제를 해결할 수 있다.**   
* N = 120 가정시에
* 1-9 는 1개
* 10-99는 2개
* 100-120 은 2자리

다시 
* 1-9 는 1 x (9-1+1) == 9   
* 10-99는 2 x (99-10+1) == 180   
* 100-120 은 3 x (120-100+1) == 63   

이렇게 문제를 풀 수 있는 이유는   
수가 1부터 N까지 빠짐없이 사용된다는 점이다.  

이렇게 생각의 방향을 바꿔보면 문제의 경우의수를 많이 줄일 수 있다.    
1. 나머지 연산    
2. 중복되는 것을 공통되는 것을 그룹화하여 연산의 횟수를 줄이는 법   

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <stack>
#include <queue>
#include <deque>

using namespace std;

int main(void){

	int n;
	cin >> n;
	long long ans = 0;
	for(int start=1, len=1; start <=n ; start*=10, len++){
		int end = start*10-1; // 처음에는 1의 자릿수
							  // 9 , 99 , 999 
		if(end > n) {
			end = n;	      // 999 -> 120
		}
		ans += (long long)(end-start+1) * len; // strat는 10배 증가 len은 1씩 증가이므로
		// 9-1+1 * 1자리
		// 99-10+1 * 2자리
		// 120-100+1 * 3자리 의 값을 더해준다.  
	}
	cout << ans << "\n";

	return 0;
}
```
# 3. N중 for문 
* N개 중에 일부를 선택해야 하는 경우에 많이 사용한다.  
* 재귀 호출이나 비트마스크를 사용하면 더 간결하고 보기 쉬운 코드를 작성할 수 있기 때문에, 사용할 일이 거의 없다.  

# 4. 1,2,3, 더하기  
이전에 DP 방식으로 풀었던 문제이다.  
   
* 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제이다.  
* n = 4 
* 1+1+1+1
* 1+1+2
* 1+2+1
* 2+1+1
* 2+2
* 1+3
* 3+1

```c++
#include <cstdio>
int main() {
    int t;
    scanf("%d",&t);
    while (t--) {
        int ans = 0;
        int n;
        scanf("%d",&n);
        for (int l1=1; l1<=3; l1++) {
            if (l1 == n) {
                ans += 1;
            }
            for (int l2=1; l2<=3; l2++) {
                if (l1+l2 == n) {
                    ans += 1;
                }
                for (int l3=1; l3<=3; l3++) {
                    if (l1+l2+l3 == n) {
                        ans += 1;
                    }
                    for (int l4=1; l4<=3; l4++) {
                        if (l1+l2+l3+l4 == n) {
                            ans += 1;
                        }
                        for (int l5=1; l5<=3; l5++) {
                            if (l1+l2+l3+l4+l5 == n) {
                                ans += 1;
                            }
                            for (int l6=1; l6<=3; l6++) {
                                if (l1+l2+l3+l4+l5+l6 == n) {
                                    ans += 1;
                                }
                                for (int l7=1; l7<=3; l7++) {
                                    if (l1+l2+l3+l4+l5+l6+l7 == n) {
                                        ans += 1;
                                    }
                                    for (int l8=1; l8<=3; l8++) {
                                        if (l1+l2+l3+l4+l5+l6+l7+l8 == n) {
                                            ans += 1;
                                        }
                                        for (int l9=1; l9<=3; l9++) {
                                            if (l1+l2+l3+l4+l5+l6+l7+l8+l9 == n) {
                                                ans += 1;
                                            }
                                            for (int l0=1; l0<=3; l0++) {
                                                if (l1+l2+l3+l4+l5+l6+l7+l8+l9+l0 == n) {
                                                    ans += 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
