자료구조-스택
=======================
# 1. 스택
한쪽 끝에서만 자료를 넣고 뺄 수 있는 구조이다.    
         
자료 넣기 : push   
자료 빼기 : pop    
        
즉, 가장 마지막 데이터만 얻을 수 있으며 제일 마지막 데이터는 top 이라고 부른다.       
   
   
## 1.1. 스택의 구현
배열과 크기를 통해서 나타낼 수 있다. 

```c++
int stack[10000]; // 우선 크기를 크게 지정해서 만듬
int size  = 3; // 현재 스택에 들어간 데이터의 크기 -> 3개 존재
// 인덱스보다 1개 더 큰데 입력 때 바로 사용하려고
```
   
**push and pop**
```c++
void push(int data){
  stack[size] = data; // 앞서 설명했듯이 입력때 바로 넣을 수 있다.  
  size += 1;
}

int pop(){
  int data = stack[size-1];
  stack[size-1] = 0; // 마지막 값 초기화
  size -= 1; // 사이즈 줄이기 
  return data; // 데이터 반환 
}
```
## 1.2. 단어 뒤집기
**LIFO :** last in first out -> 마지막으로 들어간 것이 처음으로 나온다.    

스택의 성질 LIFO를 이용한 코드를 다뤄보자  

**단어 뒤집기**       
* 문장이 주어졌을 때 단어를 모두 뒤집는 문제  
* 단어의 순서를 바꿀 수 없고, 단어는 영어 알파벳으로만 이루어져있다.  
* 단어의 최대 길이 :20, 문장의 최대 길이:1000

* N개의 글자를 스택에 넣었다가 빼면 순서가 역순이된다.
* 알파벳을 스택에 넣고, 공백이나 문자열의 끝이면 스택에서 모두 빼내서 역순을 만든다.  

그래서 어떠한 데이터의 순서를 뒤집을 때는 스택이 가장 괜찮은 방법중 하나이다.   









## 1.2.1. O(N)
```c++
int sum = 0;
for(int i=1; i <= N; i++){
    sum += i;
}
```
## 1.2.2. O(N^2)
```c++
int sum = 0;
for(int i=1; i <= N; i++){
    for(int j=1; j <= N; j++){
        if(i == j){
            sum += i;
        }
    }
}
```
## 1.2.3. O(1)
```c++
int sum = N * (N+1) / 2;
```

## 1.2.4. 시간 예측해보기

* 시간 복잡도 안에 가장 큰 입력 범위를 넣었을 때, 1억이 1초정도이다.  
* 이 값은 대략적인 값으로, 실제로 구현해보면 1억을 조금 넘어도 1초 이내에 수행이 가능하다.  
    
그렇기에 (N <= 10만) 일 경우에는 

1. O(1) => 1 => 1/1억
2. O(N) => 10만 => 10만 / 1억 => 10/10000 초
3. O(N^2) => 100억  => 100억 / 1억 => 100초

## 1.2.5. 빅오표기법 

* Big O Notaion에서 상수는 버린다. ```(3N^2) -> O(N^2)```
* 두가지 항이 있을때, 변수가 같은면 큰 것만 빼고 다 버린다. ```(n^2 + N) -> O(n^2)```
* 두가지 항이 있을때, 변수가 다르면 그냥 놔둔다. ```(n^2 + M) -> O(n^2 + M)``
    
***
# 2. 메모리
* 메모리 제한은 보통 넉넉하기 때문에, 걱정할 필요가 없다.
* 대략적으로 얼마나 공간을 사용할지 예상할 수는 있다.  

## 2.1. 사용한 메모리

* 보통 가장 많은 공간을 사용하는 것은 보통 배열이다.  
* 배열이 사용한 공간: 배열의 크기 X 자료형의 크기 B
* ```int a[1000]```
* ```int a[10000]```
* ```int a[1000][1000]```
* ```int a[10000][10000]``` -> 1억을 의미하고 이는 1초를 의미하기도 한다.  

* 보통 배열의 크기가 크면 시간 초과를 받는 경우가 많다.  
* 불필요한 공간이 없다면, 대부분 메모리 제한은 알아서 지켜진다.  

***
# 3. 입출력
## 3.1. C 입출력
* 입출력은 scanf/printf
## 3.2. C++ 입출력
* 입출력은 scanf/printf , cin/cout을 사용할 수 있다.
* 그러나 cin/cout은 느리기에 입출력이 많으면 scanf/printf 사용 권장한다.

아니면 밑의 세줄을 추가하면 cin/cout 이 더 빨라진다.
```
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
```
단, 이 경우에는 ```scanf/printf , cin/cout```을 섞어 사용못한다.  
즉, ```cin/cout```만 사용 가능하다.
    
참고로 C++의 출력 관점에서       
```cout::ednl;``` 이 있지만 endl 자체가 내포하는 기능이 많기에       
```cout::'\n';```과 비교했을 때 10배 이상 차이가 나므로      
```cout::'\n';``` 사용을 권장한다    

## 3.3. java 입출력
* java 입력은 Scanner, 출력은 System.out 을 이용한다.  
```java
Scanner scanner = new Scanner(Sytem.in);
```
* 입력이 많은 경우에는 속도가 느리기 때문에, BufferedReader를 사용한다.  
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
```
* 출력이 많은 경우에는 StringBuilder를 사용해서 한 문자열로 만들어서 출력을 한 번만 사용하거나 
* BufferedWriter를 이용한다.  

## 3.4. 문제 예시  
a+b를 기준으로 설명   
단순 a+b 만 계산하는 문제도 존재하지만        
테스트 케이스의 수를 입력받는 경우도 있다.     
이럴 경우 외부에 배열 변수를 두어 입력해서 푸는 것보다    
```c++
int t;
int a[100], b[100];
scanf("%d", &t);
for (int i=0; i < t; i++){
    scanf("%d %d" , &a[i] , &b[i]);
}
for (int i=0; i < t; i++){
    printf("%d\n" , a[i]+b[i]);
}
```
외부에 변수를 두어 입력시마다 값을 교체하고 출력하는 방식으로 푸는것이 낫다.      
```c++
int t;
int a,b;
scanf("%d", &t);
while(t--){
    scanf("%d %d", &a,&b);
    printf("%d\n", a+b); 
}
```
이유는 T 개수를 모를때 배열의 크기를 정하기가 어렵고 또한 배열의 크기를 초과할 수 있기 때문이다.  

또한 **EOF**까지 입력을 받아야 되는 문제 같은 경우는    
* C : while(scanf("%d %d", &a,&b)==2)         
scanf의 리턴값은 성공적으로 입력받은 변수의 개수이다.          
* C++ : while(cin >> a >> b)    
* java : while(sc.hasNextInt())   
  
