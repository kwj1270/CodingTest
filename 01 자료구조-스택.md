자료구조-스택
=======================
# 1. 스택
한쪽 끝에서만 자료를 넣고 뺄 수 있는 구조이다.    
         
자료 넣기 : push   
자료 빼기 : pop    
        
즉, 가장 마지막 데이터만 얻을 수 있으며 제일 마지막 데이터는 top 이라고 부른다.       
   
   
## 1.1. 스택의 구현
배열과 크기를 통해서 나타낼 수 있다. 

```c++
int stack[10000]; // 우선 크기를 크게 지정해서 만듬
int size  = 3; // 현재 스택에 들어간 데이터의 크기 -> 3개 존재
// 인덱스보다 1개 더 큰데 입력 때 바로 사용하려고
```
   
**push and pop**
```c++
void push(int data){
  stack[size] = data; // 앞서 설명했듯이 입력때 바로 넣을 수 있다.  
  size += 1;
}

int pop(){
  int data = stack[size-1];
  stack[size-1] = 0; // 마지막 값 초기화
  size -= 1; // 사이즈 줄이기 
  return data; // 데이터 반환 
}
```
## 1.2. 단어 뒤집기
**LIFO :** last in first out -> 마지막으로 들어간 것이 처음으로 나온다.    

스택의 성질 LIFO를 이용한 코드를 다뤄보자  

**단어 뒤집기**       
* 문장이 주어졌을 때 단어를 모두 뒤집는 문제  
* 단어의 순서를 바꿀 수 없고, 단어는 영어 알파벳으로만 이루어져있다.  
* 단어의 최대 길이 :20, 문장의 최대 길이:1000

* N개의 글자를 스택에 넣었다가 빼면 순서가 역순이된다.
* 알파벳을 스택에 넣고, 공백이나 문자열의 끝이면 스택에서 모두 빼내서 역순을 만든다.  

그래서 어떠한 데이터의 순서를 뒤집을 때는 스택이 가장 괜찮은 방법중 하나이다. 

```c++
#include<iostream>
#include<string>
#include<stack>
using namespace std;
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	
	int t;
	cin >> t;
	cin.ignore();

	while(t--){
		string str;
		getline(cin,str);
		str += '\n';
		stack<char> s;
		for (char ch : str) {
			if(ch== ' ' || ch == '\n'){
				while(!s.empty()){
					cout << s.top();
					s.pop();
				}
			} else{
				s.push(ch);
			}
		}
	}
	
	return 0;
}
```

***
# 2. 괄호
* 괄호 문자열이 주어졌을때, 올바른 괄호 문자열인지 아닌지를 알아보는 문제  
* 괄호 문자열: (와)로만 이루어진 문자열 
* 올바른 괄호 문자열: 괄호의 쌍이 올바른 문자열  
     
한가지 특징이 있다면 여는 괄호와 닫는 괄호는 쌍을 이루고        
쌍을 이룬다는 것은 여는 괄호에서 가장 가까운 닫는 괄호야 연결성이 되어있다는 뜻이다.     

1. 닫는 괄호의 이전에 있는 여는 괄호만 후보가 된다.  
2. 다른 여는 괄호와 짝을 이루지 않는 것 
3. 1번과 2번이 모두 해당 되면은 그중에 가장 가까운 여는 괄호가 짝을 이루는 것이다.

그렇기에 스택을 이용한다면 여는괄호만 스택에 넣고  
닫는 괄호가 나왔을시에 여는 괄호를 빼주는 방식으로 코드를 작성하면 된다.  
(짝을 이루면서 빠지므로 가장 가까운 짝이 아닌 여는 괄호를 찾게 된다.)   

```c++
#include<iostream>
#include<string>
using namespace std;

string valid(string s){
	int cnt =0; // 스택의 크기 
	for(int i=0; i < s.size(); i++){
		if(s[i] == '('){
			cnt += 1;
		} else {
			cnt -= 1;
		}
		if(cnt < 0) {
			return "NO";
		}
	}
	if (cnt == 0){
		return "YES";
	} else{
		return "NO";
	} 
}
}
```

* 스택을 사용해서 올바른 괄호 문자열인지 아닌지를 알 수 있다.      
* ```(``` 가 나오면 스택에 ```(```를 넣고     
* ```)```가 나오면 스택에서 하나를 빼서 ```(```인지를 확인한다.     
* 또는 하나를 뺄 수 있는지를 확인한다.
         * 모든 과정이 끝났는데 스택이 비어있지 않다? -> 닫는 괄호가 부족 -> 짝이 맞지 않다.     
         * 닫는 괄호로 인해 스택에서 데이터를 빼려 하지만 스택이 비어있음 -> 여는 괄호 부족 -> 짝이 맞지 않다.
         
         
***
# 3. 스택 수열 

* 1부터 N까지의 수를 스택에 넣었다가 뽑아 놓음으로 하나의 수열을 만들 수 있다.  
* push 하는 순서는 오름차순이다.  
* 임의의 수열 A가 있을때, 스택을 이용해 이 수열을 만들수 있는지 없는지 구하는 문제  
* ```A = [4,3,6,8,7,5,2,1]``` 이라면
* ```++++--++-++-----``` 를 이용해서 만들 수 있다.

* 스택에 push 되는 순서는 오름차순이다.  
* pop 되는 순서대로 수열 A가 만들어지기 때문에, A의 첫 수부터 순서대로 만들어보면 된다. 
* ```m =``` 스택에 추가되어야 하는 수 
* ```A[i] =``` 만들어야 하는 수열 A의 수 
* ```m < A[i]```: ```A[i]```를 pop 해야 하기 때문에, ```m```부터 ```A[i]``` 까지의 모든 수를 순서대로 push 해야한다.  
이후 상태는 ```m == A[i]```인 경우와 같다.  
* ```m > A[i]```인 경우 : 불가능한 경우다. pop을 하면 ```A[i]```가 아닌 다른 수가 A에 추가된다.  
* ```m == A[i]```인 경우 : pop을 해서 ```A[i]```를 만들면 된다.




## 3.1. C 입출력
* 입출력은 scanf/printf
## 3.2. C++ 입출력
* 입출력은 scanf/printf , cin/cout을 사용할 수 있다.
* 그러나 cin/cout은 느리기에 입출력이 많으면 scanf/printf 사용 권장한다.

아니면 밑의 세줄을 추가하면 cin/cout 이 더 빨라진다.
```
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
```
단, 이 경우에는 ```scanf/printf , cin/cout```을 섞어 사용못한다.  
즉, ```cin/cout```만 사용 가능하다.
    
참고로 C++의 출력 관점에서       
```cout::ednl;``` 이 있지만 endl 자체가 내포하는 기능이 많기에       
```cout::'\n';```과 비교했을 때 10배 이상 차이가 나므로      
```cout::'\n';``` 사용을 권장한다    

## 3.3. java 입출력
* java 입력은 Scanner, 출력은 System.out 을 이용한다.  
```java
Scanner scanner = new Scanner(Sytem.in);
```
* 입력이 많은 경우에는 속도가 느리기 때문에, BufferedReader를 사용한다.  
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
```
* 출력이 많은 경우에는 StringBuilder를 사용해서 한 문자열로 만들어서 출력을 한 번만 사용하거나 
* BufferedWriter를 이용한다.  

## 3.4. 문제 예시  
a+b를 기준으로 설명   
단순 a+b 만 계산하는 문제도 존재하지만        
테스트 케이스의 수를 입력받는 경우도 있다.     
이럴 경우 외부에 배열 변수를 두어 입력해서 푸는 것보다    
```c++
int t;
int a[100], b[100];
scanf("%d", &t);
for (int i=0; i < t; i++){
    scanf("%d %d" , &a[i] , &b[i]);
}
for (int i=0; i < t; i++){
    printf("%d\n" , a[i]+b[i]);
}
```
외부에 변수를 두어 입력시마다 값을 교체하고 출력하는 방식으로 푸는것이 낫다.      
```c++
int t;
int a,b;
scanf("%d", &t);
while(t--){
    scanf("%d %d", &a,&b);
    printf("%d\n", a+b); 
}
```
이유는 T 개수를 모를때 배열의 크기를 정하기가 어렵고 또한 배열의 크기를 초과할 수 있기 때문이다.  

또한 **EOF**까지 입력을 받아야 되는 문제 같은 경우는    
* C : while(scanf("%d %d", &a,&b)==2)         
scanf의 리턴값은 성공적으로 입력받은 변수의 개수이다.          
* C++ : while(cin >> a >> b)    
* java : while(sc.hasNextInt())   
  
