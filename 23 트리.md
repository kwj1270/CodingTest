트리
=======================
* 자료구조의 일종    
* 트리는 그래프인데 **사이클이 없는 연결 그래프이다.**     
* 정점의 개수 : V    
* 간선의 개수 : V-1   

BFS 연습 슬라이드에서 서울 지하철2호선 문제를 풀었을때, 정점이 N개고 간선이 N개면 사이클이 1개라고 했다.  
그 이유가 바로 트리라는 사이클이 없는 연결 그래프에서 1개의 간선을 추가 시켜주었기에 사이클이 1개가 된 것이다.  

**하지만**   
* 정점의 개수 : V    
* 간선의 개수 : V-1 
라고 해서 모두가 트리인 것은 아니다.      
(A--B, C--D) 이 같이 정점 2개 간선 1개의 형태도 조건은 맞지만 연결이 되어 있지 않아서 트리는 아니다.     
그렇기에 트리는 사이클이 없는 **연결 그래프**라고 말을 하는 것이다.      
**(반대로 생각하면 정점 : V, 간선 : V-1일 경우에 연결까지 더해지면 트리인 것이다.)**    
   
# 루트 있는 트리    
트리에는 루트를 지정해줄 수 있다.     
* 루트가 있는 트리    
* 대개 1 번이 루트이다.     
* 그러나 이는 우리가 정해준 것이고 4번이 루트라 하면 4번이 루트가 된다.     
* 이렇듯 루트는 **선택적**이며 루트가 있을 수도 있고 없을 수도 있는 것이다.    
* 그리고 루트가 있다면 위에서 말한 것처럼 정하기 나름이다.  
___
루트가 있다면?  
    
* 루트부터 아래로 방향을 정할 수 있다.      
* 1 이 루트라 가정했을 시         
* 1은 2와 3의 부모     
* 2는 4와 5의 부모     
* 3은 6과 7의 부모  
다시 보면 루트가 아닌 노드는 부모가 1개씩있다.         
이를 반대로 생각해서 부모 노드가 없는 노드가 루트이다.      
    
자식이라는 개념도 존재한다.  
단말 노드를 제외하고서는 모두 자식을 1개 이상은 가지고 있다.  
즉, 자식 노드가 없는 노드가 단말 노드이다.   
   
현제라는 개념은  
같은 부모를 가지고 있는 노드를 형재 노드라고 한다.   

깊이라는 개념은    
루트에서부터의 거리를 깊이라고 한다.          
루트의 깊이를 0으로 가정했을 때 0,1,2가 되고         
루트의 깊이를 1로 가정했을 때 1,2,3 이 된다.       
   
높이라는 개념은 깊이의 최대값을 의미한다.
   
조상/자손이라는 개념은     
* p -> q 로 루트를 통과하지 않고 갈 수 있을 때       
* p가 q보다 루트에 가까우면     
* p는 q의 조상        
* q는 p의 자손     

즉 4의 조상은 4와 2와 1,     
3의 조상은 3과 1을 의미한다.           
**조상은 자기 자신을 포함한다.**       
그렇기에 1의 조상은 1인 자기 자신 밖에 없다.     
  
반대로 2의 자손은 4와 5가 있는 것이고 1의 자손은 2, 3, 4, 5, 6, 7, 이 있는 것이다.    
     
***
# 2. 이진트리 
* 자식을 최대 2개만 가지고 있는 트리    
   
## 2.1. 포화 이진트리            
* 단말 노드를 제외한 노드의 자식의 수 : 2            
* 리프 노드의 자식의 수 : 0           
* 모든 리프 노드의 깊이가 같아야 한다.             
* 높이가 h인 트리의 노드 개수 2^h -1         
쉽게 말해서 꽉차 있는 이진 트리를 의미한다.     
    
## 2.2. 어ㅣㄴ잔 이진트리            
* 단말 노드를 제외한 노드의 자식의 수 : 2            
* 리프 노드의 자식의 수 : 0           
* 마지막 레벨에는 노드가 일부는 없을 수도 있음   
* 오른쪽에서부터 몇개가 사라진 형태
    
***
# 3. 트리의 표현  
  
* 트리는 그래프이기 때문에, **그래프의 표현과 같은 방식으로 저장할 수 있다.**       
* 또는       
* 트리의 모든 노드는 부모를 하나 또는 0개만 가지기 때문에 부모만 저장하는 방식으로 저장할 수 있다.       
* 부모가 0개인 경우는 트리의 루트인데, 이 경우 부모를 -1이나 0으로 처리하는 방식을 사용한다.        

루트가 없다면 부모 자식관계라는 개념조차 존재하지 않는다.      
그러나 루트가 있다면 그래프의 표현이 아닌 부모 자식관계를 이용한 저장 방식이 따로 존재한다.     

## 3.1. 루트 노드가 존재했을 때 사용할 수 있는 방식
* 트리의 부모만 저장하는 방식
``` 
     노드 = 1 2 3 4 5 6 7       
parent[i] = 0 1 1 2 2 3 3        
```    
부모를 찾는 것이 빠르지만 반대로 자식을 찾는 것은 시간이 걸린다.    

## 3.2. 완전 이진 트리의 경우에 사용할 수 있는 방식        
* 완전 이진 트리의 경우에는 배열로 표현할 수 있다.            
* 부모의 노드가 x인 경우에 자식의 노드는 2*x, 2*x+1로 나타내면 된다.            
그러면 모든 노드가 겹치지 않고 서로 다른 숫자를 가지게 된다.    
   
자식을 찾는 것이 빠르지만 반대로 부모를 찾는 것은 시간이 걸린다.  
   
## 3.3. 그냥 이진 트리의 경우에 사용할 수 있는 방식       
* 이진 트리의 경우에는 구조체나 클래스를 이용할 수 있다.  

```c++
struct Node{
  Node *left;
  Node *right; 
}
```
   
***
# 4. 트리의 순회   

* 트리의 모든 노드를 방문하는 순서이다.      
* 그래프의 경우에는 DFS와 BFS가 있었다.       
* 트리에서도 위의 두 방법을 사용할 수 있다.  
___
* DFS는 아래와 같이 3가지 출력 순서가 있다.
1. 프리오더 (중위)
  * 노드 방문
  * 왼쪽 자식 노드를 루트로 하는 서브 트리 프리오더하는 방식      
  * 오른쪽 자식 노드를 루트로 하는 서브 트리 프리오더하는 방식   
2. 인오더 (전위)
  * 왼쪽 자식 노드를 루트로 하는 서브트리 인오더  
  * 노드 방문  
  * 오른쪽 자식 노드를 루트로 하는 서브 트리 인오더하는 방식   
3. 포스트 오더 (후위)
  * 왼쪽 자식 노드를 루트로 하는 서브트리 포스트오더  
  * 오른쪽 자식 노드를 루트로 하는 서브 트리 포스트오더하는 방식   
  * 노드 방문 
  
* 세 방법의 차이는 노드 방문 처리를 언제 할 것인가이다.     



