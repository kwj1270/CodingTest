트리
=======================
* 자료구조의 일종    
* 트리는 그래프인데 **사이클이 없는 연결 그래프이다.**     
* 정점의 개수 : V    
* 간선의 개수 : V-1   

BFS 연습 슬라이드에서 서울 지하철2호선 문제를 풀었을때, 정점이 N개고 간선이 N개면 사이클이 1개라고 했다.  
그 이유가 바로 트리라는 사이클이 없는 연결 그래프에서 1개의 간선을 추가 시켜주었기에 사이클이 1개가 된 것이다.  

**하지만**   
* 정점의 개수 : V    
* 간선의 개수 : V-1 
라고 해서 모두가 트리인 것은 아니다.      
(A--B, C--D) 이 같이 정점 2개 간선 1개의 형태도 조건은 맞지만 연결이 되어 있지 않아서 트리는 아니다.     
그렇기에 트리는 사이클이 없는 **연결 그래프**라고 말을 하는 것이다.      
**(반대로 생각하면 정점 : V, 간선 : V-1일 경우에 연결까지 더해지면 트리인 것이다.)**    
   
# 루트 있는 트리    
트리에는 루트를 지정해줄 수 있다.     
* 루트가 있는 트리    
* 대개 1 번이 루트이다.     
* 그러나 이는 우리가 정해준 것이고 4번이 루트라 하면 4번이 루트가 된다.     
* 이렇듯 루트는 **선택적**이며 루트가 있을 수도 있고 없을 수도 있는 것이다.    
* 그리고 루트가 있다면 위에서 말한 것처럼 정하기 나름이다.  
___
루트가 있다면?  
    
* 루트부터 아래로 방향을 정할 수 있다.      
* 1 이 루트라 가정했을 시         
* 1은 2와 3의 부모     
* 2는 4와 5의 부모     
* 3은 6과 7의 부모  
다시 보면 루트가 아닌 노드는 부모가 1개씩있다.         
이를 반대로 생각해서 부모 노드가 없는 노드가 루트이다.      
    
자식이라는 개념도 존재한다.  
단말 노드를 제외하고서는 모두 자식을 1개 이상은 가지고 있다.  
즉, 자식 노드가 없는 노드가 단말 노드이다.   
   
현제라는 개념은  
같은 부모를 가지고 있는 노드를 형재 노드라고 한다.   

깊이라는 개념은    
루트에서부터의 거리를 깊이라고 한다.          
루트의 깊이를 0으로 가정했을 때 0,1,2가 되고         
루트의 깊이를 1로 가정했을 때 1,2,3 이 된다.       
   
높이라는 개념은 깊이의 최대값을 의미한다.
   
조상/자손이라는 개념은     
* p -> q 로 루트를 통과하지 않고 갈 수 있을 때       
* p가 q보다 루트에 가까우면     
* p는 q의 조상        
* q는 p의 자손     

즉 4의 조상은 4와 2와 1,     
3의 조상은 3과 1을 의미한다.           
**조상은 자기 자신을 포함한다.**       
그렇기에 1의 조상은 1인 자기 자신 밖에 없다.     
  
반대로 2의 자손은 4와 5가 있는 것이고 1의 자손은 2, 3, 4, 5, 6, 7, 이 있는 것이다.    
     
***
# 2. 이진트리 
* 자식을 최대 2개만 가지고 있는 트리    
   
## 2.1. 포화 이진트리            
* 단말 노드를 제외한 노드의 자식의 수 : 2            
* 리프 노드의 자식의 수 : 0           
* 모든 리프 노드의 깊이가 같아야 한다.             
* 높이가 h인 트리의 노드 개수 2^h -1         
쉽게 말해서 꽉차 있는 이진 트리를 의미한다.     
    
## 2.2. 완전 이진트리            
* 단말 노드를 제외한 노드의 자식의 수 : 2            
* 리프 노드의 자식의 수 : 0           
* 마지막 레벨에는 노드가 일부는 없을 수도 있음   
* 오른쪽에서부터 몇개가 사라진 형태
    
***
# 3. 트리의 표현  
  
* 트리는 그래프이기 때문에, **그래프의 표현과 같은 방식으로 저장할 수 있다.**       
* 또는       
* 트리의 모든 노드는 부모를 하나 또는 0개만 가지기 때문에 부모만 저장하는 방식으로 저장할 수 있다.       
* 부모가 0개인 경우는 트리의 루트인데, 이 경우 부모를 -1이나 0으로 처리하는 방식을 사용한다.        

루트가 없다면 부모 자식관계라는 개념조차 존재하지 않는다.      
그러나 루트가 있다면 그래프의 표현이 아닌 부모 자식관계를 이용한 저장 방식이 따로 존재한다.     

## 3.1. 루트 노드가 존재했을 때 사용할 수 있는 방식
* 트리의 부모만 저장하는 방식
``` 
     노드 = 1 2 3 4 5 6 7       
parent[i] = 0 1 1 2 2 3 3        
```    
부모를 찾는 것이 빠르지만 반대로 자식을 찾는 것은 시간이 걸린다.    

## 3.2. 완전 이진 트리의 경우에 사용할 수 있는 방식        
* 완전 이진 트리의 경우에는 배열로 표현할 수 있다.            
* 부모의 노드가 x인 경우에 자식의 노드는 2*x, 2*x+1로 나타내면 된다.            
그러면 모든 노드가 겹치지 않고 서로 다른 숫자를 가지게 된다.    
   
자식을 찾는 것이 빠르지만 반대로 부모를 찾는 것은 시간이 걸린다.  
   
## 3.3. 그냥 이진 트리의 경우에 사용할 수 있는 방식       
* 이진 트리의 경우에는 구조체나 클래스를 이용할 수 있다.  

```c++
struct Node{
  Node *left;
  Node *right; 
}
```
   
***
# 4. 트리의 순회   

* 트리의 모든 노드를 방문하는 순서이다.      
* 그래프의 경우에는 DFS와 BFS가 있었다.       
* 트리에서도 위의 두 방법을 사용할 수 있다.  
___
* DFS는 아래와 같이 3가지 출력 순서가 있다.
1. **프리오더 (전위)**   
  * 노드 방문   
  * 왼쪽 자식 노드를 루트로 하는 서브 트리 프리오더하는 방식        
  * 오른쪽 자식 노드를 루트로 하는 서브 트리 프리오더하는 방식     
  * A B D E C F G
2. **인오더 (위)**  
  * 왼쪽 자식 노드를 루트로 하는 서브트리 인오더      
  * 노드 방문     
  * 오른쪽 자식 노드를 루트로 하는 서브 트리 인오더하는 방식    
  * D B E A F C G
3. **포스트 오더 (후위) - 다이나믹 같이 왠만한 알고리즘은 포스트 오더를 쓴다**      
  * 왼쪽 자식 노드를 루트로 하는 서브트리 포스트오더    
  * 오른쪽 자식 노드를 루트로 하는 서브 트리 포스트오더하는 방식     
  * 노드 방문   
  * D E B F G C A   
* 세 방법의 차이는 노드 방문 처리를 언제 할 것인가이다.     

**트리의 순회**
```c++
#include <iostream>
using namespace std;
struct Node {
    int left;
    int right;
};
Node a[50];
void preorder(int x) { // 부모를 이용해서 자식의 값을 구할때
    if (x == -1) return;
    cout << (char)(x+'A');
    preorder(a[x].left);
    preorder(a[x].right);
}
void inorder(int x) {
    if (x == -1) return;
    inorder(a[x].left);
    cout << (char)(x+'A');
    inorder(a[x].right);
}
void postorder(int x) { // 자식을 이용해서 부모의 값을 구할때   
    if (x == -1) return;
    postorder(a[x].left);
    postorder(a[x].right);
    cout << (char)(x+'A');
}
int main() {
    int n;
    cin >> n;
    for (int i=1; i<=n; i++) {
        char x, y, z;
        cin >> x >> y >> z;
        x = x-'A';
        if (y == '.') {
            a[x].left = -1;
        } else {
            a[x].left = y-'A';
        }
        if (z == '.') {
            a[x].right = -1;
        } else {
            a[x].right = z-'A';
        }
    }
    preorder(0);
    cout << '\n';
    inorder(0);
    cout << '\n';
    postorder(0);
    cout << '\n';
    return 0;
}
``` 
    
***
# 5. 트리의 높이와 너비 
* 이진 트리를 다음과 같은 규칙에 따라 격자에 그리려고 한다.     
1. 이진트리에서 같은 레벨에 있는 노드는 같은 행에 위치한다.      
2. 한 열에는 한 노드만 존재한다.     
3. 임의의 노드의 왼쪽 부트리에 있는 노드들은 해당 노드보다 왼쪽의 열에 위치하고,       
오른쪽 부트리에 있는 노드들은 해당 노드보다 오른쪽의 열에 위치한다.        
4. 노드가 배치된 가장 왼쪽 열과 오른쪽 열 사이엔 아무 노드도 없이 비어있는 열은 없다.     


```c++
#include <iostream>
#include <algorithm>
#define left _left
#define right _right
using namespace std;
struct Node {
    int left, right;
    int order, depth;
};
Node a[10001];
int left[10001];
int right[10001];
int cnt[10001];
int order = 0;
void inorder(int node, int depth) {
    if (node == -1) return;
    inorder(a[node].left, depth+1);
    a[node].order = ++order;
    a[node].depth = depth;
    inorder(a[node].right, depth+1);
}
int main() {
    int n;
    cin >> n;
    for (int i=0; i<n; i++) {
        int x, y, z;
        cin >> x >> y >> z;
        a[x].left = y;
        a[x].right = z;
        if (y != -1) cnt[y] += 1;
        if (z != -1) cnt[z] += 1;
    }
    int root = 0;
    for (int i=1; i<=n; i++) {
        if (cnt[i] == 0) {
            root = i;
        }
    }
    inorder(root, 1);
    int maxdepth = 0;
    for (int i=1; i<=n; i++) {
        int depth = a[i].depth;
        int order = a[i].order;
        if (left[depth] == 0) {
            left[depth] = order;
        } else {
            left[depth] = min(left[depth], order);
        }
        right[depth] = max(right[depth], order);
        maxdepth = max(maxdepth, depth);
    }
    int ans = 0;
    int ans_level = 0;
    for (int i=1; i<=maxdepth; i++) {
        if (ans < right[i]-left[i]+1) {
            ans = right[i]-left[i]+1;
            ans_level = i;
        }
    }
    cout << ans_level << ' ' << ans << '\n';
    return 0;
}
```
   
***
# 6. 트리의 탐색  
* 트리의 탐색은 DFS/BFS 알고리즘을 이용해서 할 수 있다.     
* 트리는 사이클이 없는 그래프이기 때문에        
* 임의의 두 정점 사이의 경로는 1개이다. (2개 이상이면 사이클인 것이기 때문에)    
* 만약에 트리에서 최단 거리를 찾으라 했을때는 DFS/BFS 둘다 최단 거리를 구할 수 있다.    
* 따라서, DSF, BFS 알고리즘을 이용해서 최단 거리를 구할 수 있다.      
* 이유: 경로가 1개라 찾은 그 경로가 최단 경로    

## 6.1. 트리의 부모 찾기  
* 그래프로 트리를 입력받고       
* 루트를 1이라고 정했을 때 -> 루트를 정해준 것이다. -> **루트부터 탐색시작**         
* 각 노드의 부모를 찾는 문제      

* BFS 탐색으로 해결할 수 있다.    
   
```c++
queue<int> q;
depth[1] = 0;
check[1] = true;
parent[1] = 0;
q.push(1);

while(!q.empty()){
   int x = q.front(); 
   q.pop();
   for(int y : a[x]){
      if(!check[y]){
         depth[y] = depth[x] + 1;
         check[y] = true;
         parent[y] = x;
         q.push(y);
      }
   }
}   
```

## 6.2. 트리의 지름
* 트리에 존재하는 모든 경로중에서 **가장 긴 것의 길이**를 트리의 지름이라고 한다.       
* 트리의 지름은 **탐색 2번**으로 구할 수 있다.        
1. 한 정점 s에서 모든 정점까지의 거리를 구한다.          
이때, 가장 먼 거리인 정점을 **u**라고 한다.         
2. 다시 **u**에서 모든 정점까지의 거리를 구한다. 이 때, 가장 먼 거리인 정점 v를 구한다.       
* d(u,v)를 u와 v사이의 거리라고 했을 때, d(u,v)가 트리의 지름이다.      

1. 중간에서 가장 바깥쪽으로 빠진 다음에  
2. 반대편으로 찾아가는 형태
   
```c++
#include <cstdio>
#include <queue>
#include <vector>
#include <cstring>
using namespace std;
struct Edge {
    int to; // 다음 노드   
    int cost;  // 비용(가중치?)   
    Edge(int to, int cost) : to(to), cost(cost) { // 이친구는 생성자이다 바로 값을 넣어주는 역할     
    }
};
vector<Edge> a[100001]; // vector<엣지>형 배열 100001 생성 -> 즉, 이차원 가변 배열 만듬
bool check[100001]; // 도착했는지 안 햇는지 검증
int dist[100001]; // 여기까지 오는 최소거리에 대한 DP     
void bfs(int start) { // 시작 
    memset(dist,0,sizeof(dist)); // 2번 할 것이여서 초기화 구문 작성
    memset(check,false,sizeof(check)); // 2번 할 것이여서 초기화 구문 작성
    queue<int> q; // 큐 -> 인트네?   
    check[start] = true; // 시작 지점은 도착했다 지정 
    q.push(start); // 시작 지점 큐에 넣고 시작 
    while (!q.empty()) { // 큐가 비었으면 종료  
        int x = q.front(); // 큐에서 빼온 첫번째 값 
        q.pop(); // 큐 빼기  
        for (int i=0; i<a[x].size(); i++) { // 엣지 백터
            Edge &e = a[x][i]; // 다음 이동 및 비용 빼오기  
            if (check[e.to] == false) { // 안 갔으면 
                dist[e.to] = dist[x] + e.cost; // 현재에서 비용만큼만 증가한것이지  
                q.push(e.to); // 다음 갈 곳을 넣는다.  
                check[e.to] = true; // 이동 할 곳 true
            }
        }
    }
}
// 다양하게 존재하지 않으면 그냥 했을 텐데
// 아마 비용이 정말 다양히 있어서 Edge를 만들어서 사용
 
int main() {
    int n; // 사이즈 입력 
    scanf("%d",&n);
    for (int i=1; i<=n; i++) { // 1 ~ 사이즈 까지 
        int x; // x 입력 받기 
        scanf("%d",&x);
        while (true) {
            int y, z; // y는 to , z 는 cost
            scanf("%d",&y);
            if (y == -1) break; // 종료하고자 하면 다음 입력시 -1 눌르자
            scanf("%d",&z);
            a[x].push_back(Edge(y,z)); // 연결리스트에 엣지 형태로 넣기  
        }
    }
    bfs(1); // 임의이 지점 아무곳이나 가능하니 1을 넣어줬다.
    int start = 1; // 1
    for (int i=2; i<=n; i++) {
        if (dist[i] > dist[start]) {
            start = i; // 임의에서 가장 긴거리 측정 
        }
    }
    bfs(start); // 이제 다시 시작 
    int ans = dist[1]; // 최소 이만큼은 얻은값  
    for (int i=2; i<=n; i++) { 
        if (ans < dist[i]) { // 더 길면 
            ans = dist[i]; // 최대값 얻기 
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
___
* 포스트 오더를 이용해서도 구할 수 있다.  
* 루트가 v 일때, 트리의 지름은 v를 통과하거나, v를 통과하지 않는 경우 2가지가 있다.  
* v를 통과하지 않는 경우에는 각각의 자식 C1, C2, ..., Ck를 루트로 하는 서브트리에서 다시 트리의 지름을 구한다.  
* v를 통과하는 경우에는 트리의 지름은 각각 C1, C2, ..., Ck에서 리프노드까지의 거리 중에 가장 큰값 2개를 이용해서 만들 수 있다.  
   
```c++
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>
#include <cstring>
using namespace std;
struct Edge {
    int to;
    int cost;
    Edge(int to, int cost) : to(to), cost(cost) {
    }
};
vector<Edge> a[100001];
bool check[100001];
pair<int, int> dfs(int x) { // first: diameter, second: height
    check[x] = true;
    vector<int> heights;
    int ans = 0;
    for (auto &e : a[x]) {
        int y = e.to;
        int cost = e.cost;
        if (check[y] == false) {
            auto p = dfs(y);
            if (ans < p.first) ans = p.first;
            heights.push_back(p.second+cost);
        }
    }
    int height = 0;
    sort(heights.begin(), heights.end());
    reverse(heights.begin(), heights.end());
    if (heights.size() >= 1) {
        height = heights[0];
        if (ans < height) {
            ans = height;
        }
    }
    if (heights.size() >= 2) {
        if (ans < heights[0] + heights[1]) {
            ans = heights[0] + heights[1];
        }
    }
    return make_pair(ans, height);
}
int main() {
    int n;
    scanf("%d",&n);
    for (int i=1; i<=n; i++) {
        int x;
        scanf("%d",&x);
        while (true) {
            int y, z;
            scanf("%d",&y);
            if (y == -1) break;
            scanf("%d",&z);
            a[x].push_back(Edge(y,z));
        }
    }
    auto ans = dfs(1);
    cout << ans.first << '\n';
    return 0;
}
```
