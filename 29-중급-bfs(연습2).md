# 1. 벽 부수고 이동하기4 https://www.acmicpc.net/problem/16946

* N x M 크기의 지도가 있다.     
* 0은 이동할 수 있는곳(빈칸), 1은 이동할 수 없는 곳(벽)을 의미한다.    
* 두 칸이 변을 공유할 때 인접하다고 말을 한다.   
* 각각의 변을 빈칸으로 바꾸고, 그 위치에서 이동할 수 있는 칸의 개수 10% 을 구하자   

```c++
#include <iostream>
#include <vector>
#include <string>
#include <queue>
#include <set>
#include <tuple>
using namespace std;
int n, m;
int a[1000][1000];
bool check[1000][1000];
int group[1000][1000];
vector<int> group_size;
int dx[] = {0,0,1,-1};
int dy[] = {1,-1,0,0};
void bfs(int sx, int sy) {
    int g = group_size.size(); // 처음에는 0이겠네
    cout << g << " ";
    queue<pair<int,int>> q; // 큐
    q.push(make_pair(sx,sy)); // 위치 넣고 돌리기
    check[sx][sy] = true; // true 변형
    group[sx][sy] = g; // 그룹번호.
    int cnt = 1; // 카운트
    while (!q.empty()) {
        int x, y; // 현재 x,y
        tie(x, y) = q.front(); q.pop();
        for (int k=0; k<4; k++) { // 4방향.
            int nx = x+dx[k];
            int ny = y+dy[k];
            if (0 <= nx && nx < n && 0 <= ny && ny < m) { // 범위내에 있으면
                if (a[nx][ny] == 0 && check[nx][ny] == false) { // 다음 갈곳이 0이고 안갔다면
                    q.push(make_pair(nx,ny)); // 다음 이동 가능
                    check[nx][ny] = true; // true 해주고
                    group[nx][ny] = g; // 그룹번호 넣어주고
                    cnt += 1; // 카운트 증가
                }
            }
        }
    }
    group_size.push_back(cnt); // 그룹에 카운트 넣는다.  -> bfs 시에 그룹 증가
    // 0일때 그룹
}
int main() {
    cin >> n >> m;
    for (int i=0; i<n; i++) {
        string s;
        cin >> s;
        for (int j=0; j<m; j++) {
            a[i][j] = s[j] - '0'; // 숫자로 입력
            check[i][j] = false; // false로 통일
            group[i][j] = -1; // 일단 그룹은 다 -1로
        }
    }
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (a[i][j] == 0 && check[i][j] == false) { // 0이고 false이면
                bfs(i, j); // bfs 돌린다.
            }
        }
    }
    
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (a[i][j] == 0) { // 0일 경우
                cout << 0; // 그냥 0 출력
            } else { // 1일 경우
                set<int> near; // 중복방지를 위한 set -> 한곳 검색하고 나머지 3곳에서 같은 범위내에 속한값은 지워줘야하니까.
                for (int k=0; k<4; k++) {
                    int x = i+dx[k]; // 4방향
                    int y = j+dy[k]; // 4방향 이동
                    if (0 <= x && x < n && 0 <= y && y < m) { // 범위내라면
                        if (a[x][y] == 0) { // 그리고 0이라면
                            near.insert(group[x][y]); // 그룹값 넣기 -> 중복을 넣어도 set 으로 처리안된다.
                        }
                    }
                }
                int ans = 1;
                for (int g : near) {
                    ans += group_size[g]; // 빈칸 그룹값을 추가로 넣어주는데 set을 했기에 중복되지는 않는다.
                }
                cout << ans%10;
            }
        }
        cout << '\n';
    }
    return 0;
}

```

# 2. 벽 부수고 이동하기2 https://www.acmicpc.net/problem/14442

* N x M 행렬로 이루어진 지도에서 (1,1)에서 (N,M)으로 최단거리로 이동하는 문제    
* 0은 이동할 수 있는곳(빈칸), 1은 이동할 수 없는 곳(벽)을 의미한다.    
* 단 벽은 k번까지만 이동 가능하다.  

```c++
#include <iostream>
#include <queue>
#include <cstdio>
#include <cstring>
#include <tuple>
using namespace std;
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
int main() {
    int n, m, k;
    scanf("%d %d %d",&n, &m, &k);
    
    int a[n][m];
    int d[n][m][k+1];
    
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            scanf("%1d",&a[i][j]);
        }
    }
    memset(d, 0, sizeof(d)); // d를 0으로 초기화
    queue<tuple<int,int,int>> q;
    d[0][0][0] = 1;
    q.push(make_tuple(0,0,0));
    while (!q.empty()) {
        int x, y, z;
        tie(x,y,z) = q.front(); q.pop();
        for (int j=0; j<4; j++) {
            int nx = x+dx[j];
            int ny = y+dy[j];
            if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            if (a[nx][ny] == 0 && d[nx][ny][z] == 0) {
                d[nx][ny][z] = d[x][y][z] + 1;
                q.push(make_tuple(nx,ny,z));
            }
            if (z+1 <= k && a[nx][ny] == 1 && d[nx][ny][z+1] == 0) {
                d[nx][ny][z+1] = d[x][y][z] + 1;
                q.push(make_tuple(nx,ny,z+1));
            }
        }
    }
    int ans = -1;
    for (int i=0; i<=k; i++) {
        if (d[n-1][m-1][i] == 0) continue;
        if (ans == -1) {
            ans = d[n-1][m-1][i];
        } else if (ans > d[n-1][m-1][i]) {
            ans = d[n-1][m-1][i];
        }
    }
    cout << ans << '\n';
    return 0;
}

```

# 3. 벽 부수고 이동하기3 https://www.acmicpc.net/problem/16933

* N x M 행렬로 나타내는 지도에서 (1,1)에서 (N,M)으로 최단 거리로 이동하는 문제  
* 0은 빈칸, 1은 벽 
* 이동할 때마다 낮과 밤이 바뀐다.   
* 단, 벽은 k번까지만 부술 수 있고, 낮에만 부술 수 있다.  
* 벽을 부순다는 조건이 없으면 일반적인 미로탐색 문제이다.  
* 어떤 칸에 방문했을 때, 벽을 부순적이 있는 경우와 아직 부순 적 없는 경우는 다른 경우이다.   
* 낮과 밤도 다른 경우이다.  
* 상태(i,j) 대신에 (i,j,b,t)(b는 벽을 부순 횟수, t=낮과밤)으로 BFS를 탐색을 진행한다.  

```c++
#include <iostream>
#include <queue>
#include <cstdio>
#include <cstring>
#include <tuple>
using namespace std;
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
int main() {
    int n, m, k;
    scanf("%d %d %d",&n, &m, &k);
    
    int a[n][m];
    int d[n][m][k+1][2];
    
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            scanf("%1d",&a[i][j]);
        }
    }
    memset(d, 0, sizeof(d)); // d를 0으로 초기화
    queue<tuple<int,int,int,bool>> q;
    d[0][0][0][0] = 1;
    q.push(make_tuple(0,0,0,0));
    while (!q.empty()) {
        int x, y, z, night;
        tie(x,y,z,night) = q.front(); q.pop();
        for (int j=0; j<4; j++) {
            int nx = x+dx[j];
            int ny = y+dy[j];
            if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            
            if (a[nx][ny] == 0 && d[nx][ny][z][1-night] == 0) {
                d[nx][ny][z][1-night] = d[x][y][z][night] + 1;
                q.push(make_tuple(nx,ny,z,1-night));
            }
            if (night == 0 && z+1 <= k && a[nx][ny] == 1 && d[nx][ny][z+1][1-night] == 0) {
                d[nx][ny][z+1][1-night] = d[x][y][z][night] + 1;
                q.push(make_tuple(nx,ny,z+1,1-night));
            }
        }
        if(d[x][y][z][1-night] == 0){
            d[x][y][z][1-night] = d[x][y][z][night]+1;
            q.push(make_tuple(x,y,z,1-night));
        }
    }
    int ans = -1;
    for(int i=0; i < 2; i++)
    for (int j=0; j<=k; j++) {
        if (d[n-1][m-1][j][i] == 0) continue;
        if (ans == -1) {
            ans = d[n-1][m-1][j][i];
        } else if (ans > d[n-1][m-1][j][i]) {
            ans = d[n-1][m-1][j][i];
        }
    }
    cout << ans << '\n';
    return 0;
}

```

4. 움직이는 미로 탈출 https://www.acmicpc.net/problem/16933

* 크기가 8 x 8 인 체스판이 있고, 모든 칸은 빈칸 또는 벽이다.      
* 가장 왼쪽 아랫쪽에서 가장 오른쪽 윗쪽까지 이동할 수 있는지 없는 지를 구하는 문제    
* 벽은 1초에 한칸씩 내려온다    
* 벽이 없는 칸으로 이동할 수 없고, 이동한 칸에 벽이 내려오면 더이상 이동할 수 없다.      
* 8초가 지나면 벽이 전부 없어진다.  
___
* 지도를 총 9개 준비해서 , 0초후, 1초후, 2초후..., 8초후를 만들고 BFS를 수행한다.  
* (r,c,t): t초 후에 (r,c)에 있을 때 최소시간   
* 8초후 부터는 t를 증가시키는 의미가 있다.  
___
* 실제로는 지도를 9개나 만들 필요는 없다.   
* 특정 시점이 t초 후에 벽이 있는지 없는지는 알아낼 수 있기 때문이다.     
* t초 후에 (r,c)로 벽이 내려왔다면, 그 벽은 (r-t,c) 에 있던 벽이다.   

```c++
#include <iostream>
#include <tuple>
#include <vector>
#include <string>
#include <queue>
using namespace std;
bool check[8][8][9];
int dx[] = {0,0,1,-1,1,-1,1,-1,0};
int dy[] = {1,-1,0,0,1,1,-1,-1,0};
int main() {
    int n = 8;
    vector<string> a(n);
    for (int i=0; i<n; i++) {
        cin >> a[i];
    }
    queue<tuple<int,int,int>> q;
    check[7][0][0] = true;
    q.push(make_tuple(7,0,0));
    bool ans = false;
    while (!q.empty()) {
        int x, y, t;
        tie(x,y,t) = q.front(); q.pop();
        if (x == 0 && y == 7) ans = true;
        for (int k=0; k<9; k++) {
            int nx = x+dx[k];
            int ny = y+dy[k];
            int nt = min(t+1, 8);
            if (0 <= nx && nx < n && 0 <= ny && ny < n) {
                if (nx-t >= 0 && a[nx-t][ny] == '#') continue;
                if (nx-t-1 >= 0 && a[nx-t-1][ny] == '#') continue;
                if (check[nx][ny][nt] == false) {
                    check[nx][ny][nt] = true;
                    q.push(make_tuple(nx,ny,nt));
                }
            }
        }
    }
    cout << (ans ? 1 : 0) << '\n';
    return 0;
}
```
```c++
                if (nx-t >= 0 && a[nx-t][ny] == '#') continue;
                if (nx-t-1 >= 0 && a[nx-t-1][ny] == '#') continue;
```

2개인 이유는 아래는 기존 우리가 구하는 우리가 이동한 곳에 벽이 내려올 경우를 말하는 것이고   
위 조건문은 이미 벽이 거기에 존재하는가를 의미한다.    
무슨 의미냐면 벽이 이미 내려오고 있다는 것을 의미해서 지금 당장은 못간다는 의미이다.   
