알고리즘 시작
=======================
# 1. 시간복잡도
우리가 어떤 코드를 작성했을 때 시간이 얼마나 걸리는지 예측을 해볼 수 있는 방법이다.  
    
문제의 크기 : N
   
* 시간 복잡도를 이용하면 작성한 코드가 시간이 대략 얼마나 걸릴지 예상할 수 있다.  
* 표기법으로 대문자 O를 사용한다. 
* 영어로는 Big O Notataion
* 입력의 크기 N에 대해서 시간이 얼마나 걸릴지 나타내는 방법
* 즉, **최악의 경우에 시간이 얼마나 걸릴지 알 수 있다.**  

## 1.1. 시간복잡도 예시

1. 총 N명의 사람이 식당에 방문
2. 식당에는 메뉴가 M개 이고 메뉴판이 1개 있다.
3. 사람 1명이 메뉴판을 읽는데 걸리는 시간은 O(M)이다.
4. 주문한 모든 메뉴는 동시에 나왔고, 각 사람 i 가 식사를 하는데 걸리는 시간은 A_i이다.
5. 각 사람이 계산을 하는데 걸리는 시간은 O(P)이다.  
  
* 각 사람이 메뉴판에 있는 모든 메뉴를 읽는 시간 복잡도 = O(NM)
* 모든 사람이 식사를 마치는데 걸리는 시간 = O(max(A_i))
* 식사를 모두 마친 다음 한줄로 서서 각자 계산을 하는 시간 복잡도 = O(NP)

```
시간 복잡도는 소스를 보고 계산할 수 도 있고, 
소스를 작성하기도 전에 먼저 계산해볼 수 있다. 

문제를 풀기전에 먼저 생각한 방법의 시간 복잡도를 계산해보고  
이게 시간 안에 수행될 것 같은 경우에만 구현하는 것이 좋다.
```

## 1.2. 시간복잡도 코드 예시
1부터 N까지의 합을 계산
## 1.2.1. O(N)
```c++
int sum = 0;
for(int i=1; i <= N; i++){
    sum += i;
}
```
## 1.2.2. O(N^2)
```c++
int sum = 0;
for(int i=1; i <= N; i++){
    for(int j=1; j <= N; j++){
        if(i == j){
            sum += i;
        }
    }
}
```
## 1.2.3. O(1)
```c++
int sum = N * (N+1) / 2;
```

## 1.2.4. 시간 예측해보기

* 시간 복잡도 안에 가장 큰 입력 범위를 넣었을 때, 1억이 1초정도이다.  
* 이 값은 대략적인 값으로, 실제로 구현해보면 1억을 조금 넘어도 1초 이내에 수행이 가능하다.  
    
그렇기에 (N <= 10만) 일 경우에는 

1. O(1) => 1 => 1/1억
2. O(N) => 10만 => 10만 / 1억 => 10/10000 초
3. O(N^2) => 100억  => 100억 / 1억 => 100초

## 1.2.5. 빅오표기법 

* Big O Notaion에서 상수는 버린다. ```(3N^2) -> O(N^2)```
* 두가지 항이 있을때, 변수가 같은면 큰 것만 빼고 다 버린다. ```(n^2 + N) -> O(n^2)```
* 두가지 항이 있을때, 변수가 다르면 그냥 놔둔다. ```(n^2 + M) -> O(n^2 + M)``
    
***
# 2. 메모리
* 메모리 제한은 보통 넉넉하기 때문에, 걱정할 필요가 없다.
* 대략적으로 얼마나 공간을 사용할지 예상할 수는 있다.  

## 2.1. 사용한 메모리

* 보통 가장 많은 공간을 사용하는 것은 보통 배열이다.  
* 배열이 사용한 공간: 배열의 크기 X 자료형의 크기 B
* ```int a[1000]```
* ```int a[10000]```
* ```int a[1000][1000]```
* ```int a[10000][10000]``` -> 1억을 의미하고 이는 1초를 의미하기도 한다.  

* 보통 배열의 크기가 크면 시간 초과를 받는 경우가 많다.  
* 불필요한 공간이 없다면, 대부분 메모리 제한은 알아서 지켜진다.  

***
# 3. 입출력
## 3.1. C 입출력
* 입출력은 scanf/printf
## 3.2. C++ 입출력
* 입출력은 scanf/printf , cin/cout을 사용할 수 있다.
* 그러나 cin/cout은 느리기에 입출력이 많으면 scanf/printf 사용 권장한다.

아니면 밑의 세줄을 추가하면 cin/cout 이 더 빨라진다.
```
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
```
단, 이 경우에는 ```scanf/printf , cin/cout```을 섞어 사용못한다.  
즉, ```cin/cout```만 사용 가능하다.

## 3.3. java 입출력
* java 입력은 Scanner, 출력은 System.out 을 이용한다.  
```java
Scanner scanner = new Scanner(Sytem.in);
```
* 입력이 많은 경우에는 속도가 느리기 때문에, BufferedReader를 사용한다.  
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
```
* 출력이 많은 경우에는 StringBuilder를 사용해서 한 문자열로 만들어서 출력을 한 번만 사용하거나 
* BufferedWriter를 이용한다.  

