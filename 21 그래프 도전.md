그래프 도전
=======================
# 1. BFS 스페셜 저지 
정점의 개수가 N이고, 정점에 1부터 N까지 번호가 매겨져있는 양방향 그래프가 있을 때,     
BFS 알고리즘은 다음과 같은 형태로 이루어져 있다.       


1. 큐에 시작 정점을 넣는다. 이 문제에서 시작 정점은 1이다. 1을 방문했다고 처리한다.
2. 큐가 비어 있지 않은 동안 다음을 반복한다.
  1. 큐에 들어있는 첫 정점을 큐에서 꺼낸다. 이 정점을 x라고 하자.
  2. x와 연결되어 있으면, 아직 방문하지 않은 정점 y를 모두 큐에 넣는다. 모든 y를 방문했다고 처리한다.

* 입력으로 주어진 정보를 이용해서 BFS 탐색을 진행하면서 올바른 결과인지 살펴본다.
2-2 단계에서 방문하지 않은 정점을 방문하는 순서는 중요하지 않다. 따라서, BFS의 결과는 여러가지가 나올 수 있다.

**내가 짠 코드**    
```c++
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <queue>
#include <stack>

using namespace std;


vector<int> list[100001];
vector<int> standardArr;
vector<int> arr;
vector<int> arr2;

bool check[100001];
int n;

vector<int> bfs(int start){
	queue<int> q;
	q.push(start);
	vector<int> tempArr;
	while(!q.empty()){
		int x = q.front();
		tempArr.push_back(x);
		q.pop();
		check[x] = true;
		for(int i=0; i < list[x].size(); i++){
			int y = list[x][i];
			if(check[y] == false){
				q.push(y);
			}
		}
	}
	return tempArr;
}

bool checkArr(){
	for(int i=0; i < n; i++){
		if(standardArr[i] != arr[i] || standardArr[i] != arr2[i]){
			return false;
		}
	}
	return true;
}

int main(int argc, char* argv[]) {
	bool ok = false;
	cin >> n;
	for(int i=0; i < n-1; i++){
		int x, y;
		cin >> x >> y;
		list[x].push_back(y);
		list[y].push_back(x);
	}

	standardArr.resize(n);
	for(int i=0; i < n; i++){
		cin >> standardArr[i];
	}

	arr = bfs(1);
	for (int i=1; i<=n; i++) {
        sort(list[i].begin(), list[i].end());
		check[i] = false;
    }
	arr2 = bfs(1);
	cout << checkArr()? 1 :0;
	cout << "\n";
	return 0;
}
```

**소스 코드**   
```c++
int m = 1; // 큐의 크기 
for(int i=0; i < n; i++){
  if(q.empty())
  int x = q.front(); q.pop();
  if( x != order[i])
  int cnt = 0;
  for(int y: a[x]){ 
    if(check[y] = false){
      parent[y] = x;
      cnt += 1;
    }  
  }
  for(int j=0; j < cnt; j++){
    if(m+j >= n || parent[order[m+j]] != x)
    q.push(order[m+j]);
    check[order[m+j]] = true;
  }
  m += cnt;
}
```
