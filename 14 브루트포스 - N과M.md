
브루트포스 - N과M
=======================  
브루트 포스에서 방법을 만드는 방법은 주로 3가지가 있다
1. 재귀 
2. 순열 
3. 비트마스크
  
그 중에서도 재귀함수가 제일 중요한데 왜냐하면 순열과 비트마스크는 재귀로 변환시킬 수 있기 때문이다.   
   
재귀를 사용하는 브루트 포스는 대개 2가지로 나눌 수 있는데
1. 순서와 관련된 문제  
2. 선택과 관련된 문제  
   
# 1. N 과 M (1)
* 1부터 N까지 자연수 중에서 **중복 없이** M개를 고른 수열을 모두 구하는 문제  
* 1 <= M <= N <= 8
예를 들면 N이 5이고 M이 3이면?
```
123
124
125
132
134
135
.
.
.
```
이렇게 중복 없이 m개를 고르는 문제는 순서와 관련된 문제라고 볼 수 있다.    
왜 그렇냐면 각각의 순서마다 들어간 값을 알아야 다음 수를 알 수 있기 때문이다.     
만약 중복이 있었다면 앞 순서에 어떤 값이 오더라도 뒤 값은 영향을 받지 않기에 순서가 아니라고 볼 수 있다.     
       
여기서 우리가 할 수 있는 가장 단편적인 방법은 앞에서 부터 수를 하나씩 넣는 것이다.    
그리고 그다음 숫자는 앞에서 정한 숫자를 제외한 숫자들이 경우의 수일것이다.    
     
중복없이를 구현하기 위해서 우리는 사용된 숫자라는 것을 알리기 위한 배열 C를 만들어 사용할 것이다.  
```
bool c[10]
```
```c[i]``` 값이 true 이면 i라는 값을 사용한 것이고 반대로 false 이면 사용하지 않은 것을 의미시킨다.  
또한 ```a[]```을 이용해서 각 자리수마다 저장된 숫자들을 넣어줄 수 있다.  
```
int a[10]
```

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <stack>
#include <queue>
#include <deque>

using namespace std;

bool c[10]; 
int a[10];
void go(int index, int n, int m){ // m은 자리수를 의미
	if(index == m) {
		for(int i=0; i < m ;i++){
			cout << a[i];
            if (i != m-1) cout << ' ';
		}
		cout << "\n";
		return; // 탈출 조건
	}
	for(int i=1; i <=n; i++){
		if(c[i]) continue; 
		c[i] = true;
		a[index] = i;
		go(index+1, n, m);
		c[i] = false; // 이전 것을 풀어줘야 다음것을 할 수 있음
					  // 한 순서에 1개만 선택할 때 사용할 수 있는 방법이다.  
	} 
}

int main(void){

	int n,m;
	cin >> n >> m;
	go(0, n,m);
	return 0;
}
```

# 1. N 과 M (2)
mn2
```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <stack>
#include <queue>
#include <deque>

using namespace std;

bool c[10]; 
int a[10];
void go(int index, int start, int n, int m){ // m은 자리수를 의미
	if(index == m) {
		for(int i=0; i < m ;i++){
			cout << a[i];
            if (i != m-1) cout << ' ';
		}
		cout << "\n";
		return; // 탈출 조건
	}
	for(int i=start; i <=n; i++){
		if(c[i]) continue; // 전보다 작으면 continue
		c[i] = true; 
		a[index] = i;
		go(index+1,i+1, n, m);
		c[i] = false; // 이전 것을 풀어줘야 다음것을 할 수 있음
					  // 한 순서에 1개만 선택할 때 사용할 수 있는 방법이다.  
	} 
}

int main(void){

	int n,m;
	cin >> n >> m;
	go(0,1, n,m);
	return 0;
}
```
 
mn2(김우재 오리지널)
```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <stack>
#include <queue>
#include <deque>

using namespace std;

bool c[10]; 
int a[10];
void go(int index, int n, int m){ // m은 자리수를 의미
	if(index == m) {
		for(int i=0; i < m ;i++){
			cout << a[i];
            if (i != m-1) cout << ' ';
		}
		cout << "\n";
		return; // 탈출 조건
	}
	for(int i=1; i <=n; i++){
		if(c[i] || a[index-1] >= i) continue; // 전보다 작으면 continue
		c[i] = true; 
		a[index] = i;
		go(index+1, n, m);
		c[i] = false; // 이전 것을 풀어줘야 다음것을 할 수 있음
					  // 한 순서에 1개만 선택할 때 사용할 수 있는 방법이다.  
	} 
}

int main(void){

	int n,m;
	cin >> n >> m;
	go(0, n,m);
	return 0;
}
```



# 2. 수 이어쓰기  
* 1부터 N까지 수를 이어서 쓰면 새로운 하나의 수를 얻게 된다. (1 <= N <= 100,000,000)  
* 12345678910111213141516171819202122...
* 이때, 새로운 수는 몇 자리 수일까? (길이 구하기)         
    
한가지 패턴을 발견해보자면 **수의 자리수별로 나누어서 문제를 해결할 수 있다.**   
* N = 120 가정시에
* 1-9 는 1개
* 10-99는 2개
* 100-120 은 2자리

다시 
* 1-9 는 1 x (9-1+1) == 9   
* 10-99는 2 x (99-10+1) == 180   
* 100-120 은 3 x (120-100+1) == 63   

이렇게 문제를 풀 수 있는 이유는   
수가 1부터 N까지 빠짐없이 사용된다는 점이다.  

이렇게 생각의 방향을 바꿔보면 문제의 경우의수를 많이 줄일 수 있다.    
1. 나머지 연산    
2. 중복되는 것을 공통되는 것을 그룹화하여 연산의 횟수를 줄이는 법   

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <stack>
#include <queue>
#include <deque>

using namespace std;

int main(void){

	int n;
	cin >> n;
	long long ans = 0;
	for(int start=1, len=1; start <=n ; start*=10, len++){
		int end = start*10-1; // 처음에는 1의 자릿수
							  // 9 , 99 , 999 
		if(end > n) {
			end = n;	      // 999 -> 120
		}
		ans += (long long)(end-start+1) * len; // strat는 10배 증가 len은 1씩 증가이므로
		// 9-1+1 * 1자리
		// 99-10+1 * 2자리
		// 120-100+1 * 3자리 의 값을 더해준다.  
	}
	cout << ans << "\n";

	return 0;
}
```
# 3. N중 for문 
* N개 중에 일부를 선택해야 하는 경우에 많이 사용한다.  
* 재귀 호출이나 비트마스크를 사용하면 더 간결하고 보기 쉬운 코드를 작성할 수 있기 때문에, 사용할 일이 거의 없다.  

# 4. 1,2,3, 더하기  
이전에 DP 방식으로 풀었던 문제이다.  
   
* 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제이다.  
* n = 4 
* 1+1+1+1
* 1+1+2
* 1+2+1
* 2+1+1
* 2+2
* 1+3
* 3+1

```c++
#include <cstdio>
int main() {
    int t;
    scanf("%d",&t);
    while (t--) {
        int ans = 0;
        int n;
        scanf("%d",&n);
        for (int l1=1; l1<=3; l1++) {
            if (l1 == n) {
                ans += 1;
            }
            for (int l2=1; l2<=3; l2++) {
                if (l1+l2 == n) {
                    ans += 1;
                }
                for (int l3=1; l3<=3; l3++) {
                    if (l1+l2+l3 == n) {
                        ans += 1;
                    }
                    for (int l4=1; l4<=3; l4++) {
                        if (l1+l2+l3+l4 == n) {
                            ans += 1;
                        }
                        for (int l5=1; l5<=3; l5++) {
                            if (l1+l2+l3+l4+l5 == n) {
                                ans += 1;
                            }
                            for (int l6=1; l6<=3; l6++) {
                                if (l1+l2+l3+l4+l5+l6 == n) {
                                    ans += 1;
                                }
                                for (int l7=1; l7<=3; l7++) {
                                    if (l1+l2+l3+l4+l5+l6+l7 == n) {
                                        ans += 1;
                                    }
                                    for (int l8=1; l8<=3; l8++) {
                                        if (l1+l2+l3+l4+l5+l6+l7+l8 == n) {
                                            ans += 1;
                                        }
                                        for (int l9=1; l9<=3; l9++) {
                                            if (l1+l2+l3+l4+l5+l6+l7+l8+l9 == n) {
                                                ans += 1;
                                            }
                                            for (int l0=1; l0<=3; l0++) {
                                                if (l1+l2+l3+l4+l5+l6+l7+l8+l9+l0 == n) {
                                                    ans += 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
