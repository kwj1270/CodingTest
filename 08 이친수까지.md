이친수까지
=======================
# 1. 카드 구매하기  
   
* 카드 N개를 구매해야 한다.       
* 카드팩은 총 N가지 종류가 존재한다.    
* i번째 카드팩은 i개의 카드를 담고 있고, 가격은 P[i]원이다.  
* 카드 N개를 구매하는 비용의 최대값을 구하는 문제  
    
**점화식**  
1. 우리가 구매하려는 카드의 갯수는 총 n 개이다.  
2. 우리는 카드팩내에 카드의 개수가 1~N 까지로 명확히 정해지지 않았다.    
3. 대신 이를 거꾸로 생각하면 카드팩을 구매하기 전에는 n-i개를 소유하고 있었을 것이다.
4. 즉, d[n] = d[n-i]+p[i] 라는 가정식이 생성된다. (d[n]은 n개를 구매하는 최대값)     
5. 이를 다시 표현하자면 ```d[i] = max(d[i], d[i-j] + price[j])```로 나타낼 수 있다.   

```c++
#include <iostream>
#include <vector>
using namespace std;

int d[1000]; // 총 합 예) 4개 구할때의 총합  
int p[10000]; // 각 합 예) 4번째 카드의 값  

int main(void) { 
    int n;
	cin >> n;
	cin.ignore();
	for(int i=1; i <= n;i++){
		cin >> p[i];
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= i ; j++){
			d[i] = max(d[i], d[i-j] + p[j]);	
		}
	}
	cout << d[n] << "\n";
}
```

***
# 2. 카드 구매하기 2  
* 카드 N개를 구매해야 한다.          
* 카드팩은 총 N가지 종류가 존재한다.        
* i번째 카드팩은 i개의 카드를 담고 있고, 가격은 P[i]원이다.        
* 카드 N개를 구매하는 비용의 **최소값**을 구하는 문제        
       
**점화식**  
1. 우리가 구매하려는 카드의 갯수는 총 n 개이다.  
2. 우리는 카드팩내에 카드의 개수가 1~N 까지로 명확히 정해지지 않았다.    
3. 대신 이를 거꾸로 생각하면 카드팩을 구매하기 전에는 n-i개를 소유하고 있었을 것이다.
4. 즉, d[n] = d[n-i]+p[i] 라는 가정식이 생성된다. (d[n]은 n개를 구매하는 최소값)     
5. 이를 다시 표현하자면 ```d[i] = min(d[i], d[i-j] + price[j])```로 나타낼 수 있다.   

**제한을 이용한 방법**
```c++
#include <iostream>
#include <vector>
using namespace std;

int d[1000]; // 총 합 예) 4개 구할때의 총합  
int p[10000]; // 각 합 예) 4번째 카드의 값  

int main(void) { 
    int n;
	cin >> n;
	cin.ignore();
	for(int i=1; i <= n;i++){
		cin >> p[i];
		d[i] = 1000* 10000; // 최대값 1000개, 가격 10000이여서
	}
	d[0] = 0;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= i ; j++){
			d[i] = min(d[i], d[i-j] + p[j]);	
		}
	}
	cout << d[n] << "\n";
}
```
**음수를 이용한 방법 (추천- 경우의 수일때 유용)**
```c++
#include <iostream>
#include <vector>
using namespace std;

int d[1000]; // 총 합 예) 4개 구할때의 총합  
int p[10000]; // 각 합 예) 4번째 카드의 값  

int main(void) { 
    int n;
	cin >> n;
	cin.ignore();
	for(int i=1; i <= n;i++){
		cin >> p[i];
		d[i] = -1; 
	}
	d[0] = 0;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= i ; j++){
			if(d[i] == -1 || d[i] > d[i-j] + p[j]){
				d[i] = d[i-j] + p[j];	
			}
		}
	}
	cout << d[n] << "\n";
}
```

***
# 3. 1,2,3 더하기 5
* 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제     
* 단, 같은 수를 **두 번 이상 연속해서 사용하면 안된다.**     
     
**점화식**  
1. D[i][j] = i를 1,2,3의 합으로 나타내는 방법의 수
2. 마지막에 사용한 수는 j 라고 한다.      
j와 같지 않은수를 판단하고 사용하기 위해서이다.   
D[i][j] = i를 1,2,3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j

* D[i][1] = i를 1,2,3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 1
	* 바로 전에 사용할 수 있는 2,3
	* D[i][1] = D[i-1][2] + D[i-1][3] 
* D[i][2] = i를 1,2,3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 2
	* 바로 전에 사용할 수 있는 1,3
	* D[i][2] = D[i-2][1] + D[i-2][3]
* D[i][3] = i를 1,2,3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 3
	* 바로 전에 사용할 수 있는 1,2
	* D[i][3] = D[i-3][1] + D[i-3][2]

**코드 (이해가 잘 안된다 ㅠㅡㅠ)**
```c++
#include <stdio.h>
long long d[1000001][4];
const long long mod = 1000000009LL;
const int limit = 100000;
int main() {
    for (int i=1; i<=limit; i++) {
        if (i-1 >= 0) {
            d[i][1] = d[i-1][2] + d[i-1][3];
            if (i == 1) {
                d[i][1] = 1;
            }
        }
        if (i-2 >= 0) {
            d[i][2] = d[i-2][1] + d[i-2][3];
            if (i == 2) {
                d[i][2] = 1;
            }
        }
        if (i-3 >= 0) {
            d[i][3] = d[i-3][1] + d[i-3][2];
            if (i == 3) {
                d[i][3] = 1;
            }
        }
        d[i][1] %= mod;
        d[i][2] %= mod;
        d[i][3] %= mod;
    }
    int t;
    scanf("%d",&t);
    while (t--) {
        int n;
        scanf("%d",&n);
        printf("%lld\n",(d[n][1] + d[n][2] + d[n][3])%mod);
    }
}
```
