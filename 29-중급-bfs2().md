# 1. 벽 부수고 이동하기4 https://www.acmicpc.net/problem/16946

* N x M 크기의 지도가 있다.     
* 0은 이동할 수 있는곳(빈칸), 1은 이동할 수 없는 곳(벽)을 의미한다.    
* 두 칸이 변을 공유할 때 인접하다고 말을 한다.   
* 각각의 변을 빈칸으로 바꾸고, 그 위치에서 이동할 수 있는 칸의 개수 10% 을 구하자   

```c++
#include <iostream>
#include <vector>
#include <string>
#include <queue>
#include <set>
#include <tuple>
using namespace std;
int n, m;
int a[1000][1000];
bool check[1000][1000];
int group[1000][1000];
vector<int> group_size;
int dx[] = {0,0,1,-1};
int dy[] = {1,-1,0,0};
void bfs(int sx, int sy) {
    int g = group_size.size(); // 처음에는 0이겠네
    cout << g << " ";
    queue<pair<int,int>> q; // 큐
    q.push(make_pair(sx,sy)); // 위치 넣고 돌리기
    check[sx][sy] = true; // true 변형
    group[sx][sy] = g; // 그룹번호.
    int cnt = 1; // 카운트
    while (!q.empty()) {
        int x, y; // 현재 x,y
        tie(x, y) = q.front(); q.pop();
        for (int k=0; k<4; k++) { // 4방향.
            int nx = x+dx[k];
            int ny = y+dy[k];
            if (0 <= nx && nx < n && 0 <= ny && ny < m) { // 범위내에 있으면
                if (a[nx][ny] == 0 && check[nx][ny] == false) { // 다음 갈곳이 0이고 안갔다면
                    q.push(make_pair(nx,ny)); // 다음 이동 가능
                    check[nx][ny] = true; // true 해주고
                    group[nx][ny] = g; // 그룹번호 넣어주고
                    cnt += 1; // 카운트 증가
                }
            }
        }
    }
    group_size.push_back(cnt); // 그룹에 카운트 넣는다.  -> bfs 시에 그룹 증가
    // 0일때 그룹
}
int main() {
    cin >> n >> m;
    for (int i=0; i<n; i++) {
        string s;
        cin >> s;
        for (int j=0; j<m; j++) {
            a[i][j] = s[j] - '0'; // 숫자로 입력
            check[i][j] = false; // false로 통일
            group[i][j] = -1; // 일단 그룹은 다 -1로
        }
    }
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (a[i][j] == 0 && check[i][j] == false) { // 0이고 false이면
                bfs(i, j); // bfs 돌린다.
            }
        }
    }
    
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (a[i][j] == 0) { // 0일 경우
                cout << 0; // 그냥 0 출력
            } else { // 1일 경우
                set<int> near; // 중복방지를 위한 set -> 한곳 검색하고 나머지 3곳에서 같은 범위내에 속한값은 지워줘야하니까.
                for (int k=0; k<4; k++) {
                    int x = i+dx[k]; // 4방향
                    int y = j+dy[k]; // 4방향 이동
                    if (0 <= x && x < n && 0 <= y && y < m) { // 범위내라면
                        if (a[x][y] == 0) { // 그리고 0이라면
                            near.insert(group[x][y]); // 그룹값 넣기 -> 중복을 넣어도 set 으로 처리안된다.
                        }
                    }
                }
                int ans = 1;
                for (int g : near) {
                    ans += group_size[g]; // 빈칸 그룹값을 추가로 넣어주는데 set을 했기에 중복되지는 않는다.
                }
                cout << ans%10;
            }
        }
        cout << '\n';
    }
    return 0;
}

```

# 2. 벽 부수고 이동하기2 https://www.acmicpc.net/problem/14442

* N x M 행렬로 이루어진 지도에서 (1,1)에서 (N,M)으로 최단거리로 이동하는 문제    
* 0은 이동할 수 있는곳(빈칸), 1은 이동할 수 없는 곳(벽)을 의미한다.    
* 단 벽은 k번까지만 이동 가능하다.  

```c++

```
