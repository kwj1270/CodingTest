그래프
=======================
다이나믹(점화식)과 브루트포스(모든 방법)는 어떤 하나의 방법과 같은 것인데     
그래프 알고리즘은 문제에 나와있는 상황을 그래프로 모델링 한다음 여러가지 알고리즘을 수행하는 것이다.   
     
그렇기에 알고리즘은 변하지 않고 어떻게 상황을 그래프로 만드는지가 중요한 부분이다.     

## 용어 설명  
    
* 자료구조의 일종     
* **점 :** 정점(Node, Vertex)
* **선 :** 간선(Edge): 정점간의 관계를 나타낸다.     
* G = (V,E)로 나타낸다.   

## 경로
경로가 의미하는 것은 하나의 정점에서 다른 정점까지 가는 간선의 연속을 의미한다.      
간선의 연속이라 한 이유는 계속 길이 있어야 하므로이다.       
   
* 정점 A에서 B로 가는 경로  
* A -> C -> D -> E -> B  
* A -> B 
* A -> C -> B 
* A -> C -> B -> E 
  
## 싸이클 

* 정점 A에서 다시 A로 돌아오는 경로  
* A -> C -> B -> A 
* A -> C -> E -> B -> A
* A -> C -> D -> E -> B-> A

```
이건 왠지 다이나믹같이 한단계 전이 A와 연결된 곳 까지만 가면 될 것 같은데?   
```

## 단순 경로와 단순 사이클  
  
* 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로/사이클  
* 특별한 말이 없으면, 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다.

## 방향 있는 그래프  

* A -> C 와 같이 간선에 방향이 있다.    
* A -> C 는 있지만, C -> A는 없다.        
       
방향이 없는 그래프도 존재하는데 이를 양방향 그래프라고도 한다.        
나중에 그래프를 저장하는 작업이 필요한데 이때 양방향 그래프를 방향이 있는 그래프로 전환해서 저장해야 한다.      
   

## 간선 여러개   

* 두 정점 사이에 간선이 여러 개 일수도 있다.      
* 아래 그림의 A-B는 연결하는 간선이 2개있다.           
* 두 간선은 서로 다른 간선이다.     
* 만약 최단거리를 구할 경우 긴 간선은 없다고 취급하고 계산하면 된다.   
* 일반적인 것은 아니고 그래도 특별한 처리를 해줘야한다.   

## 루프     
  
* 간선의 양 끝 점이 같은 경우가 있다.     
* A -> A

## 가중치     
      
* 간선에 가중치가 있는 경우에는         
* A에서 B로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등등등....     
* 가중치란 간선에 쓰여있는 값이라고 보면 된다. (이동하는 거리)  
* 가중치가 없는 경우도 있는데 이 같은 경우는 1이라고 생각을 해주면 된다.  

## 차수  

* 정점과 정점에 연결되어 있는 간선의 개수 (그 정점에 연결된 간선의 개수 -> 정점마다 차수가 다르다)    
* 5의 차수 : 3
* 4의 차수 : 4 
* 방향이 있는 그래프의 경우에는 IN-DEGREE와 OUT-DEGREE로 나누어서 차수를 계산할 수 있다.     
* IN-DEGREE는 해당 정점으로 들어오는 간선의 갯수
* OUT-DEGREE는 해당 정점에서 나가는 간선의 갯수   

## 그래프로 모델링을 할 수 있는것들  
1. 지하철     
역이 정점 역과 역사이의 통로가 간선         
2. 도로        
교차로가 정점 교차로에서 교차로로 가는 도로가 간선       
3. 친구관계  
사람이 정점이고 사람과 사람이 친구면 간선 사람과의 관계(친구의 수)는 차수        
(인스타그램의 팔로우 팔로워가 바로 이러한 방향그래프의 원리를 이용했다.)        

# 그래프의 표현 (그래프의 저장)    
그림을 저장하겠다는 얘기가 아니고 그래프의 정점과 간선을 저장하는 것이다.     
     
* 아래와 같은 그래프는 정점이 6개, 간선이 8개 있다.      
* 간선에 방향이 없기 때문에, 방향이 없는 그래프이다.   
* 정점 : {1,2,3,4,5,6}  
(정점은 정점의 수만 저장하면 된다. -> 1부터 6이 아니면 1부터 6으로 바꿔주면 된다. 강남-1 역삼-2 등등)          
* 간선 : {(1,2), (1,5), (2,5), (2,3), (3,4), (2,4), (4,5), (4,6)} -> 1차원 배열에 쭉 저장하는 방법          
(사실상 6개의 정점을 통해 8개 간선을 만드는 일은 무수히 많은 경우의 수를 따진다)           
(그렇기에 그래프를 저장하는 것이 바로 간선을 저장하는 방법을 의미한다.)         
    
**그래프의 저장 방법**  
1. 인접 행렬     
2. 인접 리스트    
1차원 배열에 쭉 저장하는 방법을 사용하지 않고 위와 같은 방법 2가지로 사용하는 이유는?   
어떤 효율의 문제가 생기기 때문이다.   
그래프 저장 방법에서 효율이란 것은 한 정점 x와 연결된 간선을 효율적으로 찾는 구조를 만드는 것이다.  

일단 위 구조가 어떻게 동작하지는 모르지만       
{(1,2), (1,5), (2,5), (2,3), (3,4), (2,4), (4,5), (4,6)} 같은 경우는         
어떤 하나의 정점과 연결되어 있는 간선을 모르면 모든 간선을 살펴봐야하기 때문이다.     


# 인접 행렬       
           
* 정점의 개수를 V라고 했을 때       
* V x V 크기의 이차원 배열을 이용한다.           
* A[i][j] = 1(i->j 간선이 있을때), 0(없을 때)         
  
**방향이 없는 그래프**       
방향이 없는 그래프는 이 방향과 저 방향 2개로 나누어서 저장하자     
예를 들어 1이랑 5가 연결되어 있으면 ```A[0][4] = 1```, ```A[4][0] = 1```     
    
**가중치가 있는 그래프(방향 없을때)**        
가중치가 있는 그래프는 1대신에 **가중치**를 넣어주면 된다.         
A[i][j] = **w**(i->j 간선이 있을때), 0(없을 때) ```A[0][4] = 7```, ```A[4][0] = 7```        

**이로 알 수 있는 사실**   
정점 V개, 간선 E개라고 가정을 하면           
공간은 V^2이라는 것을 알 수 있고       
한 정점에 연결된 간선을 구하는 방법의 수는 V 이다.     
예를 들면 2에 대한 간선을 구하는 것은 A[2][ 0 ~ 끝까지] 이므로이다.      


# 인접 리스트  
* 리스트를 이용해서 구현한다.      
* A[i] = (i와 연결된 정점을 리스트로 포함하고 있다.)     
   
**방향이 없는 그래프**          
A[1] 2 5    
A[2] 1 3 4 5   
A[3] 2 4     
A[4] 3 5 2 6     
A[5] 1 2 4    
A[6] 4   
     
**가중치가 있는 그래프(방향 없을때)**          
가중치와 같이 묶어서 저장하는 방식을 이용하자     
A[1] (2,**2**) (5,**7**)     
A[2] (1,**2**) (3,**2**) (4,**3**) (5,**1**)   
A[3] (2,**2**) (4,**1**)      
A[4] (3,**1**) (5,**7**) (2,**3**) (6,**7**)     
A[5] (1,**7**) (2,**1**) (4,**7**)   
A[6] (4,**7**)      
연결된 방식만 기입하기 때문에 0의 값을 나오지 않는다.   
  
* 리스트는 크기를 동적으로 변경할 수 있어야 한다.    
* 링크드 리스트나 길이를 동적으로 변경할 수 있는 배열을 사용한다.   

# 공간 복잡도 
* 인접 행렬 O(V^2)   
* 인접 리스트 O(E) - 간선의 갯수  
그렇다면 효율에 대해서 얘기했을때 한 정점과 연결된 모든 간선을 찾는 시간은? -> 차수와 같다.     
   
그렇기에 인접 행렬보다 인접 리스트가 공간 및 시간을 더욱 아낄 수 있고 우리는 인접 리스트만 사용할 것이다.  
인접 행렬이 인접 리스트보다 뛰어난 부분은 간선이 있는지 없는지 걸리는 시간에서만이다.    
   
# 간선 리스트  
* 배열을 이용해서 구현한다.         
* 간선을 모두 저장하고 있다.         
* 라이브러리를 이용하기 싫은 사람이 쓰는 방법이다 ㅎㅎ;;    
* E라는 배열에 간선을 모두 저장      
       
E[0] = 1 2      
E[1] = 1 5     
E[2] = 2 3    
E[3] = 2 4    
E[4] = 2 5    
E[5] = 5 4    
E[6] = 4 3    
E[7] = 4 6    
E[8] = 2 1    
E[9] = 5 1     
E[10] = 3 2      
E[11] = 4 2    
E[12] = 5 2     
E[13] = 4 5    
E[14] = 3 4      
E[15] = 6 4      
   
      
방법의 한가지 특색이 있는데 바로 앞 정점을 기준으로 정렬을 진행해주어야 한다.  
그 다음에 앞에 정점이 몇개 있는가를 cnt[] 베열에 넣는다.  
```
for (int i=0; i<m; i++){
     cnt[e[i][0]] += 1;
}
```
만약 e의 첫 번째 글자가 1이라면 cnt[1] +=1 동작  
만약 e의 첫 번째 글자가 2이라면 cnt[2] +=1 동작  

* cnt[0] 0   
* cnt[1] 2      
* cnt[2] 4   
* cnt[3] 2   
* cnt[4] 4    
* cnt[5] 3     
* cnt[6] 1         
     
         
cnt 배열을 앞에서부터 누적해준다.  
```
for (int i=0; i<m; i++){
     cnt[i] = cnt[i-1] + cnt[i];
}
```
* cnt[0] 0   
* cnt[1] 2      
* cnt[2] 6   
* cnt[3] 8   
* cnt[4] 12    
* cnt[5] 15     
* cnt[6] 16   

그러면 이제 아주 놀라운 일이 생기는데   
cnt에는 각각의 갯수가 들어있는 것이 아니라 겹쳐져서 들어간 값으로      

2번 값을 구하고 싶으면 cnt[2] - cnt[1] 의 형태로 구하면 된다.          
* i번 정점과 연결된 간선은  
* E 배열에서 cnt[i-1] 부터 cnt[i]-1 까지이다.  
* O(차수)   

즉, 6-2를 하면 2번과 연결된 차수는 4개라는 뜻이고    
cnt[1] 부터 ~ 5까지    
2 부터 5까지의 인덱스를 사용하면 된다는 뜻이다.  
    
# 연결 요소
* 그래프가 아닌 그림 같이 나누어져 있지 않은 경우가 있을 수도 있다.         
* 이렇게 나누어진 각각의 그래프를 연결 요소라고 한다.           
* 연결 요소에 속한 모든 정점을 연결하는 경로가 있어야 한다.           
* 또, 다른 연결 요소에 속한 정점과 연결하는 경로가 있으면 안된다.          
* 아래 그래프는 총 2개의 연결 요소로 이루어져 있다.  
* 연결 요소를 구하는 것은 DFS나 BFS탐색을 이용해서 구할 수 있다.   
* 탐색이 한번 완료후 새로 시작한다면 연결 요소가 2개 이상이라는 뜻이다.  

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>

using namespace std;
vector<int> list[10001];
bool check[10001];

int n; // 정점의 개수
int m; // 간선의 개수  
void dfs(int x){
	check[x] = true;
	for(int i=0; i < list[x].size(); i++){
		int y = list[x][i];
		if(check[y] == false){
			dfs(y);		
		}
	}
}
void bfs(int start){
	queue <int> q;
	q.push(start);
	check[start] = true;
	while(!q.empty()){
		int x = q.front(); q.pop();
		for(int i=0; i < list[x].size(); i++){
			int y = list[x][i];
			if(check[y] == false){
				check[y] = true;
				q.push(y);
			}
		}
	}
}
int main(void)
{
	cin >> n >> m;  
	
	for(int i=0; i < m; i++){
		int u, v;
		cin >> u >> v;
		list[u].push_back(v);
		list[v].push_back(u);
	}

	for (int i=1; i<=n; i++) {
        sort(list[i].begin(), list[i].end());
    }
	
	int cnt = 0;
	for(int i=1; i <= n; i++){
		if(check[i] == false){
			dfs(i); // bfs(i);
			cnt++;
		}
	}
	cout << cnt << "\n";
	return 0;
}
     
```

# 이분 그래프   
* 그래프가 2개로 나누어진 그래프      
* 한쪽과 다른 한쪽으로 나누어져 있어서     
* 모든 간선이 A 와 B사이에 만 있는 그래프        
* 예를 들면 여러 사람이 여러 물건중 하나를 선택하는 구조      
* 다른 예로 학생이 수업을 수강신청하는 구조    
* 그래프를 다음과 같이 A와 B로 나눌 수 있으면 이분 그래프라고 한다.   
* A 에 포함되어 있는 정점끼리 연결된 간선이 없음  
* B 에 포함되어 있는 정점끼리 연결된 간선이 없음 
* 모든 간선의 한 끝 점은 A에, 다른 끝점은 B에

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <stack>
#include <queue>

using namespace std;

vector<int> a[20001];
int color[20001]; // boolean 타입이 아니다. 즉, 해당 위치가 어떤 색깔인지를 나타낸다.   

void dfs(int node, int c) { // 기존 dfs에서 c가 추가되었다. 왜지?  
    color[node] = c; // color를 따지는구나 -> 색깔을 넣기위해서 
    for (int i=0; i<a[node].size(); i++) { // 기존 dfs
        int next = a[node][i]; // 기존 dfs
        if (color[next] == 0) { // 다음 이동할 곳에 색이 채워지지 않았다면?  
            dfs(next, 3-c); // 3-c를 한다.
			// c == 1 -> 2
			// c == 2 -> 1

			// c == 3 -> 0
			// c == 0 -> 3
         
			// 2나 1을 넣었을때는 1또는2 
			// 2이나 0을 넣었을때는 0또는3 이 나오는 이분법 계산이 가능하다.  
		}
    }
}
int main() {
    int t; // 입력받기 
    cin >> t;
    while (t--) {
        int n, m;
		cin >> n >> m;
		/// 초기화 구문 /// 
		for (int i=1; i<=n; i++) {
            a[i].clear(); // 값 초기화 // 2회 돌리므로 
            color[i] = 0; // 모든 색깔 0으로 초기화  // 2회 돌리므로 
        }
		/// 간선 입력 구문 (방향x)/// 
        for (int i=0; i<m; i++) {
            int u,v;
			cin >> u >> v;
            a[u].push_back(v); // 양방향 
            a[v].push_back(u); // 양방향  
        }
        for (int i=1; i<=n; i++) {
            if (color[i] == 0) {
                dfs(i, 1);
            }
			// 연결 요소 처리 방식 사용 
			// 모든 색깔을 채울때까지 돌릴것이다.
        }
        bool ok = true; // ok는 우선 트루  
        for (int i=1; i<=n; i++) { // 1~n -> 각 정점 한번씩 돌것입니다.     
            for (int k=0; k<a[i].size(); k++) { // 인접리스트 순회할 것입니다.  
				int j = a[i][k]; // next 이동  
                if (color[i] == color[j]) { // 다음에 이동할 곳이 색깔이 같으면 
                    ok = false; // 문제있다 판단
					// 이분법은 연결된 것들끼리 서로 달라야 합니다.
					// 그렇기에 1 다음에 3 5 가 있다 하더라도
					// 그들은 1과 색깔이 달라야 하겠지요  
                }
            }
        }
        printf("%s\n",ok ? "YES" : "NO");
    }
    return 0;
}
```
