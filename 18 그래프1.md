그래프1
=======================
다이나믹(점화식)과 브루트포스(모든 방법)는 어떤 하나의 방법과 같은 것인데     
그래프 알고리즘은 문제에 나와있는 상황을 그래프로 모델링 한다음 여러가지 알고리즘을 수행하는 것이다.   
     
그렇기에 알고리즘은 변하지 않고 어떻게 상황을 그래프로 만드는지가 중요한 부분이다.  

## 1.1 그래프  
    
* 자료구조의 일종     
* **점 :** 정점(Node, Vertex)
* **선 :** 간선(Edge): 정점간의 관계를 나타낸다.     
* G = (V,E)로 나타낸다.   

## 1.2. 경로
경로가 의미하는 것은 하나의 정점에서 다른 정점까지 가는 간선의 연속을 의미한다.      
간선의 연속이라 한 이유는 계속 길이 있어야 하므로이다.       
   
* 정점 A에서 B로 가는 경로  
* A -> C -> D -> E -> B  
* A -> B 
* A -> C -> B 
* A -> C -> B -> E 
  
## 1.3. 싸이클 

* 정점 A에서 다시 A로 돌아오는 경로  
* A -> C -> B -> A 
* A -> C -> E -> B -> A
* A -> C -> D -> E -> B-> A

```
이건 왠지 다이나믹같이 한단계 전이 A와 연결된 곳 까지만 가면 될 것 같은데?   
```

## 1.4. 단순 경로와 단순 사이클  
  
* 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로/사이클  
* 특별한 말이 없으면, 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다.

## 1.5. 방향 있는 그래프  

* A -> C 와 같이 간선에 방향이 있다.    
* A -> C 는 있지만, C -> A는 없다.        
       
방향이 없는 그래프도 존재하는데 이를 양방향 그래프라고도 한다.        
나중에 그래프를 저장하는 작업이 필요한데 이때 양방향 그래프를 방향이 있는 그래프로 전환해서 저장해야 한다.      
   

## 1.6. 간선 여러개   

* 두 정점 사이에 간선이 여러 개 일수도 있다.      
* 아래 그림의 A-B는 연결하는 간선이 2개있다.           
* 두 간선은 서로 다른 간선이다.     
* 만약 최단거리를 구할 경우 긴 간선은 없다고 취급하고 계산하면 된다.   
* 일반적인 것은 아니고 그래도 특별한 처리를 해줘야한다.   

## 1.7. 루프     
  
* 간선의 양 끝 점이 같은 경우가 있다.     
* A -> A

## 1.8. 가중치     
      
* 간선에 가중치가 있는 경우에는         
* A에서 B로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등등등....     
* 가중치란 간선에 쓰여있는 값이라고 보면 된다. (이동하는 거리)  
* 가중치가 없는 경우도 있는데 이 같은 경우는 1이라고 생각을 해주면 된다.  

## 1.9. 차수  

* 정점과 정점에 연결되어 있는 간선의 개수 (그 정점에 연결된 간선의 개수 -> 정점마다 차수가 다르다)    
* 5의 차수 : 3
* 4의 차수 : 4 
* 방향이 있는 그래프의 경우에는 IN-DEGREE와 OUT-DEGREE로 나누어서 차수를 계산할 수 있다.     
* IN-DEGREE는 해당 정점으로 들어오는 간선의 갯수
* OUT-DEGREE는 해당 정점에서 나가는 간선의 갯수   

## 그래프로 모델링을 할 수 있는것들  
1. 지하철     
역이 정점 역과 역사이의 통로가 간선         
2. 도로        
교차로가 정점 교차로에서 교차로로 가는 도로가 간선       
3. 친구관계  
사람이 정점이고 사람과 사람이 친구면 간선 사람과의 관계(친구의 수)는 차수        
(인스타그램의 팔로우 팔로워가 바로 이러한 방향그래프의 원리를 이용했다.)        

***
# 2. 그래프의 표현 (그래프의 저장)    
그림을 저장하겠다는 얘기가 아니고 그래프의 정점과 간선을 저장하는 것이다.     
     
* 아래와 같은 그래프는 정점이 6개, 간선이 8개 있다.      
* 간선에 방향이 없기 때문에, 방향이 없는 그래프이다.   
* 정점 : {1,2,3,4,5,6}  
(정점은 정점의 수만 저장하면 된다. -> 1부터 6이 아니면 1부터 6으로 바꿔주면 된다. 강남-1 역삼-2 등등)          
* 간선 : {(1,2), (1,5), (2,5), (2,3), (3,4), (2,4), (4,5), (4,6)} -> 1차원 배열에 쭉 저장하는 방법          
(사실상 6개의 정점을 통해 8개 간선을 만드는 일은 무수히 많은 경우의 수를 따진다)           
(그렇기에 그래프를 저장하는 것이 바로 간선을 저장하는 방법을 의미한다.)         
    
**그래프의 저장 방법**  
1. 인접 행렬     
2. 인접 리스트    
1차원 배열에 쭉 저장하는 방법을 사용하지 않고 위와 같은 방법 2가지로 사용하는 이유는?   
어떤 효율의 문제가 생기기 때문이다.   
그래프 저장 방법에서 효율이란 것은 한 정점 x와 연결된 간선을 효율적으로 찾는 구조를 만드는 것이다.  

일단 위 구조가 어떻게 동작하지는 모르지만       
{(1,2), (1,5), (2,5), (2,3), (3,4), (2,4), (4,5), (4,6)} 같은 경우는         
어떤 하나의 정점과 연결되어 있는 간선을 모르면 모든 간선을 살펴봐야하기 때문이다.     

***
# 3. 인접 행렬    
    
* 정점의 개수를 V라고 했을 때    
* V X V 크기의 이차원 배열을 이용한다.         
* A[i][j] = 1(i->j 간선이 있을때), 0(없을 때)      


