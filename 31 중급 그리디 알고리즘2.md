# 31 중급 그리디 알고리즘2
## 보석 도둑 https://www.acmicpc.net/problem/1202
* 상덕이가 보석 훔치려함
* 보석 종류 n
* 무게 M
* 가격 V
* 가방에 담을 수 있는 최대 무게 C
* 각 가방에는 **1개**만 넣을 수 있음

**입력**
```c++
3 2 // 종류, 가방 갯수 
1 65 // 무게 1의 보석은 65가격 
5 23 // 무게 5의 보석은 23가격
2 99 // 무게 2의 보석은 99가격 
10 // 가방의 최대량
2 // 가방2의 최대량
```

**출력**
```c++
164
```
* 2개 넣을 수 있는데 1개만 넣을 수 있으므로 2가 가장 좋고     
* 10개 넣을 수 있는데 1개만 넣을 수 있으므로 1이 가장 좋다.   
    
**내 생각**     
* 우선 가방을 정렬시킨다.        
* 보석을 무게순으로 정렬시킨다.           
* 큐를 이용하여 무게순으로 값을 넣는다.          
* 한바퀴 돌면서 최대값을 찾는다. 단 무게 이상이 나오면 break    
* 구하는 방법은 top()으로 비교하고 pop, push로 뒤로 넣기
* 최대값인 친구만 pop하기      
* 다시 가방 개수만큼 반복한다.   

**정답**  
2가지 방법 존재
1. 가방 기준
  1. 각각의 보석이 있을때 어떤 가방에 들어갈지 좋을지 찾음
2. 보석 기준
  1. 각각의 보석이 있을때 어떤 가방에 들어갈지 좋을지 찾음
* 각 가방에는 보석이 1개만 들어갈 수 있기에 가격이 큰 보석을 최대한 많이 가져가는것이 좋다.   
* 보석(무게, 가격) -> (2, 99) (1, 65) (5,23) -> 가격 기준 오름차순
* 가방 -> 정렬 -> 2, 10 -> 무게 기준 오름차순
* 2, 99는 어디에 들어가는게 좋을까?       
  * 최대 무게가 2인 가방에 들어가는 것이좋다.   
  * 뒤에 가격의 가치는 낮지만 무거운 것이 들어있을 수도 있다.   
  * 즉, 10에 들어간다면 2에는 (5, 65) (1,23)가 오면서 낭비가 되기 때문이다.   
  * 다르게 보면 최대 자신의 무게와 가까운곳에 들어가는 것이 좋다.   
* 가격이 높은 보석부터 차례대로 각 보석을 담을 수 있는 가방 중 `c[i]`가 가장 작은 가방에 넣는다.   
* 이를 구현하기 위해서 다음을 효율적으로 할 수 있는 자료구조가 필요하다   
   
1. 어떤수 x보다 큰 숫자 중에 가장 작은 수를 찾는다.   
2. 수를 지운다.   

정답은 BST : 이진 트리 알고리즘    
c++ 은 multiset을 이용하면 된다.     
  
# 가방 기준  
```c++
#include <cstdio>
#include <vector>
#include <algorithm>
#include <set>
using namespace std;
struct jewel {
    int m, v;
};

int main() {
    int n,k;
    scanf("%d %d",&n,&k);
    vector<jewel> a(n);
    
    for (int i=0; i<n; i++) {
        scanf("%d %d",&a[i].m, &a[i].v); // 보석 입력 받음
    }
    
    sort(a.begin(), a.end(), [](jewel u, jewel v) { // 정렬 시작 내림차순
        return u.v > v.v;
    });
    
    multiset<int> s; // 같은것이 들어갈 수 있는 것, 자동 오름차순 정렬
    for (int i=0; i<k; i++) {
        int t;
        scanf("%d",&t); // 가방 입력 받음
        s.insert(t); // set에 입력 중복 없애기 위해서인가.
    }
    
    long long ans = 0; // 결과
    for (int i=0; i<n; i++) { // 가격이 가장 높은 보석부터 시작, 2 -> 1 -> 5
        auto it = s.lower_bound(a[i].m); // 무게가 있는 인덱스를 찾음 -> 없으면 근접한 상위 리턴
        // 맨처음 2를 찾는다.
        // 2가 있으므로 2에 대한 it 반환
        // 그다음 1을 찾는다.
        // 1에 가장 가까운 큰수를 찾는다.   
        // 10밖에 안남았으므로 10을 리턴
        // 즉 가장 가까운 가방의 무게를 찾는다.
        if (it != s.end()) { // 존재하지 않으면 it는 end()인데 이는 존재한다는 뜻.
            ans += a[i].v; // 결과에 값 넣음
            s.erase(it); // 해당 지움
        }
        // 존재하지 않다는 것은 일단 넘기는 것
    }
    
    printf("%lld\n",ans);
    return 0;
}
```
* **O(nlogK)**
* 보석을 찾는데 걸리는 시간 logK(lower_bound)
* 있으면 지우는데 걸리는 시간 logK(erase)
* N번 돌때마다 있으므로
* 실은 n`*`(2`*`logK)이지만 O(nlogK)이다. (k는가방 갯수)     

뭔가 석연찮아서 예제를 바꿔서 이해해보겠습니다.    
```c++
가방 : 3 4
1 60
4 50
3 14
```
만약 1이 4에 들어간다면 후에 4는 가방에 못들어가는 문제가 생기고 대신 3이 가방에 들어갑니다.     
그렇기에 무게가 가장 큰 순으로 푸는 것은 맞지만 **가장 가까운 가방에 들어가야 한다는 것입니다.**   
알고리즘은 단순히 무게 알고리즘에서 **가방에 넣는 방식을 더해준 방법입니다.**    

# 무게 기준 
* 각각의 가방에 대해서 좋은 보석을 찾는 방법       
* 각각의 보석의 무게를 기준과 가방을 합쳐서 오름차순 정렬      
* `(1,65) (2,99) 2 (5,23) 10` 가방앞에 있는 것은 들어갈 수 있는 보석
* 즉 가방 앞에 있는 값들을 비교해서 사용하면 된다.   
* 후보를 만들고 해당 후보에서 가장 큰값을 뻬서 사용하면된다.   
* 큐를 이용하는 것 같은데  
* 맞다 우선순위 큐를 이용한것이다.   

```c++
#include <queue>
#include <algorithm>
#include <vector>
#include <cstdio>
using namespace std;
struct jewel {
    int m,v,w;
};
int main() {
    int n,k;
    scanf("%d %d",&n,&k);
    vector<jewel> a(n+k);
    
    for (int i=0; i<n; i++) {
        scanf("%d %d",&a[i].m,&a[i].v); // 무게와 값 입력
    }
    
    for (int i=0; i<k; i++) {
        scanf("%d",&a[i+n].m); // 가방 입력
        a[i+n].w = 1; // 가방의 가중치?
    }
    // 아 위에 있는 것들은 가중치가 0이므로 같은 값이 나오면 뒤로 보내기 위해서이다.
    
    sort(a.begin(), a.end(), [](jewel u, jewel v) {
        return u.m < v.m || (u.m == v.m && u.w < v.w); // 무게가 작으면 앞으로 또는 무게는 같지만 우선순위가 작은 걸 앞으로
    });
    
    priority_queue<int> q; // 우선순위 큐 -> 정렬된 큐인가?
    long long ans = 0; //
    for (auto &p : a) { // 정렬된 배열 하나씩 빼기
        if (p.w == 0) {
            q.push(p.v); // 0인 경우 가방이 아니니 큐에 값만 넣기.
        } else {
            if (!q.empty()) { // 아니고 후보가 비어있지 않다면
                ans += (long long)q.top(); // 가장 위에 있는 값 빼기
                q.pop(); // 큐 팝
            }
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```
* **O(nlogn)**
* 큐에 넣고 빼기 logN
* 최대 N 더하기 K(가방 개수) 만큼 정렬하고 사용하므로 
* O(N+k)(logN)
* 참고로 log는 숫자가 클수록 좋은 것이여서 위 결과보다 값이 좋다.   
     
* 배운점 
    * multiset : 중복가능, 2진트리임, 오름차순 정렬 (위에서는 가방 오름차순 정렬), 가장 중간 값이 맨위임
    * lower_bound : a.lower_bound(b) 를 하면 a에서 b를 찾고 없으면 b와 가장 근접한 큰값을 a에서 찾음   
    * priority_queue : 우선순위 큐: 디폴트로 가장 큰 값이 루트에 있음 
    
# 순회강연 문제 
* N개의 대학에서 강연 요청
* 강연 요청은 D일 안에 하면 된다는 조건과 p 강의료로 구성되어 있다.   
* 하루에 최대 한곳에만 강연을 할 수 있다고 가정했을 때   
* 최대 수익을 구하는 문제   

**내 생각**     
* 우선 큰 착각을 한게 해당 날짜에서만 강의를 한다고 생각했다. 즉 3이면 3일에만 하는줄 알았다.           
* 날짜별로 정렬을 한다.
* map을 사용하여 동일한 날자일때 더 큰값으로 덮어쓰기를 진행한다.             
* 이후 map을 순회하며 값을 가져온다.   

**정답**
* 3이라고 주어지면 3일 안에 하면 되는 것이다.   
* 오름차순으로 시작할시 3일에 해도 되는 것은 1일에 해도되는데 이를 계산하지 못한다.   
* 그렇기에 내림차순으로 시작하여 `N일 까지` 할 수 있는 것들을 구하고
* 이들을 후보에 넣은 다음 하루 마다 가장 큰 값을 반환토록한다.    
* 우선 이를 위해서 날짜가 큰값대로 내림차순 정렬을 한다.   
* 2일까지 해야하는 일은 3일에 하지못하므로 3일까지 해야할 일들만 순회하도록 해야한다.  
* day 순으로 정렬이 되었기에 같은 day를 전부 순회하기 위해 while을 사용한다.   
* 순회하면서 모든 값들을 후보키에 넣고
* 순회가 끝나면 그중 최대값만 넣는다.   
* 2일차라고 가정했을시 3에 있는 값도 3일까지이므로사용할 수 있으니 큐는 초기화하지 않는다.   
* 이렇게 2랑 1도 해준다.   
    
```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
struct Lecture {
    int p, d;
};
bool cmp(const Lecture &u, const Lecture &v) {
    return u.d > v.d;
}
int main() {
    int n;
    cin >> n;
    vector<Lecture> a(n);
    for (int i=0; i<n; i++) {
        cin >> a[i].p >> a[i].d;
    }
    sort(a.begin(),a.end(),cmp);
    int k=0;
    priority_queue<int> q;
    int ans = 0;
    
    // a는 날짜가 큰값부터 정렬되어 있다.
    // 즉 k는 a를 위한 인덱스
    // i가 3이라 할때
    // a에 있는 모든 3의 요소들을 넣는다.
    // 가장 위에있는 값을 넣어준다.
    // 그런데 왜 이렇게 했냐면
    // 3이라는 것은 3일안에만 하면 되기에
    // 2일에서 해도되고 1일에서도 해도된다.
    // i가 2일때도 해도 된다는 뜻이다.
    // d==2 일때까지만 k를 증가시킨다.
    // 이제 3에서 나왔던 값들과 2에서 나온값들중 최대값을 넣느다.
    // 1도 마찬가지이다.
    for (int i=10000; i>=1; i--) {
        while (k<n && a[k].d == i) { // 3일부터라 치면
            q.push(a[k].p);
            k += 1;
        }
        if (!q.empty()) {
            ans += q.top();
            q.pop();
        }
    }
    cout << ans << '\n';
    return 0;
}
```

# 가장 긴 증가하는 부분 수열3 LIS
* 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오   
* 예를 들어 수열  `A = {10,20,10,30,20,50}` 인 경우에 가장 긴 증가하는 부분 수열은    
`A={10,20,30,50}`이고, 길이는 4이다.  
* 기존 방식은 dp를 사용하면 되겠지만 제한 조건이 `N (1 ≤ N ≤ 1,000,000)`이므로 최소 `O(N)`으로 풀어야한다.     
    
우선 이를 풀기 위해서 `가장 긴 증가하는 부분 수열2`를 통해서 먼저 풀어보자
모든 방식을 동원해서 풀면은 시간이 정말 오래걸린다. (N^2)    
그래서 어떻게 해야하지?      
1차원 배열과 이진 탐색 lower_bound()를 사용하면 된다.   

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> a;
    for (int i=0; i<n; i++) {
        int num;
        cin >> num; // 하나씩 입력 받음
        auto it = lower_bound(a.begin(), a.end(), num); // a안에 num에 대해 크거나 같은 값이 있냐
        if (it == a.end()) { // 아에 없으면
            a.push_back(num); // a에 넣는다.
        } else {
            // it는 a의 어떤 부분을 가리키는데
            // num과 같거나 큰 값에 들어있다.
            // 그렇기에 num을 넣는것은 최소값으로 갱신하는 것이다.
            *it = num; // 해당 위치에 num 넣는다.
        }
    }
    cout << a.size() << '\n'; // 단 해당 코드는 길이만 구할 수 있다.
    // 5671 이라고 가정한다면
    // 167이 되는데 이는 값이 아니다.
    // 실제로는 567이 되어야 한다.
    // 그렇다면 어떻게?
    // 앞에 값이 무엇인지 기록한다.
    // 567 -> -1 0 1
    // 167 -> -1 0 1
    // 즉, 5671 -> -1 0 1 -1 인 형태고
    // 가장 큰 인덱스부터 차례로 내려오면서 더 큰값을 가져온다.
    // 7 -> 6 -> 5랑 1비교 -> 5 -> 567.  
    return 0;
}
```
* `10 20 10 30 20 50` 이었다고 가정하면
* 10
* 10 20 (20 없으므로 추가)
* 10 20 (10 있으므로 똑같음)
* 10 20 30 (30 없으므로 추가)
* 10 20 30 (20 있으므로 똑같음)
* 10 20 30 50 (50 없으므로 추가)    
    
이러한 결과가 나온다.        
하지만 큰 문제가 있는데 이는 길이만 구할 때 사용된다.        
예를 들면 `A={5,6,7,1}`일 경우를 따져보자 
   
* 5,6,7 없으므로 {5,6,7} 까지는 잘온다     
* 1이 오면 lower_bound로 인하여 5의 위치가 리턴되어 {1,6,7}이 된다.      
* 길이만 따지면 정답이지만 형태가 {5,6,7}이 정답인데 {1,6,7}이 된다.      
    
그렇다면 길이 말고 형태까지 정답을 출력하고 싶다면 어떻게 할까?    
추적과 값 비교를 이용하면 된다.   

* 5가 들어갈시 인덱스가 없으므로 -1 가짐 
* 6 앞에 인덱스가 있으므로 6의 인덱스(1)-1 인 0을 가짐
* 7 앞에 인덱스가 있으므로 7의 인덱스(2)-1 인 1을 가짐 
* 1 은 lower_bound로 인해 0번째 인덱스로 감, 앞에 인덱스가 없으니 -1을 가짐 
* 가장 큰 값 7부터 추적을 하여 들어감 7 -> 6 -> ?
* 동일한 값을 가진 경우 더 큰값으로 이동한다.  7-> 6 -> 5   
* 이를 역으로 출력하면 567이 된다.      
 
****





  






