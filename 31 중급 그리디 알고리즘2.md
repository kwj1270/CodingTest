# 31 중급 그리디 알고리즘2
## 보석 도둑 https://www.acmicpc.net/problem/1202
* 상덕이가 보석 훔치려함
* 보석 종류 n
* 무게 M
* 가격 V
* 가방에 담을 수 있는 최대 무게 C
* 각 가방에는 **1개**만 넣을 수 있음

**입력**
```c++
3 2 // 종류, 가방 갯수 
1 65 // 무게 1의 보석은 65가격 
5 23 // 무게 5의 보석은 23가격
2 99 // 무게 2의 보석은 99가격 
10 // 가방의 최대량
2 // 가방2의 최대량
```

**출력**
```c++
164
```
* 2개 넣을 수 있는데 1개만 넣을 수 있으므로 2가 가장 좋고     
* 10개 넣을 수 있는데 1개만 넣을 수 있으므로 1이 가장 좋다.   
    
**내 생각**     
* 우선 가방을 정렬시킨다.        
* 보석을 무게순으로 정렬시킨다.           
* 큐를 이용하여 무게순으로 값을 넣는다.          
* 한바퀴 돌면서 최대값을 찾는다. 단 무게 이상이 나오면 break    
* 구하는 방법은 top()으로 비교하고 pop, push로 뒤로 넣기
* 최대값인 친구만 pop하기      
* 다시 가방 개수만큼 반복한다.   

**정답**  
2가지 방법 존재
1. 가방 기준
  1. 각각의 보석이 있을때 어떤 가방에 들어갈지 좋을지 찾음
2. 보석 기준
  1. 각각의 보석이 있을때 어떤 가방에 들어갈지 좋을지 찾음
* 각 가방에는 보석이 1개만 들어갈 수 있기에 가격이 큰 보석을 최대한 많이 가져가는것이 좋다.   
* 보석(무게, 가격) -> (2, 99) (1, 65) (5,23) -> 가격 기준 오름차순
* 가방 -> 정렬 -> 2, 10 -> 무게 기준 오름차순
* 2, 99는 어디에 들어가는게 좋을까?       
  * 최대 무게가 2인 가방에 들어가는 것이좋다.   
  * 뒤에 가격의 가치는 낮지만 무거운 것이 들어있을 수도 있다.   
  * 즉, 10에 들어간다면 2에는 (5, 65) (1,23)가 오면서 낭비가 되기 때문이다.   
  * 다르게 보면 최대 자신의 무게와 가까운곳에 들어가는 것이 좋다.   
* 가격이 높은 보석부터 차례대로 각 보석을 담을 수 있는 가방 중 `c[i]`가 가장 작은 가방에 넣는다.   
* 이를 구현하기 위해서 다음을 효율적으로 할 수 있는 자료구조가 필요하다   
   
1. 어떤수 x보다 큰 숫자 중에 가장 작은 수를 찾는다.   
2. 수를 지운다.   

정답은 BST : 이진 트리 알고리즘    
c++ 은 multiset을 이용하면 된다.     
  
```c++
#include <cstdio>
#include <vector>
#include <algorithm>
#include <set>
using namespace std;
struct jewel {
    int m, v;
};

int main() {
    int n,k;
    scanf("%d %d",&n,&k);
    vector<jewel> a(n);
    
    for (int i=0; i<n; i++) {
        scanf("%d %d",&a[i].m, &a[i].v); // 보석 입력 받음
    }
    
    sort(a.begin(), a.end(), [](jewel u, jewel v) { // 정렬 시작 내림차순
        return u.v > v.v;
    });
    
    multiset<int> s; // 같은것이 들어갈 수 있는 것, 자동 오름차순 정렬
    for (int i=0; i<k; i++) {
        int t;
        scanf("%d",&t); // 가방 입력 받음
        s.insert(t); // set에 입력 중복 없애기 위해서인가.
    }
    
    long long ans = 0; // 결과
    for (int i=0; i<n; i++) { // 가격이 가장 높은 보석부터 시작, 2 -> 1 -> 5
        auto it = s.lower_bound(a[i].m); // 무게가 있는 인덱스를 찾음 -> 없으면 근접한 상위 리턴
        // 맨처음 2를 찾는다.
        // 2가 있으므로 2에 대한 it 반환
        // 그다음 1을 찾는다.
        // 1에 가장 가까운 큰수를 찾는다.   
        // 10밖에 안남았으므로 10을 리턴
        // 즉 가장 가까운 가방의 무게를 찾는다.
        if (it != s.end()) { // 존재하지 않으면 it는 end()인데 이는 존재한다는 뜻.
            ans += a[i].v; // 결과에 값 넣음
            s.erase(it); // 해당 지움
        }
        // 존재하지 않다는 것은 일단 넘기는 것
    }
    
    printf("%lld\n",ans);
    return 0;
}
```




