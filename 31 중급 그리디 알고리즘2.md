# 31 중급 그리디 알고리즘2
## 보석 도둑 https://www.acmicpc.net/problem/1202
* 상덕이가 보석 훔치려함
* 보석 종류 n
* 무게 M
* 가격 V
* 가방에 담을 수 있는 최대 무게 C
* 각 가방에는 **1개**만 넣을 수 있음

**입력**
```c++
3 2 // 종류, 가방 갯수 
1 65 // 무게 1의 보석은 65가격 
5 23 // 무게 5의 보석은 23가격
2 99 // 무게 2의 보석은 99가격 
10 // 가방의 최대량
2 // 가방2의 최대량
```

**출력**
```c++
164
```
* 2개 넣을 수 있는데 1개만 넣을 수 있으므로 2가 가장 좋고     
* 10개 넣을 수 있는데 1개만 넣을 수 있으므로 1이 가장 좋다.   
    
**내 생각**     
* 우선 가방을 정렬시킨다.        
* 보석을 무게순으로 정렬시킨다.           
* 큐를 이용하여 무게순으로 값을 넣는다.          
* 한바퀴 돌면서 최대값을 찾는다. 단 무게 이상이 나오면 break    
* 구하는 방법은 top()으로 비교하고 pop, push로 뒤로 넣기
* 최대값인 친구만 pop하기      
* 다시 가방 개수만큼 반복한다.   

**정답**  
2가지 방법 존재
1. 가방 기준
  1. 각각의 보석이 있을때 어떤 가방에 들어갈지 좋을지 찾음
2. 보석 기준
  1. 각각의 보석이 있을때 어떤 가방에 들어갈지 좋을지 찾음
* 각 가방에는 보석이 1개만 들어갈 수 있기에 가격이 큰 보석을 최대한 많이 가져가는것이 좋다.   
* 보석(무게, 가격) -> (2, 99) (1, 65) (5,23) -> 가격 기준 오름차순
* 가방 -> 정렬 -> 2, 10 -> 무게 기준 오름차순
* 2, 99는 어디에 들어가는게 좋을까?       
  * 최대 무게가 2인 가방에 들어가는 것이좋다.   
  * 뒤에 가격의 가치는 낮지만 무거운 것이 들어있을 수도 있다.   
  * 즉, 10에 들어간다면 2에는 (5, 65) (1,23)가 오면서 낭비가 되기 때문이다.   
  * 다르게 보면 최대 자신의 무게와 가까운곳에 들어가는 것이 좋다.   
* 가격이 높은 보석부터 차례대로 각 보석을 담을 수 있는 가방 중 `c[i]`가 가장 작은 가방에 넣는다.   
* 이를 구현하기 위해서 다음을 효율적으로 할 수 있는 자료구조가 필요하다   
   
1. 어떤수 x보다 큰 숫자 중에 가장 작은 수를 찾는다.   
2. 수를 지운다.   

정답은 BST : 이진 트리 알고리즘    
c++ 은 multiset을 이용하면 된다.     
  
# 가방 기준  
```c++
#include <cstdio>
#include <vector>
#include <algorithm>
#include <set>
using namespace std;
struct jewel {
    int m, v;
};

int main() {
    int n,k;
    scanf("%d %d",&n,&k);
    vector<jewel> a(n);
    
    for (int i=0; i<n; i++) {
        scanf("%d %d",&a[i].m, &a[i].v); // 보석 입력 받음
    }
    
    sort(a.begin(), a.end(), [](jewel u, jewel v) { // 정렬 시작 내림차순
        return u.v > v.v;
    });
    
    multiset<int> s; // 같은것이 들어갈 수 있는 것, 자동 오름차순 정렬
    for (int i=0; i<k; i++) {
        int t;
        scanf("%d",&t); // 가방 입력 받음
        s.insert(t); // set에 입력 중복 없애기 위해서인가.
    }
    
    long long ans = 0; // 결과
    for (int i=0; i<n; i++) { // 가격이 가장 높은 보석부터 시작, 2 -> 1 -> 5
        auto it = s.lower_bound(a[i].m); // 무게가 있는 인덱스를 찾음 -> 없으면 근접한 상위 리턴
        // 맨처음 2를 찾는다.
        // 2가 있으므로 2에 대한 it 반환
        // 그다음 1을 찾는다.
        // 1에 가장 가까운 큰수를 찾는다.   
        // 10밖에 안남았으므로 10을 리턴
        // 즉 가장 가까운 가방의 무게를 찾는다.
        if (it != s.end()) { // 존재하지 않으면 it는 end()인데 이는 존재한다는 뜻.
            ans += a[i].v; // 결과에 값 넣음
            s.erase(it); // 해당 지움
        }
        // 존재하지 않다는 것은 일단 넘기는 것
    }
    
    printf("%lld\n",ans);
    return 0;
}
```
* **O(nlogK)**
* 보석을 찾는데 걸리는 시간 logK(lower_bound)
* 있으면 지우는데 걸리는 시간 logK(erase)
* N번 돌때마다 있으므로
* 실은 n`*`(2`*`logK)이지만 O(nlogK)이다. (k는가방 갯수)     

뭔가 석연찮아서 예제를 바꿔서 이해해보겠습니다.    
```c++
가방 : 3 4
1 60
4 50
3 14
```
만약 1이 4에 들어간다면 후에 4는 가방에 못들어가는 문제가 생기고 대신 3이 가방에 들어갑니다.     
그렇기에 무게가 가장 큰 순으로 푸는 것은 맞지만 **가장 가까운 가방에 들어가야 한다는 것입니다.**   
알고리즘은 단순히 무게 알고리즘에서 **가방에 넣는 방식을 더해준 방법입니다.**    

# 무게 기준 
* 각각의 가방에 대해서 좋은 보석을 찾는 방법       
* 각각의 보석의 무게를 기준과 가방을 합쳐서 오름차순 정렬      
* `(1,65) (2,99) 2 (5,23) 10` 가방앞에 있는 것은 들어갈 수 있는 보석
* 즉 가방 앞에 있는 값들을 비교해서 사용하면 된다.   
* 후보를 만들고 해당 후보에서 가장 큰값을 뻬서 사용하면된다.   
* 큐를 이용하는 것 같은데  
* 맞다 우선순위 큐를 이용한것이다.   

```c++
#include <queue>
#include <algorithm>
#include <vector>
#include <cstdio>
using namespace std;
struct jewel {
    int m,v,w;
};
int main() {
    int n,k;
    scanf("%d %d",&n,&k);
    vector<jewel> a(n+k);
    
    for (int i=0; i<n; i++) {
        scanf("%d %d",&a[i].m,&a[i].v); // 무게와 값 입력
    }
    
    for (int i=0; i<k; i++) {
        scanf("%d",&a[i+n].m); // 가방 입력
        a[i+n].w = 1; // 가방의 가중치?
    }
    // 아 위에 있는 것들은 가중치가 0이므로 같은 값이 나오면 뒤로 보내기 위해서이다.
    
    sort(a.begin(), a.end(), [](jewel u, jewel v) {
        return u.m < v.m || (u.m == v.m && u.w < v.w); // 무게가 작으면 앞으로 또는 무게는 같지만 우선순위가 작은 걸 앞으로
    });
    
    priority_queue<int> q; // 우선순위 큐 -> 정렬된 큐인가?
    long long ans = 0; //
    for (auto &p : a) { // 정렬된 배열 하나씩 빼기
        if (p.w == 0) {
            q.push(p.v); // 0인 경우 가방이 아니니 큐에 값만 넣기.
        } else {
            if (!q.empty()) { // 아니고 후보가 비어있지 않다면
                ans += (long long)q.top(); // 가장 위에 있는 값 빼기
                q.pop(); // 큐 팝
            }
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```
* **O(nlogn)**
* 큐에 넣고 빼기 logN
* 최대 N 더하기 K(가방 개수) 만큼 정렬하고 사용하므로 
* O(N+k)(logN)
* 참고로 log는 숫자가 클수록 좋은 것이여서 위 결과보다 값이 좋다.   
     
* 배운점 
    * multiset : 중복가능, 2진트리임, 오름차순 정렬 (위에서는 가방 오름차순 정렬), 가장 중간 값이 맨위임
    * lower_bound : a.lower_bound(b) 를 하면 a에서 b를 찾고 없으면 b와 가장 근접한 큰값을 a에서 찾음   
    * priority_queue : 우선순위 큐: 디폴트로 가장 큰 값이 루트에 있음 
    
# 순회강연 문제 



