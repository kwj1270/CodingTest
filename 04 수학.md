수학
=======================
# 1. 나머지 연산 

* 컴퓨터의 정수는 저장할 수 있는 범위가 있기 때문에, 답을 M으로 나눈 나머지를 출력하는 문제가 등장한다.  
* (A+B) mod M = ((A mod M) + (B mod M)) mod M
* (A x B) mod M = ((A mod M) x (B mod M)) mod M
* 나누기의 경우에는 성립하지 않는다.  
* 뺄셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 한다.   
(A-B) mod M = ((A mod M) - (B mod M) + M) mod M

```
(5+3) % 2 = ?
((5 % 2) + (3 % 2)) % 2 = ?
(1+1) % 2 = 0
______________________________________
(5 x 3) % 2 = ?
((5 % 2) x (3 % 2)) % 2 = ?
(1 x 1) % 2 = 1
______________________________________
(5 - 3) % 2 = ?
((5 % 2) - (3 % 2) + 2) % 2 = ?
(1 - 1 + 2) % 2 = 0
______________________________________
(3 - 5) % 2 = ?
((3 % 2) - (5 % 2) + 2) % 2 = ?
(1 - 1 + 2) % 2 = 0
______________________________________
```

***
# 2. 최대 공약수 
## 2.1. 방법1 
* 최대 공약수는 줄여서 GCD라고 쓴다.  
* 두 수 A와 B의 최대 공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다.  
* 최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A,B)까지 모든 정수로 나누어 보는 방법
* 최대공약수가 1인 두 수를 서로소라고 한다.  

```c++
int g = 1;
for (int i=2; i <= min(a,b); i++){
	if(a%i == 0 && b % i == 0){
		g = i;
	}
}
```
## 2.2. 방법2
* 유클리드 호제법을 이용하면 더 빠르게 나타낼 수 있다.    
* a를 b로 나눈 나머지를 r이라고 했을 때       
* GCD(a,b) = GCD(b, r)과 같다.    
* r 이 0이면 그때 b가 최대 공약수이다.     
* GCD(24,16) -> GCD(16,8) -> GCD(8,0) -> 8 이 최대 공약수     
* 간혹 b가 a보다 크면 swap시키라는 말이 있는데 사실상 안해줘도 된다.      
왜냐하면 다음 회차시에 나머지로 넘어가면서 값이 저절로 swap 되기에 매번 연산처리를 해줄 필요가 없다.    

**재귀 버전**
```c++
int gcd(int a, int b){
	if(b == 0){
		return a;
	} else {
		returnd gcd(b, a%b);
	}
}
```
**재귀 아닌 버전**   
```c++
int gcd(int a, int b){
	while( b != 0){
		int r = a%b;
		a = b;
		b = r;
	}
	return a;
}
```

***
# 3. 최대 공배수 

* 최소 공배수는 줄여서 LCM이라고 부른다.  
* 두 수의 최소 공배수는 두 수의 공통된 배수중에서 가장 작은 정수를 의미한다.  
* 최소공배수는 GCD(최대 공약수)를 응용해서 구할 수 있다.   
* 두 수 a,b의 최대 공약수를 g라고 했을 때  
* 최소 공배수 l = g * (a/g) * (b/g) 이다.  

```
45 15 의 최대 공배수 구하기   
gcm = 15가 된다.   
15 * (45 / 15) * (15 / 15)
15 * 3 * 1 => 45  
________________________________________

48 36 의 최대 공배수 구하기   
gcm = 12가 된다.   
12 * (48 / 12) * (36 / 12)
12 * 4 * 3 => 144  
________________________________________
```


***
# 4. 소수
* 소수 : 약수가 1과 자기 자신 밖에 없는수 
* Double-ended queue의 약자이다.
* push_front: 덱의 앞에서 자료를 넣는 연산  
* push_back: 덱의 뒤에서 자료를 넣는 연산
* pop_front: 덱의 앞에서 자료를 빼는 연산
* pop_back: 덱의 뒤에서 자료를 빼는 연산
* front: 덱의 가장 앞에 있는 자료를 보는 연산 (삭제x) 
* back: 덱의 가장 뒤에 있는 자료를 보는 연산 (삭제x)  

덱을 작성할 경우 큐와 스택을 모두 사용할 수 있다.   
덱의 성질만 이용해서 푸는 문제는 거의 없기에 참고만 해주자    
   
```c++
#include <iostream> 
#include <string>
#include <deque>
using namespace std; 
int main(void) { 
    int t;
	cin >> t;
	
	deque<int> q;
	
    while(t--){
    	string cmd;
    	cin >> cmd;
    	
 		if (cmd == "push_front") {
            int num;
            cin >> num;
            q.push_front(num);
        } else if (cmd == "push_back") {
            int num;
            cin >> num;
            q.push_back(num);
        } else if (cmd == "pop_front") {
            cout << (q.empty() ? -1 : q.front()) << '\n';
            if (!q.empty()) {
                q.pop_front();
            }
        } else if (cmd == "pop_back") {
            cout << (q.empty() ? -1 : q.back()) << '\n';
            if (!q.empty()) {
                q.pop_back();
            }
        }
		
		else if (cmd == "front") {
            cout << (q.empty() ? -1 : q.front()) << '\n';
        } else if (cmd == "back") {
            cout << (q.empty() ? -1 : q.back()) << '\n';
        } else if (cmd == "size") {
            cout << q.size() << '\n';
        } else if (cmd == "empty") {
            cout << q.empty() << '\n';
        }
    }
    
    return 0; 
}
```
