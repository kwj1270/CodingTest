수학
=======================
# 1. 나머지 연산 

* 컴퓨터의 정수는 저장할 수 있는 범위가 있기 때문에, 답을 M으로 나눈 나머지를 출력하는 문제가 등장한다.  
* (A+B) mod M = ((A mod M) + (B mod M)) mod M
* (A x B) mod M = ((A mod M) x (B mod M)) mod M
* 나누기의 경우에는 성립하지 않는다.  
* 뺄셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 한다.   
(A-B) mod M = ((A mod M) - (B mod M) + M) mod M

```
(5+3) % 2 = ?
((5 % 2) + (3 % 2)) % 2 = ?
(1+1) % 2 = 0
______________________________________
(5 x 3) % 2 = ?
((5 % 2) x (3 % 2)) % 2 = ?
(1 x 1) % 2 = 1
______________________________________
(5 - 3) % 2 = ?
((5 % 2) - (3 % 2) + 2) % 2 = ?
(1 - 1 + 2) % 2 = 0
______________________________________
(3 - 5) % 2 = ?
((3 % 2) - (5 % 2) + 2) % 2 = ?
(1 - 1 + 2) % 2 = 0
______________________________________
```

***
# 2. 최대 공약수 
## 2.1. 방법1 
* 최대 공약수는 줄여서 GCD라고 쓴다.  
* 두 수 A와 B의 최대 공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다.  
* 최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A,B)까지 모든 정수로 나누어 보는 방법
* 최대공약수가 1인 두 수를 서로소라고 한다.  

```c++
int g = 1;
for (int i=2; i <= min(a,b); i++){
	if(a%i == 0 && b % i == 0){
		g = i;
	}
}
```
## 2.2. 방법2
* 유클리드 호제법을 이용하면 더 빠르게 나타낼 수 있다.    
* a를 b로 나눈 나머지를 r이라고 했을 때       
* GCD(a,b) = GCD(b, r)과 같다.    
* r 이 0이면 그때 b가 최대 공약수이다.     
* GCD(24,16) -> GCD(16,8) -> GCD(8,0) -> 8 이 최대 공약수     
* 간혹 b가 a보다 크면 swap시키라는 말이 있는데 사실상 안해줘도 된다.      
왜냐하면 다음 회차시에 나머지로 넘어가면서 값이 저절로 swap 되기에 매번 연산처리를 해줄 필요가 없다.    

**재귀 버전**
```c++
int gcd(int a, int b){
	if(b == 0){
		return a;
	} else {
		returnd gcd(b, a%b);
	}
}
```
**재귀 아닌 버전**   
```c++
int gcd(int a, int b){
	while( b != 0){
		int r = a%b;
		a = b;
		b = r;
	}
	return a;
}
```

***
# 3. 최대 공배수 

* 최소 공배수는 줄여서 LCM이라고 부른다.  
* 두 수의 최소 공배수는 두 수의 공통된 배수중에서 가장 작은 정수를 의미한다.  
* 최소공배수는 GCD(최대 공약수)를 응용해서 구할 수 있다.   
* 두 수 a,b의 최대 공약수를 g라고 했을 때  
* 최소 공배수 l = g * (a/g) * (b/g) 이다.  

```
45 15 의 최대 공배수 구하기   
gcm = 15가 된다.   
15 * (45 / 15) * (15 / 15)
15 * 3 * 1 => 45  
________________________________________

48 36 의 최대 공배수 구하기   
gcm = 12가 된다.   
12 * (48 / 12) * (36 / 12)
12 * 4 * 3 => 144  
________________________________________
```


***
# 4. 소수
* 소수 : 약수가 1과 자기 자신 밖에 없는 수     
* N이 소수가 되려면, 2보다 크거나 같고, N-1까지의 작거나 같은 자연수로 나누어 떨어지면 안된다.     
* 1 부터 100 까지 소수     
* 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97      
          
**알고리즘 방식**   
        
1. 어떤 수 N이 소수인지 아닌지 판별하는 방법    
2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법    
   
## 4.1. 방법1 
* 소수 : 약수가 1과 자기 자신 밖에 없는 수   
* N이 소수가 되려면, 2보다 크거나 같고, N-1까지의 작거나 같은 자연수로 나누어 떨어지면 안된다.     
```c++
bool prime(int n){
	if(n < 2){
		return false;
	}
	for (int i=2; i<=n-1; i++){
		if(n % i == 0){
			return false;
		}
	}
	return true;
}
```
    
## 4.2. 방법2 
* 소수 : 약수가 1과 자기 자신 밖에 없는 수   
* N이 소수가 되려면, 2보다 크거나 같고, N/2까지의 작거나 같은 자연수로 나누어 떨어지면 안된다.     

**이유**
```
N의 약수 중에서 가장 큰 것은 N/2 보다 작거나 같기 때문  
	-> 약수를 찾을 때
N = a x b 로 나타낼 수 있는데, a가 작을수록 b는 크다.  
	-> 약수 2개 a,b로 나타냈을 때 
가능한 a 중에서 가장 작은 값은 2이기 때문에, b는 N/2를 넘지 않는다. 
	-> 최대 약수는 2/n을 넘지 않으니 이에 상응하는 a의 값은 최소 2가 나온다는 뜻이다.    
```

```c++
bool prime(int n){
	if(n < 2){
		return false;
	}
	for (int i=2; i<=n/2; i++){
		if(n % i == 0){
			return false;
		}
	}
	return true;
}
```
   
## 4.3. 방법3
* 소수 : 약수가 1과 자기 자신 밖에 없는 수     
* N이 소수가 되려면, 2보다 크거나 같고, 루트N 보다 작거나 같은 자연수로 나누어 떨어지면 안된다.       
    
**이유**
```
N이 소수가 아니라면, N = a x b 로 나타낼수 있다. (a <= b) -> 약수   
* a > b 라면 두 수를 바꿔서 항상 a <= b 로 만들 수 있다.  
* 두 수 a와 b의 차이가 가장 작은 경우는 루트N 이다. -> 동일이니까
* 따라서, 루트 N까지만 검사를 해보면 된다. -> 기본값에 최대 약수로 나누는 거니까   
```   
    
```c++
bool prime(int n){
	if(n < 2){
		return false;
	}
	for (int i=2; i<=i*i/2; i++){
		if(n % i == 0){
			return false;
		}
	}
	return true;
}
```
* 컴퓨터에서 실수는 근사값을 나타내기 때문에, 루트 N과 같은 경우는 위 코드처럼 나타내는 것이 좋다.  
* ```루트 i <= N```  은 ```i <= N * N``` 과 같다.   
* 어떤 수 N이 소수인지 아닌지 판별하는데 걸리는 시간 복잡도 : O(루트N)       
     
## 전체 요소에 대해서 소수 검색하기     
* 어떤 수 N이 소수인지 아닌지 알아내는데 걸리는 시간 복잡도는 O(루트N)이었다.      
* N = 백만인 경우 : 루트N = 1000     
* N = 1억인 경우 : 루트N = 10000    
* 그럼, 1부터 1000000까지 모든 소수를 구하는데 걸리는 시간 복잡도는 몇일까?        
* **문제는 :** 각각의 수에 대해서 소수인지 아닌지 검사해야 한다.     
* 즉, 각각의 수에 대해서 O(루트N)을 계산하고 수는 총 N 개이므로 O(N 루트N)이 걸린다.       
* 1000000 * 1000 = 1000000000 = 10억 = 10초        
* 너무 긴 시간이 필요하다.        
그렇기에 단수를 처리하는 것이 아닌 큰 범위에서 찾으려면 다른 방법을 사용해야 한다.     
   
## 4.4. 에라토스테네스의 체      
* 1 부터 N까지 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용한다.        
1. 2부터 N까지 모든 수를 써놓는다.         
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.          
3. 그 수는 소수이다.           
4. 이제 그 수의 배수를 모두 지운다.            
       
* 지워지지 않은 수 중에서 가장 작은 수는 2이다.           
* 2는 소수이고 2의 배수를 모두 지운다.           
* 3의 배수를 지운다.   
* 5의 배수를 지운다. 
* 7의 배수를 지운다.   
* 11의 배수는 이미 지워져 있다.(2,3,5,7로 인하여)   
* 11 * 11은 121로 100을 넘기 때문에 더 이상 수행할 필요가 없으므로 남은 수가 모두 소수이다.   
* 1부터 N까지 모든 소수를 구하는 것이 목표이기 때문에, 구현할 때는 바깥 for문(i)를 N까지 돌린다.  
* 안쪽 for문(j)는 N의 크기에 따라서, ```i*i``` 또는 ```i*2```로 바꾸는 것이 좋다.  
* i = 백만인 경우 ```i*i```는 범위를 넘어가기 때문이다.

```c++
```
* 에라토스테네스의 체를 사용한 경우     
* 어떤 수 N이 소수인지 아닌지 판별하기 위해 ```루트 N``` 방법을 사용할 필요가 없다.     
* 에라토스테네스의 결과에서 지워지지 않았으면 소수, 아니면 소수가 아니기 때문이다.  


## 4.5. 골드바흐의 추측
* 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.  
* 위의 문장에 3을 더하면 
* 5보다 큰 모든 홀수는 세 소수의 합으로 표현이 가능하다.  
* 하지만 이러한 방식은 아직 증명되지 않은 문제이다.  
* 10^18이하에서는 참인 것이 증명되어 있다.  
   
***
# 5. 팩토리얼   
## 5.2. 팩토리얼 0의 개수  
* N! = 1 x 2 x ... n 의 0이 몇 개인지 알아내는 문제
* 10! = 36288**00**
* 10!이 0이 2개인 이유는 10!을 소인수분해 해보면 알 수 있다.   
* 10! = 1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9 x 10 
* 10! = 1 x 2 x 3 x 2 x 2 x 5 x 2 x 3 x 7 x 2 x 2 x 2 x 3 x 3 x 2 x 5
* 10! = 2^8 x 3^4 x 5^2 x 7
* 10! = 2^6 x 3^4 x (5^2 x 2^2) x 7 ```=>``` 5 x 5 x 2 x 2 ```=>``` 10 x 10 => 100 
       
즉, 팩토리얼에서 0이 몇 개 인지 알아내려면 N!을 소인수분해 했을 때, 2와 5가 몇개가 나오는지 알아야 한다.        
* 5의 개수가 항상 2의 개수 보다 적기 때문에, 5의 개수만 세어주면 된다.      
* N! 0의 개수 = [N/5]+[n/5^2]+[N/5^3] + ...   
    
**100!의 경우**
1. 인수로 5가 들어가는 것을 찾는다.  
2. 여기서 25,50,75,100은 ```25*1```, ```25*2```, ```25*3```, ```25*4```로
3. ```5*5*1```,```5*5*2```,```5*5*3```,```5*5*4```로 5가 2개씩 더 들어간다.  
4. 100/5 를 진행했을 때 5의 개수는 20개이다.  
5. 여기서 ```25```, ```50```, ```75```, ```100```도 포함되지만 5가 두번 들어간다. 
6. 그렇기에 추가로 들어가는 5의 개수를 더해준다.  
7. 20 + 4 = 24  
8. 따라서 100! 의 0의 개수는 24개이다.  

```
933262154439441526816992388562667
004907159682643816214685929638952
175999932299156089414639761565182
862536979208272237582511852109168
64000000000000000000000000
```
   
***
# 6. 조합 0의 개수  
* 팩토리얼은 2의 개수가 5의 개수 보다 항상 많기 때문에, 5의 개수만 세어줬는데 
* 조합은 어떻게 될 지 모르기 때문에, 2의 개수와 5의 개수를 동시에 세어줘야 한다.  

