수학
=======================
# 1. 나머지 연산 

* 컴퓨터의 정수는 저장할 수 있는 범위가 있기 때문에, 답을 M으로 나눈 나머지를 출력하는 문제가 등장한다.  
* (A+B) mod M = ((A mod M) + (B mod M)) mod M
* (A x B) mod M = ((A mod M) x (B mod M)) mod M
* 나누기의 경우에는 성립하지 않는다.  
* 뺄셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 한다.   
(A-B) mod M = ((A mod M) - (B mod M) + M) mod M

```
(5+3) % 2 = ?
((5 % 2) + (3 % 2)) % 2 = ?
(1+1) % 2 = 0
______________________________________
(5 x 3) % 2 = ?
((5 % 2) x (3 % 2)) % 2 = ?
(1 x 1) % 2 = 1
______________________________________
(5 - 3) % 2 = ?
((5 % 2) - (3 % 2) + 2) % 2 = ?
(1 - 1 + 2) % 2 = 0
______________________________________
(3 - 5) % 2 = ?
((3 % 2) - (5 % 2) + 2) % 2 = ?
(1 - 1 + 2) % 2 = 0
______________________________________
```

***
# 2. 최대 공약수 
## 2.1. 방법1 
* 최대 공약수는 줄여서 GCD라고 쓴다.  
* 두 수 A와 B의 최대 공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다.  
* 최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A,B)까지 모든 정수로 나누어 보는 방법
* 최대공약수가 1인 두 수를 서로소라고 한다.  

```c++
int g = 1;
for (int i=2; i <= min(a,b); i++){
	if(a%i == 0 && b % i == 0){
		g = i;
	}
}
```
## 2.2. 방법2
* 유클리드 호제법을 이용하면 더 빠르게 나타낼 수 있다.    
* a를 b로 나눈 나머지를 r이라고 했을 때       
* GCD(a,b) = GCD(b, r)과 같다.    
* r 이 0이면 그때 b가 최대 공약수이다.     
* GCD(24,16) -> GCD(16,8) -> GCD(8,0) -> 8 이 최대 공약수     
* 간혹 b가 a보다 크면 swap시키라는 말이 있는데 사실상 안해줘도 된다.      
왜냐하면 다음 회차시에 나머지로 넘어가면서 값이 저절로 swap 되기에 매번 연산처리를 해줄 필요가 없다.    

**재귀 버전**
```c++
int gcd(int a, int b){
	if(b == 0){
		return a;
	} else {
		returnd gcd(b, a%b);
	}
}
```
**재귀 아닌 버전**   
```c++
int gcd(int a, int b){
	while( b != 0){
		int r = a%b;
		a = b;
		b = r;
	}
	return a;
}
```

***
# 3. 최대 공배수 

* 최소 공배수는 줄여서 LCM이라고 부른다.  
* 두 수의 최소 공배수는 두 수의 공통된 배수중에서 가장 작은 정수를 의미한다.  
* 최소공배수는 GCD(최대 공약수)를 응용해서 구할 수 있다.   
* 두 수 a,b의 최대 공약수를 g라고 했을 때  
* 최소 공배수 l = g * (a/g) * (b/g) 이다.  

```
45 15 의 최대 공배수 구하기   
gcm = 15가 된다.   
15 * (45 / 15) * (15 / 15)
15 * 3 * 1 => 45  
________________________________________

48 36 의 최대 공배수 구하기   
gcm = 12가 된다.   
12 * (48 / 12) * (36 / 12)
12 * 4 * 3 => 144  
________________________________________
```


***
# 4. 소수
* 소수 : 약수가 1과 자기 자신 밖에 없는 수     
* N이 소수가 되려면, 2보다 크거나 같고, N-1까지의 작거나 같은 자연수로 나누어 떨어지면 안된다.     
* 1 부터 100 까지 소수     
* 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97      
          
**알고리즘 방식**   
        
1. 어떤 수 N이 소수인지 아닌지 판별하는 방법    
2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법    
   
## 4.1. 방법1 
* 소수 : 약수가 1과 자기 자신 밖에 없는 수   
* N이 소수가 되려면, 2보다 크거나 같고, N-1까지의 작거나 같은 자연수로 나누어 떨어지면 안된다.     
```c++
bool prime(int n){
	if(n < 2){
		return false;
	}
	for (int i=2; i<=n-1; i++){
		if(n % i == 0){
			return false;
		}
	}
	return true;
}
```
    
## 4.2. 방법2 
* 소수 : 약수가 1과 자기 자신 밖에 없는 수   
* N이 소수가 되려면, 2보다 크거나 같고, N/2까지의 작거나 같은 자연수로 나누어 떨어지면 안된다.     

**이유**
```
N의 약수 중에서 가장 큰 것은 N/2 보다 작거나 같기 때문  
	-> 약수를 찾을 때
N = a x b 로 나타낼 수 있는데, a가 작을수록 b는 크다.  
	-> 약수 2개 a,b로 나타냈을 때 
가능한 a 중에서 가장 작은 값은 2이기 때문에, b는 N/2를 넘지 않는다. 
	-> 최대 약수는 2/n을 넘지 않으니 이에 상응하는 a의 값은 최소 2가 나온다는 뜻이다.    
```

```c++
bool prime(int n){
	if(n < 2){
		return false;
	}
	for (int i=2; i<=n/2; i++){
		if(n % i == 0){
			return false;
		}
	}
	return true;
}
```
   
## 4.3. 방법3
* 소수 : 약수가 1과 자기 자신 밖에 없는 수     
* N이 소수가 되려면, 2보다 크거나 같고, 루트N 보다 작거나 같은 자연수로 나누어 떨어지면 안된다.       
    
**이유**
```
N이 소수가 아니라면, N = a x b 로 나타낼수 있다. (a <= b) -> 약수   
* a > b 라면 두 수를 바꿔서 항상 a <= b 로 만들 수 있다.  
* 두 수 a와 b의 차이가 가장 작은 경우는 루트N 이다. -> 동일이니까
* 따라서, 루트 N까지만 검사를 해보면 된다. -> 기본값에 최대 약수로 나누는 거니까   
```   
    
```c++
bool prime(int n){
	if(n < 2){
		return false;
	}
	for (int i=2; i<=i*i/2; i++){
		if(n % i == 0){
			return false;
		}
	}
	return true;
}
```
* 컴퓨터에서 실수는 근사값을 나타내기 때문에, 루트 N과 같은 경우는 위 코드처럼 나타내는 것이 좋다.  
* ```루트 i <= N```  은 ```i <= N * N``` 과 같다.   
* 어떤 수 N이 소수인지 아닌지 판별하는데 걸리는 시간 복잡도 : O(루트N)     
