브루트포스 - 비트마스크
=======================
* 비트 연산을 사용해서 부분 집합을 표현할 수 있다.  

# 1. 비트 연산

* & AND
* | OR
* ~ NOT 
* ^ XOR
___

* 두 수 A와 B를 비트 연산 하는 경우에는 가장 뒤의 자리부터 하나씩 연산을 수행하면 된다.  
* A = 27, B = 83인 경우  
* A = 0011011 , B = 1010011
* A & B = 0010011 -> 19
* A | B = 1011011 -> 91
* A ^ B = 1001000 -> 72



# 2. 다음 순열  
1. A[i-1] < A[i] 를 만족하는 가장 큰 i를 찾는다.  
2. j >= i 이면서 A[j] > A[i-1]를 만족하는 가장 큰 j를 찾는다.  
3. A[i-1]과 A[j]를 swap 한다.  
4. A[i] 부터 순열을 뒤집는다.

예를들면 순열이 ```7, 2, 3, 6, 5, 4, 1``` 일 경우에 다음에 올 순열을 구하는 방법은 
1. 7,2,3으로 시작하는 마지막 순열을 의미한다.  
  * 이것을 어떻게 알지?
  * 마지막 순열은 내림차순을 의미한다. 
  * 즉, 뒤에서부터 내림차순임을 판단하고 내림차순이 아닌 경우 
  * 마지막 내림차순이 ```[i]```가 되는 것이고 내림차순이 아닌곳이 ```[i-1]```이 된다.
  * 위 예시로는 6이 ```[i]```가 되는것이고 3이 ```[i-1]```이 된는 것이다.
  * 즉, 위에서 의미하는 것은 723으로 시작하는 마지막 순열을 의미한다.  
2. 마지막 순열 다음으로 올 순열을 구해야 하므로 다음에 올 ```7, 2, ?``` 을 구해야 한다.
  * 기존 3보다 커야하며 앞에 있는 수와 겹치지 않기 위해서 i부터 끝까지의 수중 가장 작은수를 찾아야한다.  
  * 위 예시에서는 6,5,4,1 이고 3보다 큰 가장 작은 수는 4이므로  
  * 3과 4의 위치를 바꿔주고 -> 7,2,4,6,5,3,1  
  * 7,2,4 의 가장 첫번째 순열을 구해준다.  
  * 가장 첫번째 순열은 오름차순이므로 7,2,4 뒤에 오름차순 정렬시켜주면 된다.
  * 여기서 i부터 끝까지는 내림차순이므로 이를 뒤집기만 해줌녀 오름차순이 된다.  
  * 즉, 7,2,4,1,3,5,6 이 되어야 한다.     
  * 다르게 생각하면 정렬을 안하면 다음 순열의 마지막을 찾을 수 있네?  
   
```c++

```
# 3. 이전 순열  
다음 순열의 부등호를 모두 반대로 바꾸어 주면 된다.
   
```c++
```
# 4. 모든 순열   
처음부터 끝까지 다음 순열을 이용하면서 순열을 출력해주면 된다.   

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
	int n;
	cin >> n;
	vector<int> a(n);
	for (int i=0; i<n; i++) {
		a[i] = i+1;
	}
	do {
		for (int i=0; i<n; i++) {
			cout << a[i] << ' ';
		}
		cout << '\n';
	} while (next_permutation(a.begin(), a.end()));
	return 0;
}
```
   
# 5. 팩토리얼   
1억은 1초다. 모든 순열을 구하는데 걸리는 시간은 N x N! 이고  
10! 팩토리얼은 3,628,800이다. (3천만)  
이렇게 모든 순열을 구해서 문제를 푸는 경우 n제한이 10밖에 안된다.   
```c++
```

# 6. 기타  
우리가 앞에서 구했던 방법은 수가 모두 다르다는 가정하에 구했는데        
사실상 수가 같은 수가 겹치더라도 이러한 다음 순열을 구할 수 있다.(모든 순열도)   

# 7. 차이를 최대로 
* 수 N개가 주어졌을 때 
* ```| A[0] - A[1] | + | A[1] - A[2] | + ... + | A[N-2] -A[N-1] |```
* 위의 식의 값을 최대로 하는 문제를 구하는 것이다.  
* 수식이 쓰여져 있으니 수학적 방법을 토대로 할 것 같지만 
* 제한이 8밖에 안된다는 점을 이용해서 이를 순열로 풀어볼 생각이다.
* 문제에서는 수를 바꿀수는 없지만  수의 순서를 바꿀 수 있다는 조건이 있기에 순열을 이용할 것이다.  
* 즉, 수의 순서만 제한하고 최대가 8이라는 것은 ```8!``` 의 최대 경우의 수를 이용하는 것이다.
* 8 x 8! 은 1억이 안되기에 문제를 풀 수 있는것이다.  
* 문제에서 차이의 최대이므로 절대값으로 풀어야 한다.  

**소스 코드**
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int calculate(vector<int> &a){
	int sum = 0;
	for(int i=1; i < a.size(); i++){
		sum += abs(a[i-1] - a[i+1]); // 점점 값을 키워나간다.  
	}
	return sum;
}

int main() {

	int n;
	cin >> n;

	vector<int> a(n);

	int temp;
	for(int i=0; i < n; i++){
		cin >> a[i];
	}
	sort(a.begin(), a.end()); // 정렬은 필수이다  
	// 오름차순으로 정렬해놓는 것이 첫번째 순열이므로     
	// 처음부터 끝까지 가야하기에 정렬을 해야한다.   

	int ans = 0; // 결과값 
	do{
		int temp = calculate(a);
		ans = max(ans, temp);
	}while(next_permutation(a.begin(), a.end())); // do while의 이유
	// 해당 메소드를 하면 다음 순열로 넘어가기에 우선 do while을 사용해주자

	cout << ans << "\n";

	return 0;
}
```

**김우재 오리지널 코드 (하나도 안보고 풀었다 ㅎㅎ)**
```c++
#include <iostream>
#include <stack>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {

	int n;
	cin >> n;

	vector<int> arr;

	int temp;
	for(int i=0; i < n; i++){
		cin >> temp;
		arr.push_back(temp);
	}
	sort(arr.begin(), arr.end()); // 정렬은 필수이다  
	// 오름차순으로 정렬해놓는 것이 첫번째 순열이므로     
	// 처음부터 끝까지 가야하기에 정렬을 해야한다.   

	int ans = 0; // 결과값 
	do{
		int max = 0; // 각 순열당 임시 값 
		for(int i=0; i < n-1; i++){
			max += abs(arr[i] - arr[i+1]); // 점점 값을 키워나간다.  
		}
		if(ans < max) ans = max; // 만약 기존 최대값 보다 크면 대입  

	}while(next_permutation(arr.begin(), arr.end())); // do while의 이유
	// 해당 메소드를 하면 다음 순열로 넘어가기에 우선 do while을 사용해주자

	cout << ans << "\n";

	return 0;
}
```
    
# 8. 외판원 순회2
* 영어로 Travelling Salesman Problem (TSP)      
* 1번부터 N번까지 번호가 매겨져있는 도시가 있다.     
* 한 도시에서 시작해 N개의 모든 도시를 거쳐 다시 원래 도시로 돌아오려고 한다.        
* 이때, 가장 적은 비용을 구하는 문제     
* W[i][j] = i > j 비용, 0인 경우는 갈 수 없다.     
* 순열로 풀경우 N제한을 봐야 하는데 문제마다 다르므로 10이하면 풀 수 있게 될 것이다.
     
**소스 코드**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {

	int n;
	cin >> n;
	vector<vector<int>> w (n,vector<int>(n));

	for(int i=0; i < n; i++){
		for(int j=0; j < n; j++){
			cin >> w[i][j];
		}	
	}

	vector<int> d(n);
	for (int i=0; i<n; i++) {
		d[i] = i; // 0~N까지 값이 들어가네 
		// i는 다음 이동 지역을 의미
		// 즉 d 는 방문 순서를 의미한다. 
		// 즉 어디서부터 어디를 방문하는지 순서를 기록한다.  
		// 이렇게 초기화 한것은 1부터 끝까지 가는 초기 순열을 의미
	}

	int ans = 2147483647; // 일단 엄청 큰값 넣기  

	do{
		
		// do{}에서 하는것은 d[0] 부터 d[n-1] 까지 가는것인데
		// 인덱스가 아닌 d[]에 저장된 값이 다음 지역을 의미하므로
		// 이를 순열을 이용해서 모든 경우의 수를 구하도록 하는 것이다.
		bool ok = true;
		int sum = 0;

		for (int i=0; i<n-1; i++) {
			if (w[d[i]][d[i+1]] == 0) { // 다음 칸을 갈 수 있냐를 의미
				ok = false; // false -> 이동 할수 없음을 의미한다.  
				// 이동할 수 없으므로 아래 if가 동작하지 않을 것이다.
			} else {
				sum += w[d[i]][d[i+1]]; // 이동할 수 있으면 거리를 넣어준다.
			}
		}
		if (ok && w[d[n-1]][d[0]] != 0) { // 처음으로 가는게 0이 아니면 
			sum += w[d[n-1]][d[0]]; // 처음으로 가는 값도 더해줘라  
			if (ans > sum) ans = sum; // 여태 나온 값중 작은 값 구하기 
		}
	}while(next_permutation(d.begin(), d.end())); // 다음 이동 방법 계산

	cout << ans << "\n";

	return 0;
}
```
n 이 4인 경우라고 했을시   

* 1 2 3 4
* 2 3 4 1
* 3 4 1 2 
* 4 1 2 3
* 위의 4가지는 모두 같은 경우이다.  
* 다시 시작한 도시로 돌아가야하기 때문이다
* 따라서 시작점을 1로 고정해도 된다.  
* 즉 위 순열에서 1부터 시작하면 다 똑같다.  

**1을 고정시킨 소스코드**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {

	int n;
	cin >> n;
	vector<vector<int>> w (n,vector<int>(n));

	for(int i=0; i < n; i++){
		for(int j=0; j < n; j++){
			cin >> w[i][j];
		}	
	}

	vector<int> d(n);
	for (int i=0; i<n; i++) {
		d[i] = i; // 0~N까지 값이 들어가네 
		// i는 다음 이동 지역을 의미
		// 즉 d 는 방문 순서를 의미한다. 
		// 즉 어디서부터 어디를 방문하는지 순서를 기록한다.  
		// 이렇게 초기화 한것은 1부터 끝까지 가는 초기 순열을 의미
	}

	int ans = 2147483647; // 일단 엄청 큰값 넣기  

	do{
		
		// do{}에서 하는것은 d[0] 부터 d[n-1] 까지 가는것인데
		// 인덱스가 아닌 d[]에 저장된 값이 다음 지역을 의미하므로
		// 이를 순열을 이용해서 모든 경우의 수를 구하도록 하는 것이다.
		bool ok = true;
		int sum = 0;

		for (int i=0; i<n-1; i++) {
			if (w[d[i]][d[i+1]] == 0) { // 다음 칸을 갈 수 있냐를 의미
				ok = false; // false -> 이동 할수 없음을 의미한다.  
				// 이동할 수 없으므로 아래 if가 동작하지 않을 것이다.
			} else {
				sum += w[d[i]][d[i+1]]; // 이동할 수 있으면 거리를 넣어준다.
			}
		}
		if (ok && w[d[n-1]][d[0]] != 0) { // 처음으로 가는게 0이 아니면 
			sum += w[d[n-1]][d[0]]; // 처음으로 가는 값도 더해줘라  
			if (ans > sum) ans = sum; // 여태 나온 값중 작은 값 구하기 
		}
	}while(next_permutation(d.begin()+1, d.end())); // 다음 이동 방법 계산

	cout << ans << "\n";

	return 0;
}
```
```
}while(next_permutation(d.begin()+1, d.end())); // 다음 이동 방법 계산
```
여기가 달라졌다.    
이렇게 했을 경우 시작점을 고정시키면서 문제를 풀 수 있게 된다.    
(순열은 처음부터 끝까지로 하기 위해 정렬을 시켜주지 항상 최소값이 고정된다 보면된다.)   
맨 처음 방법은 ```nxn!``` 이라면 현재 방법은 ```nxn-1!```이다.
     
**1을 고정시킨 소스코드2**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {

	int n;
	cin >> n;
	vector<vector<int>> w (n,vector<int>(n));

	for(int i=0; i < n; i++){
		for(int j=0; j < n; j++){
			cin >> w[i][j];
		}	
	}

	vector<int> d(n);
	for (int i=0; i<n; i++) {
		d[i] = i; // 0~N까지 값이 들어가네 
		// i는 다음 이동 지역을 의미
		// 즉 d 는 방문 순서를 의미한다. 
		// 즉 어디서부터 어디를 방문하는지 순서를 기록한다.  
		// 이렇게 초기화 한것은 1부터 끝까지 가는 초기 순열을 의미
	}

	int ans = 2147483647; // 일단 엄청 큰값 넣기  

	do{
		if(d[0] != 1) break;
		// do{}에서 하는것은 d[0] 부터 d[n-1] 까지 가는것인데
		// 인덱스가 아닌 d[]에 저장된 값이 다음 지역을 의미하므로
		// 이를 순열을 이용해서 모든 경우의 수를 구하도록 하는 것이다.
		bool ok = true;
		int sum = 0;

		for (int i=0; i<n-1; i++) {
			if (w[d[i]][d[i+1]] == 0) { // 다음 칸을 갈 수 있냐를 의미
				ok = false; // false -> 이동 할수 없음을 의미한다.  
				// 이동할 수 없으므로 아래 if가 동작하지 않을 것이다.
			} else {
				sum += w[d[i]][d[i+1]]; // 이동할 수 있으면 거리를 넣어준다.
			}
		}
		if (ok && w[d[n-1]][d[0]] != 0) { // 처음으로 가는게 0이 아니면 
			sum += w[d[n-1]][d[0]]; // 처음으로 가는 값도 더해줘라  
			if (ans > sum) ans = sum; // 여태 나온 값중 작은 값 구하기 
		}
	}while(next_permutation(d.begin(), d.end())); // 다음 이동 방법 계산

	cout << ans << "\n";

	return 0;
}
```
```d[0] != 1``` 인 경우에 1로써 모든 순서를 이미 돌았기 때문에 그 뒤에는 사용 안하도록 만든것이다.   
      
# 9. 로또  
* 입력으로 주어진 k개의 수중에서 6개를 고르는 문제 (순서와 전혀 상관 없다)  
* 고른다고 했기에 선택관련 문제인데 순서로 해결할 수도 있다.  
* 우선 다음 순열 메소드는 같은 값이 있어도 순열을 만들 수 있다.  

**소스코드-이해가 좀 필요하다**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    while (true) {
        int n;
        cin >> n;
        if (n == 0) {
            break;
        }
        vector<int> a(n);
        for (int i=0; i<n; i++) {
            cin >> a[i];
        }
        vector<int> d;
        for (int i=0; i<n-6; i++) {
            d.push_back(0);
        }
        for (int i=0; i<6; i++) {
            d.push_back(1);
        }
        vector<vector<int>> ans;
        do {
            vector<int> current;
            for (int i=0; i<n; i++) {
                if (d[i] == 1) {
                    current.push_back(a[i]);
                }
            }
            ans.push_back(current);
        } while (next_permutation(d.begin(), d.end()));
        sort(ans.begin(), ans.end());
        for (auto &v : ans) {
            for (int i=0; i<v.size(); i++) {
                cout << v[i] << ' ';
            }
            cout << '\n';
        }
        cout << '\n';
    }
    return 0;
}
```
