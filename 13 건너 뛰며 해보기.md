건너 뛰며 해보기
=======================  
# 1. 카잉 달력
* M 과 N보다 작거나 같은 두 자연수 x,y를 이용해서 년도를 ```<x:y>``` 로 표시한다.
* 첫 번째 해는 ```<1:1>```, 두 번째 해는 ```<2:2>```이다.  
* ```<x:y>```의 다음 해는 ```<x:y>```이다.  
  * x < M 이면 x = x+1, 아니면 x = 1 
  * y < N 이면 y = y+1, 아니면 y = 1
* M, N, x, y 가 주어졌을 때, ```<x:y>```이 몇 번째 해인지 구하는 문제  
  
즉 쉽게 말해서 M=10 N=12 일 경우 ```<10:10>``` 에서 다음은 ```<1:11>``` 이렇게 되는 것이고    
몇 번째 년도의 값이어야 ```<x:y>```가 나오는지 구하는 것이다     

여기서 중요한 방법이 하나 있는데 
위 처럼 N이나 M을 넘길경우 다시 1로 시작하는 방법이어야 한다.   
하지만 그상태 그대로 나머지를 할 경우 0으로 초기화 되어버린다.   
이를 방지하고자 전체값을 -1 해주고 계산을 한 다음에 후에 다시 1을 더해주는 방식을 사용하면 된다
```
		M = 5 , N = 7이라 가정시
		// 35일경우 둘다 0,0이 된다.  
		// 다시 5,5 라고 가정시에 -> 0,5가 된다.
		// 다시 6,6 라고 가정시에 -> 1,6이 된다.  
		
    // 이렇게 된 0을 다시 1로 만들어주는 작업을 하는 것보다
    // 애초에 작업 자체가 1값이 나올 수 있도록 처리해주는 것이 좋은데
    // 바로 전체값 -1 을 하고 후에 +1을 해주는 것이다.
    
		// 5,5 가정시에 전체값 -1인 4,4로 바꾸면 -> 4,4가 된다.
		// 여기에 다시 1을 더해주면 -> 5,5가 된다.
		// 6,6 가정시에 전체값 -1인 5,5로 바꾸면 -> 0,5가 된다.
		// 여기에 다시 1을 더해주면 -> 1,6이 된다.
		// 이런 동작을 취해주는 것이 좋다.  
```
```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <stack>
#include <queue>
#include <deque>

using namespace std;

int main(void){
	
	int t;
	cin >> t;

	while(t--){
		int m, n, x, y;
		cin >> m >> n >> x >> y;

		// m 과 n 은 단순 기준만 나타내기에 -1을 할 필요가 없다
		x-=1; // 전체값 -1
		y-=1; // 전체값 -1
		bool ok = false;
		for (int k=x; k<(n*m); k+=m) { // 최대공배수가 되면 다시 1,1로 원상 복귀 되니까 
            if (k%n == y) {
                cout << k+1 << '\n'; // 이 의미는 조금더 알아봐야겠다.  
                ok = true;
                break;
            }
        }
        if (!ok) {
            cout << -1 << '\n';
        }
	}

	return 0;
}
```
# 2. 수 이어쓰기  
* 1부터 N까지 수를 이어서 쓰면 새로운 하나의 수를 얻게 된다. (1 <= N <= 100,000,000)  
* 12345678910111213141516171819202122...
* 이때, 새로운 수는 몇 자리 수일까? (길이 구하기)         
    
한가지 패턴을 발견해보자면 **수의 자리수별로 나누어서 문제를 해결할 수 있다.**   
* N = 120 가정시에
* 1-9 는 1개
* 10-99는 2개
* 100-120 은 2자리

다시 
* 1-9 는 1 x (9-1+1) == 9   
* 10-99는 2 x (99-10+1) == 180   
* 100-120 은 3 x (120-100+1) == 63   

이렇게 문제를 풀 수 있는 이유는   
수가 1부터 N까지 빠짐없이 사용된다는 점이다.  

이렇게 생각의 방향을 바꿔보면 문제의 경우의수를 많이 줄일 수 있다.    
1. 나머지 연산    
2. 중복되는 것을 공통되는 것을 그룹화하여 연산의 횟수를 줄이는 법   

# 3. N중 for문 
* N개 중에 일부를 선택해야 하는 경우에 많이 사용한다.  
* 재귀 호출이나 비트마스크를 사용하면 더 간결하고 보기 쉬운 코드를 작성할 수 있기 때문에, 사용할 일이 거의 없다.  

# 4. 1,2,3, 더하기  

* 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제이다.  
* n = 4 
* 1+1+1+1
* 1+1+2
* 1+2+1
* 2+1+1
* 2+2
* 1+3
* 3+1

```c++
```







# 3. 그냥 다 해보기 - 사탕 게임
* N X M 크기의 테이블이 사탕이 있다. (n <= 50)             
* 인접한 두 칸을 고르고, 사탕을 교환한다.                 
	1. 인접한 두 칸을 고르는 방법의 갯수 : 2(n^2)      
	WHY? -> 칸의 갯수 N^2 모든 칸은 4개의 인접한 칸을 가지고 있다. -> 4N^2    
	모든칸이 인접한 칸을 오른쪽이나 아래쪽만 구한다 하면 (중복없이 계산하는 방법 - 왼쪽 위부터)     
	2. 시간 복잡도 계산으로 따지면 상수를 제외한 O(n^2)이다.   
* 그 다음, 같은 색으로 이루어져 있는 가장 긴 연속 부분 행 또는 열을 고르는 문제         
	1. 가장 긴 연속 부분 행을 구한다는 것은 행의 모든 요소를 하나하나 다 비교해야 한다는 뜻이다.
	2. 이 부분도 모든 행을 검색하게 되므로 N^2이라는 경우의 수가 발생된다.  
* 결국에는 N^2 x N^2 의 형태이므로 N^4의 경우의 수를 띄게 된다.   
* 50^4 은 2500^2 제곱이므로 브루트 포스를 사용해도 될 것이다.   
   
**소스코드**   
```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

int check(vector<string> &a){
	int n = a.size();
	int ans = 1; // 반환값으로 넘길 최대 연속길이를 의미 우선 나 자신을 카운터 하니 1 
	for(int i=0; i<n;i++){
		int cnt = 1; // 부분마다의 연속의 개수 -> 일단 나 자신을 카운터 해야하니 1
		for(int j=1; j<n;j++){// 0 ~ n-1 인덱스까지
			if(a[i][j] == a[i][j-1]){  // j=1부터 시작하므로 뒤에서부터 같은지 검사
				cnt += 1; // 같을 경우 카운트 증가 
			} else {
				cnt = 1; // 하나라도 다를 경우 다시 1로 카운트  
			}
			if (ans < cnt) ans = cnt; // 만약 최대길이가 현재보다 작으면 값 대입  
		}
		cnt = 1; // 세로 방향을 위한 카운트 준비  
		for(int j=1; j<n;j++){ // 마찬가지로 0 ~ n-1 인덱스까지  
			if(a[j][i] == a[j-1][i]){ // j를 앞으로 줌을로써 열 비교  
				cnt += 1; // 같을 경우 카운트 증가
			} else { 
				cnt = 1; // 다를 경우 다시 1로 카운트  
			}
			if (ans < cnt) ans = cnt; // 최대 길이가 현재 카운트보다 작으면 대입  
		}
	}
	return ans;
}

int main() {

	int n;
	cin >> n;
	cin.ignore();

	vector<string> a(n);

	for(int i=0; i < n;i ++){
		getline(cin, a[i]);
	}
	int ans = 0;
	for(int i=0; i < n; i++){
		for(int j=0; j < n; j++){
			if(j+1 < n){
				swap(a[i][j],a[i][j+1]); // 오른쪽 바꾸기 
				int temp = check(a); // check는 최대 연속 구분행의 값이나 열의 값을 반환
				if(ans < temp) ans = temp; // ans 가 그 합보다 작으면 바꾼값을 넣기
				swap(a[i][j],a[i][j+1]); // 다시 원래대로 되돌린다.
				// 하나만 바꾸라 했으니 원래 상태로 돌리지 않으면 그다음에는 2개가 바뀐것이고
				// 그다음에는 3개가 바뀐것이고 이렇게 바뀐게 누적되어가기 때문이다.   
			}
			if(i+1 < n){
				swap(a[i][j],a[i+1][j]); // 아래 바꾸기
				int temp = check(a); // check는 최대 연속 구분행의 값이나 열의 값을 반환
				if(ans < temp) ans = temp; // ans 가 그 합보다 작으면 바꾼값을 넣기
				swap(a[i][j],a[i+1][j]); // 다시 원래대로 되돌린다.
				// 하나만 바꾸라 했으니 원래 상태로 돌리지 않으면 그다음에는 2개가 바뀐것이고
				// 그다음에는 3개가 바뀐것이고 이렇게 바뀐게 누적되어가기 때문이다.   
			}
		}
	}
	cout << ans << "\n";
    return 0;
}
```
   
# 4. 그냥 다 해보기 - 날짜 계산  
* 준규가 사는 나라는 ESM이라는 연도를 사용한다.  
* ```1 <= E <= 15```, ```1 <= S <= 28```, ```1 <= M <= 19```
* 1년 1 1 1
* 2년 2 2 2 
* ...
* 15년 15 15 15
* 16년 1 16 16
* ...
* 20년 5 20 1
* 21년 6 21 2
    
ESM이 주어졌을 때, 이게 몇 년인지 구하는 문제         
가능한 모든 방법의 수는? ```15 * 28 * 19``` -> 7980       
1억이 1초인데 7980이므로 브루트 포스로 계산을 해도 된다.    
   
```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

int main() {
	int E, S, M;
	cin >> E >> S >> M; // 바뀌지 않는값 상수

	int e = 1, s=1, m=1; // 바뀌고 있는 값 

	for(int i=1;;i++){
		if( e == E && s == S & m ==M){
			cout << i << "\n";
			break;
		}
		e +=1;
		s +=1;
		m +=1;
		
		if(e == 16) e = 1;
		if(s == 29) s = 1;
		if(m == 20) m = 1;
	}
	return 0;
}
```
   
```c++

```
      
# 5. 그냥 다 해보기 - 리모컨 문제    
* TV 채널을 리모컨을 이용해 바꾸는 문제  
* 버튼: 0,1,2,3,4,5,6,7,8,9,+,-  
* 일부 숫자 버튼이 고장났다.  
* 현재 보고 있는 채널: 100 
* 이동하려고 하는 채널: N 
* 이 때, 리모컨 버튼을 누르는 횟수를 최소로 하는 문제    
___    
* 예를 들어, 5457에 이동하려면 5,4,5,7을 눌러 4번만에 이동할 수 있다.  
* 만약, 숫자 버튼 7이 고장났다면, 5,4,5,6,+ 또는 5,4,5,8,-를 눌러 5번만에 이동할 수 있다.  
* 6,7,8이 고장난 경우에는 5,4,5,5,+,+ 또는 5,4,5,9,-,-를 눌러 6번만에 이동할 수 있다.  
* 5,6,7,8,9가 고장난 경우에는.....
___     
* 6,7,8이 고장났고, 5457에 이동하고 싶은 경우를 생각해보자   
* 5,4,3,5,+,+,+,5,4,-,-,5,4,5,5,+,+는 절대 정답이 될 수 없다.  
* +나 -를 누르다가 숫자 버튼을 누르는 순간 그 전까지 입력한 것이 모두 의미 없어진다.  
* 이 문제는 버튼을 누르는 횟수의 최솟값을 구하는 문제이다. 
* 의미없는 것이 있는 방법은 절대 최소가 될 수 없다.    
* 5,4,5,5,-,-,+,+,+,+ 는 절대 정답이 될 수 없다.   
* -와 +가 불필요하게 들어가서 중복이 되기 때문이다.  
___
* 따라서, 숫자 버튼을 누르고, 그 다음 +나 -중 하나만 **연속해서 눌러야 한다.**    
* 이동하려고 하는 채널 N (0 <= N <= 500,000)   
* 숫자 버튼을 눌러서 이동하는 채널 C도 0 <= C <= 500,000 이면 된다.    
* 아니다
* 500,000에 이동해야 하고, 1과 5만 누를 수 있는 경우  
* 155,555 -> 500,000 보다 (+344,445번) 
* 511,111 -> 500,000 보다 (-11,111번)
* 숫자 버튼을 눌러서 이동하는 채널 C도 0 <= C <= 1,000,000 이면 된다.

**소스 코드**
```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

bool broken[10];
int possible(int c){
	if(c==0){ // c가 0일경우 -> 0이 들어 올 경우 
		if(broken[0]) return 0; // broken[0] 가 true 이면 0리턴 
		else return 1; // false 이면 1 리턴 
	}
	int len = 0;
	while(c > 0){ // 1의 자리에서 나누기하면 0이된다.
		if(broken[c % 10]){ // c % 10 나머지 broken이 true이면 0 리턴    
			return 0; // 0을 리턴하고 함수 종료 
			// 어차피 밖에서 모든 숫자를 다 돌리기에
			// 하나라도 부서진 버튼이 있다면 0을 리턴하자
			// 그래야 적은 수 비교할때 0으로 리턴한값은 값이 크므로
			// 
		}
		len += 1;
		c /= 10;
	}
	return len; // 하나라도 부서진 숫자가 없으면 리턴 될 수 있다.
}

int main() {
	int n; // 이동할 값 
	cin >> n;
	int m; // 부서진 리모컨 숫자  
	cin >> m;
	for(int i=0; i < m; i++){
		int x;
		cin >> x;
		broken[x] = true; // 부서진 숫자는 true 로 처리해준다.  
	}

	int ans = n-100; // 현재 위치가 100이여서 100을 빼준다?  
	if(ans < 0){     
		ans = -ans;  // 이동할 곳이 100 이하 일경우는 절대값으로 취해준다.   
	}
	for(int i=0; i <= 1000000;i++){ // 찾는값에서 멀수록 press 값이 증가되어 정답에서 멀어진다.  
		int c = i; // 무식하게 0번 채널부터 1000000채널까지 다 뒤진다.  
		int len = possible(c); // 각 채널마다의 길이  
		if(len > 0){ // possible에서 0이상의 값이 나오면  
			int press = c-n; // c는 누를 수 있는 값이고 n은 찾는값
			// press 는 +/-를 연속해서 누르는 갯수를 의미한다.   
			if(press < 0){ // 현재 반복횟수 - 100이 음수이면 절대값 
				press = -press;
			}
			if(ans > len+ press){ // possible로 얻은 수 + 연속+/-갯수가 더 작을 경우
				ans = len + press; // ans 는 작은 값으로 들어온다.  
			}
		}
	}
	cout << ans << "\n";
	return 0;
}
```
      
# 6. 그냥 다 해보기 - 테트로미노  
* 폴리오미노는 크기가 1x1인 정사각혀을 여러개 이어 붙여서 만든 도형이다.
* 정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 5가지 있다.  
* n x m 크기의 종이위에 테트로 미노를 하나놓아서   
* 놓인 칸에 쓰여 있는 수의 합을 최대로 하는 문제
* 4 <= N, M <= 500
* 회전과 대칭도 가능하다
* 이는 블록이 총 19가지가 가능하다고 말하는 것과 같다.  
___
1. 어떤 테트로미노를 하나 고르는 것 -> 19가지 경우의 수  
2. 어디에 놓을지를 고르는것 -> nxn
3. O(NM)

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

int main(void){
	int y, x;
	cin >> y >> x;

	vector<vector<int>> a (y, vector<int>(x,0));
	for(int i=0; i < y; i++){
		for(int j=0; j < x; j++){
			cin >> a[i][j];
		}
	}
	int ans = 0;
	for(int i=0; i < y; i++){
		for(int j=0; j < x; j++){
			if(j+3 < x){
				int temp = a[i][j] + a[i][j+1] + a[i][j+2] + a[i][j+3];
				if(ans < temp) ans = temp;
			}
			if(i+3 < y){
				int temp = a[i][j] + a[i+1][j] + a[i+2][j] + a[i+3][j];
				if(ans < temp) ans = temp;
			}

			if (i+1 < y && j+2 < x) {
				int temp = a[i][j] + a[i+1][j] + a[i+1][j+1] + a[i+1][j+2];
				if (ans < temp) ans = temp;
			}
			if (i+2 < y && j+1 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i+1][j] + a[i+2][j];
				if (ans < temp) ans = temp;
			}
			if (i+1 < y && j+2 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i][j+2] + a[i+1][j+2];
				if (ans < temp) ans = temp;
			}
			if (i+2 < y && j-1 >= 0) {
				int temp = a[i][j] + a[i+1][j] + a[i+2][j] + a[i+2][j-1];
				if (ans < temp) ans = temp;
			}
			if (i-1 >= 0 && j+2 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i][j+2] + a[i-1][j+2];
				if (ans < temp) ans = temp;
			}
			if (i+2 < y && j+1 < x) {
				int temp = a[i][j] + a[i+1][j] + a[i+2][j] + a[i+2][j+1];
				if (ans < temp) ans = temp;
			}
			if (i+1 < y && j+2 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i][j+2] + a[i+1][j];
				if (ans < temp) ans = temp;
			}
			if (i+2 < y && j+1 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i+1][j+1] + a[i+2][j+1];
				if (ans < temp) ans = temp;
			}
			if (i+1 < y && j+1 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i+1][j] + a[i+1][j+1];
				if (ans < temp) ans = temp;
			}
			if (i-1 >= 0 && j+2 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i-1][j+1] + a[i-1][j+2];
				if (ans < temp) ans = temp;
			}
			if (i+2 < y && j+1 < x) {
				int temp = a[i][j] + a[i+1][j] + a[i+1][j+1] + a[i+2][j+1];
				if (ans < temp) ans = temp;
			}
			if (i+1 < y && j+2 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i+1][j+1] + a[i+1][j+2];
				if (ans < temp) ans = temp;
			}
			if (i+2 < y && j-1 >= 0) {
				int temp = a[i][j] + a[i+1][j] + a[i+1][j-1] + a[i+2][j-1];
				if (ans < temp) ans = temp;
			}
			if (j+2 < x) {
				int temp = a[i][j] + a[i][j+1] + a[i][j+2];
				if (i-1 >= 0) {
					int temp2 = temp + a[i-1][j+1];
					if (ans < temp2) ans = temp2;
				}
				if (i+1 < y) {
					int temp2 = temp + a[i+1][j+1];
					if (ans < temp2) ans = temp2;
				}
			}
			if (i+2 < y) {
				int temp = a[i][j] + a[i+1][j] + a[i+2][j];
				if (j+1 < x) {
					int temp2 = temp + a[i+1][j+1];
					if (ans < temp2) ans = temp2;
				}
				if (j-1 >= 0) {
					int temp2 = temp + a[i+1][j-1];
					if (ans < temp2) ans = temp2;
				}
			}
		}
	}
	cout << ans << '\n';
	return 0;
}
```
```c++
#include <iostream>
using namespace std;
int a[500][500];
int block[19][3][2] = {
    {{0,1}, {0,2}, {0,3}},
    {{1,0}, {2,0}, {3,0}},
    {{1,0}, {1,1}, {1,2}},
    {{0,1}, {1,0}, {2,0}},
    {{0,1}, {0,2}, {1,2}},
    {{1,0}, {2,0}, {2,-1}},
    {{0,1}, {0,2}, {-1,2}},
    {{1,0}, {2,0}, {2,1}},
    {{0,1}, {0,2}, {1,0}},
    {{0,1}, {1,1}, {2,1}},
    {{0,1}, {1,0}, {1,1}},
    {{0,1}, {-1,1}, {-1,2}},
    {{1,0}, {1,1}, {2,1}},
    {{0,1}, {1,1}, {1,2}},
    {{1,0}, {1,-1}, {2,-1}},
    {{0,1}, {0,2}, {-1,1}},
    {{0,1}, {0,2}, {1,1}},
    {{1,0}, {2,0}, {1,1}},
    {{1,0}, {2,0}, {1,-1}},
};
int main() {
    int n, m;
    cin >> n >> m;
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            cin >> a[i][j];
        }
    }
    int ans = 0;
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            for (int k=0; k<19; k++) {
                bool ok = true;
                int sum = a[i][j];
                for (int l=0; l<3; l++) {
                    int x = i+block[k][l][0];
                    int y = j+block[k][l][1];
                    if (0 <= x && x < n && 0 <= y && y < m) {
                        sum += a[x][y];
                    } else {
                        ok = false;
                        break;
                    }
                }
                if (ok && ans < sum) {
                    ans = sum;
                }
            }
        }
    }
    cout << ans << '\n';
    return 0;
}
```
