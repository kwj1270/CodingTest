다이나믹 프로그래밍 도전
=======================  
# 1. 동물원  
* 가로로 두 칸, 세로로 N칸인 동물원이 있다.  
* 가로, 세로로 붙어 있게 배치하면 안된다.  
* 가능한 배치의 수
___
  
* D[i] = 세로 크기가 i인 동물원을 채우는 방법의 수, 단 i번째 줄에는 동물이 있어야 한다.       
* i번째 줄의 이전에 동물이 있는 줄은 어디일까?        
___  
* i-1번째 줄일 수도 있고, i-2일 수도 있고, ... , 2,1일 수도 있다.       
즉, i 이전에는 동물들은 존재할 수도 존재 안할 수도 있다.    
* d[]는 동물원을 채우는 방법의 수 이므로     
* i 이전에 동물들을 채우는 방법의 수는 d[i-1]+ D[i-2]+...+D[2]+D[1]이다.    
단 위의 방법은 붙어있으면 안된다는 조건을 무시한 방법의 수이다.  
___
* 이제 붙어 있게 배치할 수 없는 문제의 조건을 추가해보자       
* 우리가 가정하는 것이 마지막에 무조건 동물을 넣는 것이니까 i번째에 동물이 있다고 가정하자     
* i-1번째 줄은 한가지(i에 의해 종속) i-2번째 줄부터는 2가지씩 가능하다.(O,X 아무거나)     
* 이를 표현하자면 ```D[i-1] + 2×D[i-2] + … + 2×D[2] + 2×D[1]```이다.   
* 이를 다시 표현하면 ```D[i-1] + 2(D[i-2] + … + D[2] + D[1])``` 이다.  
![동물원 제한 경우](https://user-images.githubusercontent.com/50267433/80858974-4a701b00-8c98-11ea-90b0-51cc45a7fe56.PNG)  

하지만 위의 계산식처럼 연산을 진행할 경우 O(n2)에 해결하는 방식이다.    
    
**우리는 이를 해결하기 위해서 다른 방법을 고안해보자**      
___
* D[i] = 세로 크기가 i인 동물원을 채우는 방법의 수, 단 i번째 줄에는 동물이 있어야 한다.       
* S[i] = D[0] + D[1] + D[2] + ... + D[i]를 저장한다면        
* D[i] = D[i-1] + 2(D[i-2]+...D[2]+D[1])를 
* D[i] = D[i-1] + 2 * S[i-2] 로 구현할 수 있다.   
* 그래서 이를 이용하면 O(N)이 가능하다.  

```c++
#include <iostream>
using namespace std;
int d [100001];
int s [100001];
int main() {
	int n;
	cin >>n;
	
	d[0]=1;
	s[0]=1;
	d[1]=2;
	s[1]=d[0]+d[1];
	
	for (int i=2;i<=n;i++) {
		d[i]=d[i-1]+2*s[i-2];
		s[i]=s[i-1]+d[i];
		d[i]=d[i]% 9901;
		s[i]=s[i]% 9901;
	}
	
	cout <<	s[n] << '\n';
	
	return	0;
}
```
    
***
# 2. RGB 거리2 

* RGB 거리에 사는 사람들은 집을 빨강, 초록, 파랑중에 하나로 칠하려고 한다
* 또한, 그들은 모든 이웃은 같은 색으로 칠할 수 없다는 규칙도 정했다.  
* 집 i의 이웃은 집 i-1과 집 i+1이고, 첫 집과 마지막 집도 이웃이다.  
* 처음 집과 마지막 집은 이웃이 아니다.  
* 각 집을 빨강으로 칠할 때 드는 비용,  
초록으로 칠할 때 드는 비용,  
파랑으로 드는 비용이 주어질 때,  
모든 집을 칠하는 비용의 최솟값을 구하는 문제
___
  
* D[i][j] = i번 집을 색 j로 칠했을 때, 1~i번 집을 칠하는 비용의 최소값 
	* j = 0 -> 빨강 
	* j = 1 -> 초록
	* j = 2 -> 파랑 
* D[i][j] = i번 집을 색 j 로 칠했을 때, 1~i번 집을 칠하는 비용의 최소값     

```c++
	d[i][0] = min(d[i-1][1],d[i-1][2])+p[i][0];
	d[i][1] = min(d[i-1][0],d[i-1][2])+p[i][1];
	d[i][2] = min(d[i-1][0],d[i-1][1])+p[i][2];
```
* 하지만, 이런 식으로는 정답을 구할 수 없다.  
* 1번 집과 N번 집이 같은 색이 되지 않아야 한다.  
* 1번 집과 N번 집의 색은 다음 6가지가 가능하다.  
	* 빨강, 초록
	* 빨강, 파랑
	* 초록, 빨강
	* 초록, 파랑 
	* 파랑, 빨강
	* 파랑, 초록
* 1번 집의 색상을 미리 정해놓은 다음, 다이나믹을 3번 수행해서 정답을 구할 수 있다.  	
___


```c++
#include <iostream>
#include <algorithm>
using namespace std;

int d[10001][3];
int p[10001][3];

int main(void) { 
	ios_base::sync_with_stdio(false);
	int n;
	cin >> n;

	for(int i=1; i <= n; i++){
		for(int j=0; j < 3; j++){
			cin >> p[i][j];
		}
	}

	int result = 1000*1000+1;
	
	for(int k=0; k<=2; k++){ // k는 0~2 까지 돈다  -> 처음을 지정하는것 k는 처음
		for(int j=0; j <=2; j++){ // 뒤 인덱스가 0 1 2 돈다
			// 맨처음 반복은 0부터 시작하므로 뒤에가 0이 아닌 것들은 20001 값 가짐
			// 0은 d[1][0] = p[1][0] 의 값을 가지게 된다.  
			// 이는 1도 마찬가지 2도 마찬가지  
			if(j == k) d[1][j] = p[1][j]; // 처음으로 지정된 수가 맞으면 값 넣기
			else d[1][j] = 1000*1000+1; // 처음으로 지정된 수가 아니면 다른 값 
		}
		for(int i=2; i <=n; i++){
			d[i][0] = min(d[i-1][1],d[i-1][2])+p[i][0]; // 지정한 값이 작을테고
			d[i][1] = min(d[i-1][0],d[i-1][2])+p[i][1]; // 그 지정한 값들중에 대한 
			d[i][2] = min(d[i-1][0],d[i-1][1])+p[i][2]; // 값을 할당
		}

		for(int j=0; j<=2; j++){
			if(j == k) continue; // 처음기준이랑 같으면 넘겨서 계산조차 못하게 하자  
			result = min(result,d[n][j]); // 기준이 다른 값들끼리만 비교해서 값 도출  
		}
	}

	cout << result << "\n";
	return 0;
}
```
      
***
# 3. 합분해 
* 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수  
* D[K][N] = 0 부터 N 까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수  
* D[K][N] = ΣD[K-1][L] (0 <= L <= N)   
* D[K][N] = D[K-1][0] + D[K-1][1] + ... + D[K-1][N-1] + **D[K-1][N]**
* D[K][N-1] = **D[K-1][0] + D[K-1][1] + ... + D[K-1][N-1]**
___
* D[K][N] = D[K-1][N] + D[K][N-1]    

```c++
#include <iostream>
#include <algorithm>
using namespace std;

long long d[201][201]; // 카운트 k , 값 n

int main(void) { 
	ios_base::sync_with_stdio(false);
	
	int n, k;
	cin >> n >> k;

	d[0][0] = 1;
	for(int i=1; i <= k; i++){
		for(int j=0; j <=n; j++){
			d[i][j] = d[i-1][j]; // 0~20 까지 돈다 			
			if (j-1 >= 0) { // 이건 단순히 0 -1 을 막기위해서 사용  
                		d[i][j] += d[i][j-1];
            		}
			d[i][j] %= 1000000000;
		}
	}
	cout << d[k][n] << "\n";
	return 0;
}
```
**일차원으로 계산하기**    
   
* D[K][N] = D[K][N-1] + D[K-1][N]의 경우  
* 일차원 다이나믹으로 바꿀 수 있다.  
* D2[N] = D[K][N]을 넣을 예정 
___
1. D2[N-2] = D2[N-3] + D2[N-2]
2. D2[N-1] = D2[N-2] + D2[N-1]
3. D2[N] = D2[N-1] + D2[N]

```c++
#include <iostream>
using namespace std;
long long d[201];
const long long mod = 1000000000;
int main() {
    int n, m;
    cin >> n >> m;
    d[0] = 1;
    for (int i=1; i<=m; i++) {
        for (int j=1; j<=n; j++) {
            d[j] += d[j-1];
            d[j] %= mod;
        }
    }
    cout << d[n] << '\n';
    return 0;
}
```
