그래프1 문제  
=======================
# 1. ABCDE

* 총 N명의 친구 관계가 주어졌을 때  
* 다음과 같은 친구 관계가 존재하는지 구하는 문제  
* A는 B와 친구다. -> 간선리스트 
* C는 D와 친구다. -> 간선리스트
* B는 C와 친구다. -> 인접 행렬
* D는 E와 친구다. -> 인접 리스트   
``` a-b-c-d-e ```

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>

using namespace std;

bool a[2000][2000]; // 인접 행렬 -> 2차원배열  
vector<int> g[2000]; // 인접 리스트 -> vector<int>의 2000개 배열 -> 2차원 배열 비슷  
vector<pair<int,int>> edges; // 간선 리스트 -> 매핑 배열 -> 2차원 배열인데 매핑 

int main(int argc, char* argv[]) {
	int n, m; 
	cin >> n >> m;

	for(int i=0; i<m; i++){
		int from, to;
		cin >> from >> to;

		/// 간선 리스트 ///
		// 양방향이기에 두번넣어준다 // 
		edges.push_back({from, to}); 
		edges.push_back({to, from});

		/// 인접 행렬 /// 
		// 양방향이기에 두번넣어준다 // 
		a[from][to] = a[to][from] = true; 

		/// 인접 리스트 ///
		// 양방향이기에 두번넣어준다 // 
		g[from].push_back(to);
		g[to].push_back(from);	
	}
	m *=2 ; // 입력으로 주어진 m은 친구 관계의 수이다.
	// 4개를 넣었지만 양방향으로 입력을 했으니 2배가 필요하다  

	// 그런데 양방향으로 설정해서 2개씩 넣어 줬으니 간선 관계는 2배로 해준 것이다.  
	for(int i=0; i<m; i++){
		for(int j=0; j < m; j++){
			// 아마 4개의 관계를 넣었지만 양방향이므로 8번 돌고
			// ABCD는 서로 달라야 하니 같으면 continue 

			// A->B 가는것 찾기  
			int A = edges[i].first; // pair의 특징 키값
			int B = edges[i].second; // pair의 특징 밸류값  
			
			// C->D 가는것 찾기 
			int C = edges[j].first; 
			int D = edges[j].second;

			if(A == B || A == C || A == D || B == C || B == D || C == D) continue; // 같은 사람이 있는지 테스트 
			// B -> C
			if(!a[B][C]) continue;
			// D -> E 
			for(int E : g[D]){
				if(A == E || B == E || C == E || D == E) continue; // 같은 값 나오면 continue
				cout << 1 << "\n";
				return 0; // 찾았다.
			}
		}
	}
	cout << 0 << "\n";
	return 0;
}
```
간선리스트에 대해서 다시 생각해보자  
간선리스트 전에    
    
인접 행렬은 둘 사이의 관계를 true/false로 나타낸것으로 M x M 형태를 띈다. (2차원 bool 배열)       
인접 리스트는 정점을 기준으로 연결된 모든 간선을(정점)을 리스트로 저장한다.(배열 안에 리스트로 저장)
(2차원 배열 또는 배열안에 리스트로 저장 -> c++에서는 가변 배열인 vector 존재)
           
간선 리스트는 배열 안에 매핑으로 저장된 형태이다.          
그렇기 때문에 간선리스트 배열의 크기는 간선의 갯수라고 보면 된다.(양방향이면 2배)      
가독성을 높이기 위해서 안에 있는 내용들을 정렬해서 넣은 것인지 무조건 할 필요는 없다.  
