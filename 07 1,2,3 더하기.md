1,2,3 더하기
=======================
# 1. 1로 만들기  
* 정수 X에서 사용할 수 있는 연산은 다음과 같이 3가지이다.    
1. X가 3으로 나누어 떨어지면, 3으로 나눈다.  
2. X가 2로 나누어 떨어지면, 2로 나눈다.  
3. 1을 뺀다. 

* 어떤 정수 N에 위와 같은 연산을 선택해서 1을 만드려고 한다. 연산을 사용하는 횟수의 최소값을 구하자      
   
즉 3개의 연산중에 하나를 선택해서 1을 만드는 방법을 취하라는 것이다.  

**내가 짠 코드**
```c++
#include <iostream>
#include <vector>
using namespace std;


int getCount(int num, int count){
	if(num == 1){
		return count;
	}
	count++;
	int first = 99999;
	int second = 99999;
	if(num % 3 == 0){
		first = getCount(num/3, count);
	}
	if(num % 2 == 0){
		second = getCount(num/2, count);
	}
	int last = getCount(num-1, count);
	return min(min(first, second),last);
}

int main(void) { 
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int N; // 동생의 수 , 내 위치  
	cin >> N ;
	cin.ignore();

	cout << getCount(N, 0) << "\n";

    return 0; 
}
```
위와 같이 코드를 짤 경우 중복된 경우의 수가 너무 많아지기 때문에 연산 속도가 크게 증가된다.       
    
**Top-down 재귀방식**
```
#include <iostream>
using namespace std;

int d [1000001];
int getCount(int n){
	if(n == 1) return 0;
	if(d[n] > 0) return d[n];
	d[n] = getCount(n-1) +1; 
	if(n % 2 == 0){
		int temp = getCount(n/2)+1;
		if(d[n] > temp) d[n] = temp;
	}
	if(n % 3 == 0){
		int temp = getCount(n/3)+1;
		if(d[n] > temp) d[n] = temp;
	}
	return d[n];
}

int main(void) { 
    int n;
	cin >> n;
	cout << getCount(n) << "\n";
    return 0; 
}
}
``` 
우선 다이나믹 프로그래밍은    
* 각 문제는 한 번만 풀어야 한다.    
* Overlapping Subproblem, Optimal Substructure 속성을 이용한다.      
* 즉, 큰 문제를 작은 문제로 분할하여 계산을 진행하는 것이다.   
    
이러한 특징을 이용해서 위와 같은 코드를 작성했다.       
1. 중복된 경우의 수를 제외 하기 위해서 memorization 도입      
2. 큰 문제를 작은 문제로 나누면 되는데 어렵게 생각 말고 작게 나눈다. d[n/3]+1, d[n/2]+1, d[n-1]+1    
3. +1을 진행하는 이유는 횟수가 1회 증가 되었고      
4. 밖에서 카운트를 증가 시켜주기에 ```(i==1)``` 일때는 0을 리턴한다.    
5. 가장 최소한의 경우의 수를 구하므로 비교를 진행하여 작은 값을 리턴한다.      
        
그런데 궁금한 점은 왜 n-1 부터 계산을 들어갔는가인데 이는 최솟값을 편하게 구하기 위해서이다.           
n-1은 큰 조건이 없는 즉, 아무때나 연산될 가능성이 더 높기 때문에 비교시 기준 값으로 맞추어 놓은 것이다.           
        
**Bottom-up 반복문 방식**    
```c++
#include <iostream>
using namespace std;

int d [1000001];
int getCount(int n){
	d[1] = 0;
	for(int i = 2; i <= n; i++){
		d[i] = d[i-1]+1;
		if(i%2 ==0 && d[i] > d[i/2]+1 ) d[i] = d[i/2]+1;
		if(i%3 ==0 && d[i] > d[i/3]+1 ) d[i] = d[i/3]+1;
	}
	return d[n];
}

int main(void) { 
    int n;
	cin >> n;
	cout << getCount(n) << "";
    return 0; 
}
```
Bottom-up 방식도 작은 문제부터 큰 문제를 도출하고     
앞선 점화점을 그대로 이용하여 풀어주면 된다.       
    
***
# 2. 2 x N 타일링  
* 2 X N 직사각형을 1 x 2 , 2 x 1 타일로 채우는 방법의 수  
* 아래 그림은 2 x 5 를 채우는 방법의 수 
* D[n] = 2 x n 직사각형을 채우는 방법의 수


## 2.1. Top-down
Top-down 방식은 큰 문제를 작은 문제로 나누어서 푸는 것이다.  

1. 큰 문제를 작은 문제로 나눈다.  
2. 작은 문제를 푼다.  
3. 작은 문제를 풀었으니, 이제 큰 문제를 푼다.   
    
Top-down 방식은 이전에 우리가 했던 **재귀를 이용한** 피보나치 수열을 의미한다.     
큰 재귀 함수로부터 작은 재귀로 나뉘어져 작은 문제들을 해결하면서 올라오기 때문이다.   

1. 문제를 풀어야 한다. 
   * fibonacci(n)
2. 문제를 작은 문제로 나눈다.
   * fibonacci(n-1) 과 fibonacci(n-2)로 문제를 나눈다.  
3. 작은 문제를 푼다.  
   * fibonacci(n-1) 과 fibonacci(n-2)를 호출하여 문제를 푼다.   
4. 작은 문제를 풀었으니, 이제 문제를 푼다.  
   * fibonacci(n-1) 값과 fibonacci(n-2)의 값을 더해 문제를 푼다.   

**피보나치 수열**   
```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    if(memo[n] > 0){ // 여기서 0은 아직 값을 넣지 않았다는 뜻
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```

## 2.2. Bottom-up     
Botton-up 방식은 작은 문제부터 연산하여 큰 문제를 푸는 것이다.     
Top-down 방식과 헷갈리지만       
Top-down은 큰 문제에서 시작해서 작은 문제로 나누어 푸는것이고      
Botton-up은 애초에 작은 문제를 풀어서 후에 큰 문제를 푸는 것으로 시작 환경이 다르다.      

1. 문제를 크기가 작은 문제부터 차례대로 푼다.  
2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.  
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.  
4. 반복하다 보면 가장 큰 문제를 풀 수 있다.

**Bottom-up 방식의 피보나치 수열**
```c++
int d[100];
int fibonacci(int n){
   d[0] = 0;
   d[1] = 1;
   for(int i=2; i <= n; i++){
      d[i] = d[i-1] + d[i-2];
   }
   return d[n];
}
```
1. 문제를 크기가 작은 문제부터 차례대로 푼다.  
   * for(int i=2; i <= n; i++)
2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
   * for(int i=2; i <= n; **i++**)
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.  
   * d[i] = d[i-1] + d[i-2];
4. 반복하다 보면 가장 큰 문제를 풀 수 있다.
   * d[n]을 구하게 된다.  
