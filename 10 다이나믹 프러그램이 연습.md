합분해까지
=======================  
# 1. 1,2,3 더하기 3  
* 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제  
* n = 4
* 1+1+1+1
* 1+1+2
* 1+2+1
* 2+1+1
* 2+2
* 1+3
* 3+1
   
이전에 했던 방법에 최적의 연산을 사용해야하고 숫자만 바꿔준것    
    
**코드**
```c++

#include <iostream>
using namespace std;

long long d[1000000];
int main() {

	int t;
	cin >> t;
	cin.ignore();

	while(t--){
		ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);

		int n ;
		cin >> n;
		cin.ignore();

		d[0] = 1;
		d[1] = 1;
		d[2] = 2;
		d[3] = 4;

		for (int i=4; i<=n; i++) {
			d[i] = 0;
		}
		for (int i=4; i <= n; i++) {
				d[i] += (d[i-1]+d[i-2]+d[i-3]) % 1000000009; 
		}
		cout << d[n] << "\n";
	}
}
```
    
    
    
***    
# 2. RGB거리           
* RGB 거리에 사는 사람들은 집을 빨강, 초록, 파랑중에 하나로 칠하려고한다.  
* 또한, 그들의 모든 이웃은 같은 색으로 칠할 수 없다는 규칙도 정했다.   
* 집 i의 이웃은 집 i-1과 집 i+1이고, 첫 집과 마지막 집은 이웃이 아니다.  
* 처음 집과 마지막 집은 이웃이 아니다.    
* 각 집을 빨강으로 칠할 때 드는 비용, 초록으로 칠할 때 드는 비용, 파랑으로 드는 비용이 주어질 때, 
모든 집을 칠하는 비용의 최솟값을 구하는 문제

* d[i][j] = i번 집을 색 j로 칠했을 때, 1~i번 집을 칠하는 비용의 최솟값     
	* j = 0 -> 빨강 
	* j = 1 -> 초록
	* j = 2 -> 파랑
* d[i][j] = i번 집을 색 j로 칠했을 때,  1~i번 집을 칠하는 비용의 최소값     
```
즉, 3개로 가정시 
[3][0] 이면 3번째 집이 [0]으로 끝나는 값
[3][1] 이면 3번째 집이 [1]으로 끝나는 값
[3][2] 이면 3번째 집이 [2]으로 끝나는 값

그렇다면 min(d[3-1][1],d[3-1][2])는 무엇일까? 왜 min을 한거지?
그림으로 그려보면 이해가 쉽다.  
d[2][1] 은 2개이고 마지막이 1로 끝나는 값이고 
d[2][2] 은 2개이고 마지막이 2로 끝나는 값이다.   

여기서 우리가 생각을 잘못하는 것이 있는데 d[][] 자체가 이미 최솟값을 의미하는 것으로  
너무 복잡하게 생각하지 말아야한다.  
나는 왜 2개를 합치지 않고 최소값을 구하는거지? 라고 생각했는데 
우리는 최솟값을 구하는것이지 모든 방법의 가격을 구하는 것이 아니다. 
즉, 2개중 1로 끝나는 최솟값이랑 2개중 2로 끝나는 최솟값만 있는 것이고 이를 비교하는 것일 뿐이다.  
그래야 3번째 가격을 더하더라도 가장 최솟값을 구할 수 있다.  
```

**코드**
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int d[10001][3];
int p[10001][3];

int main(void) { 
	
	int n;
	cin >> n;
	cin.ignore();

	for(int i=1;i <=n; i++){
		for(int j=0; j < 3;j++){
			cin >> p[i][j];
	
		}
	}
	for(int i=1; i <=n; i++){
		d[i][0] = min(d[i-1][1],d[i-1][2])+p[i][0];
		d[i][1] = min(d[i-1][0],d[i-1][2])+p[i][1];
		d[i][2] = min(d[i-1][0],d[i-1][1])+p[i][2];
	}
	cout << min(min(d[n][0], d[n][1]), d[n][2]) << "\n";

	return 0;
}
```
       
***    
# 3. 동물원       
* 가로로 두 칸, 세로로 N칸인 동물원이 있다.       
* 가로, 세로로 붙어있게 배치하면 안된다.       
* 가능한 배치의 수         
        
* D[N][0] = N번 줄에 배치하지 않음      
* D[N][1] = N번 줄의 왼쪽에만 배치함         
* D[N][2] = N번 줄의 오른쪽에만 배치함     
      
* D[N][0] = d[N-1][0] + d[N-1][1] + d[N-1][2]     
* D[N][1] = d[N-1][0] + d[N-1][2]         
* D[N][2] = d[N-1][0] + d[N-1][1]       
     
**코드**
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int d[100001][3]; // 2x1을 넣는데 양쪽에 넣으면 안된다.

int main(void) { 
	
	int n;
	cin >> n;
	cin.ignore();

	d[0][0] = 1;
	for(int i=1; i <= n; i++){
		d[i][0] = (d[i-1][0] + d[i-1][1] + d[i-1][2]) % 9901; 
		d[i][1] = (d[i-1][0] + d[i-1][2]) % 9901;
		d[i][2] = (d[i-1][0] + d[i-1][1]) % 9901;
	}

	cout << (d[n][0]+d[n][1]+d[n][2]) % 9901 << "\n";

	return 0;
}
```

***
# 4. 오르막 수     
* 오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다.         
* 인접한 수가 같아도 오름차순으로 친다.            
* 수의 길이가 N이 주어졌을 때, 오르막 수의 개수를 구하는 문제        
* 수는 0으로 시작할 수 있다.       
* 예: 1233345, 357, 888888, 1555999      
   
* d[i][j] = 길이가 i이고 마지막 숫자가 j인 오르막 수의 개수  
* d[1][i] = 1
* d[i][j] += d[i-1][k <= j]    
     
```  
내가 여기서 헷갈린게 오르막수인데  
계단식 처럼 1칸씩 올라가야 한다고 생각을 했다.    
그것이 아니라 현재 칸 보다 이하의 숫자면 되는데 이해를 잘못 했다.  
```    


```c++
#include <iostream>
using namespace std;
int d[100001];
int main() {
    int n;
    cin >> n;
    for (int i=1; i<=n; i++) { // d[n] 을 구하기 위함 
        d[i] = i; // 2 같은 수들을 위한 최기화 진행  
		// 초기화를 왜 이렇게 진행했을까? -> 최대 많은 수는 1로 n번 더한것이므로  
		// 카드 구매하기2 처럼 초기값을 0으로 한 이유는 
		// 최소값일 때는 초기화를 0으로 하면 안된다. 
        for (int j=1; j*j <= i; j++) { // n까지 구하는 것이므로 루트n 까지만 생각
            if (d[i] > d[i-j*j]+1) { // i=4 부터 판단 가능 -> j는 2까지 가능 4 > 3 이므로
                d[i] = d[i-j*j]+1; 
			}
        }
    }
    cout << d[n] << '\n';
    return 0;
}
```
여기서 중요한 점은 초기 값을 왜 저렇게 주었느냐이다 이부분을 잘 생각해보자  
     
***  
# 4. 합분해
* 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수   
* D[k][n] = 0 부터 n 까지의 정수 k개를 더해서 그 합이 n이 되는 경우의 수  
* ?+?+?+?....+?+L = N   
* 위의 식이 나타내는 값 D[K][N]   
* ?+?+?+?....+?= N-L
* 위의 식이 나타내는 값 D[K][N-L]    
* D[K][N-L] = 시그마[k-1][N-L] (0 <= L <= N)

```c++
#include <iostream>
using namespace std;
long long d[201][201];
long long mod = 1000000000;
int main() {
    int n, k;
    cin >> n >> k;
    d[0][0] = 1LL;  // 이건 이유를 잘 모르겠다 다시 봐야겠다.   

    for (int i=1; i<=k; i++) {
        for (int j=0; j<=n; j++) {
            for (int l=0; l<=j; l++) {
                d[i][j] += d[i-1][j-l];
                d[i][j] %= mod;
            }
        }
    }
    cout << d[k][n] << '\n';
    return 0;
}
```
아마 이부분이 이해하기가 가장 어려운 부분이 아니었나 싶다.   
코드를 해석해보면서 이해를 해보도록 하자  
```20 2```이라고 입력을 진행을 한다면 2개의 식을 통해서만 20을 도출해야 한다.

```
a1 + a2  =  20
___K____   __N__
```
그럼 여기서 한 단계를 물러나서 생각하면 어떻게 될까?
```
a1  =  20-a2
__K-1__   __N-a2__
```
가 되고 ```K는 기존 K-1``` 이고 ```N은 n-a2```이다.            
a1과 a2는 정해진 수가 아니기에 a2를 추가적으로 ```L```이라는 이름을 가지도록 했다.       
         
a1과 a2는 서로의 값에 의해서 결정되기에     
앞서 ```k-1```에서의 값에 따라서 후에 값이 달라진다.      
즉, ```k-1```에서 1을 더했으면 ```k```에서는 19가 더해져야하고    
```k-1```에서 2를 더했으면 ```k```에서는 18이 더해져야한다.         
그리고 이렇게 구한 값들도 이미 이전에 얻은 경우의수들이 있으므로     
사실상 [n]은 [n-L]에 대한 모든 경우의 수를 합한 값이 되어야 한다.    
즉 ```반복(d[k][n] += d[k-1][n-L..])``` 형태를 가지게 된 것이다.    




